{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programmieren I","text":"<p>Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache Java die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis modernen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben:</p> <ol> <li>In diesem Skript sind bereits alle Inhalte des gesamten Semesters verf\u00fcgbar. Der Grund daf\u00fcr ist der, dass Sie sich das jeweilige Thema vorab selbst\u00e4ndig erarbeiten k\u00f6nnen, indem Sie sich den jeweiligen Abschnitt bereits vor der jeweiligen Vorlesung anschauen. Ich empfehle Ihnen diese Vorgehensweise - sie hat sich bew\u00e4hrt!</li> <li>L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie m\u00fcssen irgendwann in der Lage sein, alle \u00dcbungsaufgaben selbst\u00e4ndig zu l\u00f6sen.</li> <li>Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen!</li> <li>Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung! Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. </li> <li>Programmieren lernt man nur durch Programmieren! Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, programmieren... (siehe auch hier)</li> <li>Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler! Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens.</li> <li>Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid!</li> </ol> <p>Viel Erfolg! Und viel Spa\u00df!</p>"},{"location":"#organisatorisches","title":"Organisatorisches","text":"<p>Der Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt:</p> <ul> <li>Themen werden ausf\u00fchrlich in der Vorlesung vorgestellt und in diesem Skript beschrieben.</li> <li>Es ist geplant, die neuen Themen stets vorab in diesem Skript hier zu ver\u00f6ffentlichen. Sie k\u00f6nnen sich also bereits vorab mit dem jeweiligen neuen Thema besch\u00e4ftigen. </li> <li>Zusammen mit dem Skript (das neue Thema) werden sowohl die dazugeh\u00f6rige \u00dcbung als auch die dazugeh\u00f6rige Aufgabe hochgeladen.</li> <li>Die beiden \u00dcbungen am Freitag sind jeweils gleich (d.h. dort werden die gleichen \u00dcbungsaufgaben gel\u00f6st). Die \u00dcbungen behandeln den Stoff, der am Montag und Mittwoch in der gleichen Woche besprochen wird. Das bedeutet: das neue Thema wird am Montag und Mittwoch in den Vorlesungen vermittelt und am folgenden Freitag in der \u00dcbung angewendet. </li> <li>Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie besuchen. Sie k\u00f6nnen auch beliebig w\u00f6chentlich wechseln. </li> <li>Es wird ein Tutorium angeboten (Termin wird noch bekanntgegeben). </li> <li>Sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu.</li> </ul> <p>Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen Sie die Aufgaben (Hausaufgaben) l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 8 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und mindestens 6 davon hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". </p> <p>Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht meistens jeweils einem Wochenthema. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. </p> <p>Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen, die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen.  </p> <p>F\u00fcr die Kommunikation untereinander verwenden wir Slack (Channel <code>#b11_prog1_ws2024_25</code>). Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, dass Sie sich diese gegenseitig beantworten. Damit w\u00e4re allen geholfen und wir k\u00f6nnen besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Bei Bedarf beantworten die Lehrenden die Fragen nat\u00fcrlich.  </p> <p>Das Tutorium bei Noa Sauter findet immer mittwochs um 15:45 Uhr in C 624 statt.</p>"},{"location":"#planung","title":"Planung","text":"<p>Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst).</p> Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 07.-11.10.2024 Organisatorisches, Algorithmen und Erstes Programm \u00dcbung 0 - - 2. 14.-18.10.2024 Variablen und Datentypen \u00dcbung 1 - - 3. 21.-25.10.2024 Operatoren und Ausdr\u00fccke \u00dcbung 2 - - 4. 28.-01.11.2024 Methoden und Methodenstack \u00dcbung 2a - - 5. 04.-08.11.2024 Selektion (if) und Iteration (for) \u00dcbung 3 Aufgabe 1 22.11.2024 6. 11.-15.11.2024 Iteration (while) und Methodenstack \u00dcbung 4 Aufgabe 2 29.11.2024 7. 18.-22.11.2024 Klassen und Objekte \u00dcbung 5 Aufgabe 3 06.12.2024 8. 25.-29.11.2024 Konstruktoren, this, eigene Datentypen, R\u00fcckgabe von Objekten \u00dcbung 6 Aufgabe 4 13.12.2024 9. 02.-06.12.2024 Vererbung, Object und Polymorphie \u00dcbung 7 Aufgabe 5 20.12.2024 10. 09.-13.12.2024 Arrays \u00dcbung 8 Aufgabe 6 03.01.2025 11. 16.-20.12.2024 Algorithmen \u00fcber Arrays \u00dcbung 9 Aufgabe 7 10.01.2025 12. 06.-10.01.2025 Sortieren von Arrays \u00dcbung 10 Aufgabe 8 17.01.2025 13. 13.-17.01.2025 Suchen in Arrays \u00dcbung 11 Probeklausuren - 14. 20.-24.01.2025 JavaDoc \u00dcbung 12 Probeklausuren - 15. 27.-31.01.2025 Wiederholung, Klausurvorbereitung Probeklausuren - 16. 07.02.2025 09.30-11.30 Uhr Klausur 1.PZ - - 16. 28.03.2025 09.30-11.30 Uhr Klausur 2.PZ - -"},{"location":"#code-aus-der-vorlesung","title":"Code aus der Vorlesung","text":"Vorlesung Datentypen und Variablen <pre><code>package vorlesungen.vorl1016;\n\npublic class Datentypen\n{\n    public static void main(String[] args) \n    {\n        // hier hinter koennen Sie schreiben, was Sie moechten\n        // Zeilenkommentar\n\n        /*\n            Blockkommentar ueber mehrere Zeilen\n            alles \n            noch\n            Kommentar\n        */\n\n          System.out.println(\"test test test\"); \n          System.out.println(\"test test test\");\n\n          int ganzeZahl = 0;\n          boolean wahrheitswert = true;\n          double gleitkommaZahl = 1.0;\n          char zeichen = 'a';\n          String zeichenkette = \"Das ist eine Zeichenkette\";\n\n          System.out.println(zeichenkette);\n\n          ganzeZahl = 5;\n          System.out.println(ganzeZahl);\n\n          ganzeZahl = 9;\n          System.out.println(ganzeZahl);\n\n          wahrheitswert = true;\n          gleitkommaZahl = 5.5;\n\n          gleitkommaZahl = 17.56;\n\n          double number = 1;\n          System.out.println(number);\n\n          //int numberInt = 1.0;\n          //System.out.println(numberInt);\n\n          System.out.println(ganzeZahl);\n\n          ganzeZahl = ganzeZahl + 1;\n\n          System.out.println(ganzeZahl);\n\n          byte test = 127;\n          test = (byte) (test + 1);\n          System.out.println(test);\n\n    }\n\n}\n</code></pre> Vorlesung Ausdr\u00fccke <pre><code>package vorlesungen.vorl1021;\n\npublic class Ausdruecke\n{\n\n    public static void main(String[] args)\n    {\n        System.out.println();\n        System.out.println(\"------ arithmetische Operatoren ------\");\n        System.out.println();\n        System.out.println(3 + 4);\n        System.out.println(3.0 - -4);\n        System.out.println(3 * 4);\n        System.out.println(3.0 * -4);\n        System.out.println(-4);\n        System.out.println(+4);\n        System.out.println(-4.0);\n        System.out.println(+4.0);\n        System.out.println(9 / 3);\n        System.out.println(9.0 / 3.0);\n\n        System.out.println(5 / 3);      // int-Division 1\n        System.out.println(5.0 / 3);    // double-Division 1.66\n        System.out.println(5 / 3.0);    // double-Division 1.66\n        System.out.println(5.0 / 3.0);  // double-Division 1.66\n\n        System.out.println(5 % 3);      // Rest 2\n        System.out.println(5 + 3 * 4);  // 17\n\n        int x = 3 + 4 * 5 + 6 - 7;      // 22\n        x = 3 + 4 * (5 + 6) - 7;        // 40\n        System.out.println(x);\n        x = x + 1;\n        System.out.println(x);\n        x++;                            // x = x + 1;\n        System.out.println(x);\n        ++x;\n        System.out.println(x);          // x = x + 1;\n        x+=1;\n        System.out.println(x);          // x = x + 1;\n        x*=3;                           // x = x * 3;\n        x/=3;                           // x = x / 3;\n        x-=3;                           // x = x - 3;\n        x%=3;                           // x = x % 3;\n\n        System.out.println();\n        System.out.println(\"------ Vergleichsoperatoren ------\");\n        System.out.println();\n\n        int y = 7;\n        int z = 8;\n        int w = 8;\n        System.out.println(y &lt; z);      // true\n        System.out.println(y &gt; z);      // false\n        System.out.println(y == z);     // false\n        System.out.println(z == w);     // true\n        System.out.println(y &lt;= z);     // true\n        System.out.println(y &gt;= z);     // false\n\n        System.out.println(y % 2 == 1 );    // wenn true, dann y ungerade (false: gerade)\n        System.out.println(y % 2 == 0 );    // wenn true, dann y gerade (false: ungerade)\n\n\n        System.out.println();\n        System.out.println(\"------ Zeichenkettenverbindungsoperator ------\");\n        System.out.println();\n\n\n        String s1 = \"Hello \" + \"FIW!\";\n        String s2 = \" noch mehr dazu \";\n        String s3 = s1 + s2;\n        System.out.println(s1);\n        System.out.println(s3+s1);\n\n        int a = 3;\n        System.out.println(a);\n        System.out.println(\"a = \" + a);     // \"a = \" + \"3\"\n        System.out.println(a + \" = a\");     // \"3\" + \" = a\"\n    }\n\n}\n</code></pre> Vorlesung Ausdr\u00fccke - Teil 2 <pre><code>package vorlesungen.vorl1023;\n\npublic class Ausdruecke2\n{\n\n    public static void main(String[] args)\n    {\n        int nr1 = 13;\n        int nr2 = 4;\n        int sum = nr1 + nr2;\n\n        System.out.println(nr1 + \" + \" + nr2 + \" = \" + sum);\n        System.out.println(nr1 + \" + \" + nr2 + \" = \" + (nr1 + nr2));\n\n        System.out.println();\n        System.out.println(\"--------- Logische Ausdruecke ----------\");\n        System.out.println();\n\n        boolean a = false;\n        boolean b = true;\n\n        System.out.println(a + \" &amp;&amp; \" + b + \" = \" + (a &amp;&amp; b));\n        System.out.println(a + \" ||\u00a0\" + b + \" = \" + (a || b));\n        System.out.println(\"!a = \" + !a);\n\n        int year = 2024;\n        boolean isLeapYear = ((year % 400) == 0) || \n                ((year % 4) == 0 &amp;&amp; !((year % 100) == 0));\n\n        System.out.println(\"war \" + year + \" Schaltjahr ? \" + isLeapYear);\n\n        int x = 3;\n        int y = 4; \n        int z = 5;\n\n        boolean xSmallerYSmallerZ = (x &lt; y) &amp;&amp; (y &lt; z);\n\n        int noten = 1 + 2 + 3 + 1 + 3 + 4 + 1 + 1 + 2 + 1;\n        double schnitt = noten / 10.0;\n        System.out.println(\"Durchschnitt ist \" + schnitt);\n\n        int test1 = 1;\n        double test2 = test1;\n        System.out.println(test2);\n        test2 = 1.7;\n        test1 = (int) test2;\n        System.out.println(test1);\n        System.out.println(test2);\n    }\n\n}\n</code></pre> Vorlesung Methoden <pre><code>package vorlesungen.vorl1028;\n\npublic class Methoden\n{\n    public static void add(int summand1, int summand2)\n    {\n        int summe = summand1 + summand2;\n        System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);\n    }\n\n    public static int computeSum(int summand1, int summand2)\n    {\n        int summe = summand1 + summand2;\n        return summe;\n    }\n\n    public static void main(String[] args)\n    {\n\n        add(4,5);\n        add(5,4);\n        add(7,9);\n        add(-7,19);\n        add(3,3);\n\n        int nr1 = 12;\n        int nr2 = 13;\n        int ergebnis = computeSum(nr1, nr2);\n        System.out.println(nr1 + \" + \" + nr2 + \" = \" + ergebnis);\n\n        ergebnis = computeSum(31,2);        \n    }\n}\n</code></pre> Vorlesung Methodenstack und Selektion <pre><code>package vorlesungen.vorl1030;\n\npublic class Methoden2\n{\n\n    public static double multiply(double nr1, double nr2)\n    {\n        return nr1 * nr2;\n    }\n\n    public static double multiply(double nr1, double nr2, double nr3)\n    {\n        return nr1 * nr2 * nr3;\n    }\n\n    public static double multiply(int nr1, int nr2, int nr3)\n    {\n        return nr1 * nr2 * nr3;\n    }\n\n\n    public static void printProduct(double nr1, double nr2)\n    {\n        double product = multiply(nr1, nr2); \n        System.out.println(nr1 + \" * \" + nr2 + \" = \" + product);\n    }\n\n    public static void main(String[] args)\n    {\n        double nr1 = 3.5;\n        double nr2 = 4.5;\n        printProduct(nr1, nr2);\n\n        System.out.println(multiply(3.5, 4.5, 5.5)); \n        System.out.println(multiply(3, 4 , 5)); \n        double product = multiply(3.5, 4.5); \n        System.out.println(product);\n\n        int a = 2;\n        int b = 4;\n\n        System.out.println(\"a = \" + a + \", b = \" + b);\n        if( a &gt; b )\n        {\n            // wenn a &gt; b true\n            System.out.println(\"a &gt; b -&gt; true\");\n            a = a - b;\n\n        }\n        else\n        {\n            // wenn a &gt; b false\n            System.out.println(\"a &gt; b -&gt; false\");\n            b = b - a;\n        }\n        System.out.println(\"a = \" + a + \", b = \" + b);\n\n        int n = 5;\n\n        System.out.println(\"n = \" + n);\n        if( n % 2 == 0 )\n        {\n            System.out.println(\"n gerade \");\n            n = n / 2;\n        }\n        else\n        {\n            System.out.println(\"n ungerade \");\n            n = n * 3 + 1;\n        }\n        System.out.println(\"n = \" + n);\n\n        int x = 1;\n        int y = 2;\n        int z = 3;\n\n        if( z &gt; y )\n        {\n            // z &gt; y true\n            if( y &gt; x )\n            {\n                // y &gt; x true ( &amp;&amp; z &gt; y true)\n                System.out.println(\"z &gt; y &gt; x\");\n            }\n            else\n            {\n                // z &gt; y &amp;&amp; !y&gt;x\n                if( y == x)\n                {\n                    System.out.println(\"z &gt; y == x\");\n                }\n                else\n                {\n                    // z &gt; y &amp;&amp; x &gt; y\n                }\n            }\n        }\n        else\n        {\n            // z &gt; y false\n        }\n\n    }\n\n}\n</code></pre> Vorlesung Iteration - for-Schleife <pre><code>package vorlesungen.vorl1104;\n\npublic class Iteration1\n{\n\n    public static void main(String[] args)\n    {\n        for(int i = 0; i &lt; 0; i++)\n        {\n            System.out.println(\"in der Schleife : i = \" + i);\n        }\n\n        System.out.println(\"fertig\");\n\n        System.out.println();\n        System.out.println(\"------ printSum ----------\");\n        System.out.println();\n\n        printSum1ToN(10);\n        /*\n        for(int i = 1; i &lt; 50; i++)\n        {\n            System.out.print(\" i = \" + i + \" : \");\n            printSum1ToN(i);\n        }\n        */\n    }\n\n    public static void printSum1ToN(int n)\n    {\n        int sum = 0;\n\n        for(int summand = 1; summand &lt;= n ; summand++)\n        {\n            System.out.print(summand);\n\n            if(summand &lt; n) \n            {\n                System.out.print(\" + \");\n            }\n\n            sum = sum + summand;\n        }\n\n        System.out.println(\" = \" + sum);\n    }\n\n}\n</code></pre> Vorlesung Iteration - verschachtelte for-Schleife <pre><code>package vorlesungen.vorl1106;\n\npublic class Iteration2\n{\n\n    public static void main(String[] args)\n    {\n        for(int number = -5; number &lt; 17; number++)\n        {\n            System.out.println(number + \"! = \" + factorial(number));\n        }\n\n        printRectangle(6, 4);\n        printRectangle(16, 10);\n    }\n\n    public static int factorial(int n)\n    {\n        if(n &lt; 1)\n        {\n            return 0;\n        }\n        else\n        {\n            int product = 1;    \n            for(int factor = n;  factor &gt; 1   ; factor--)\n            {\n                product = product * factor;\n            }\n            return product;\n        }\n    }\n\n    public static void printRectangle(int width, int height)\n    {\n        // kein row\n        for(int row = 1; row &lt;= height; row++)\n        {\n            // kein stars\n            // probieren Sie in der folgenden Bedingung anstelle von width mal row\n            // for(int stars = 1;  stars &lt;= width; stars++)\n            // for(int stars = width;  stars &gt; 0; stars--)\n            // for(int stars = width;  stars &gt;= 1; stars--)\n            for(int stars = 0;  stars &lt; width; stars++)\n            {\n                System.out.print(\" [\" + stars + \", \" + row + \"] \");\n                // System.out.print(\"* \");\n            }\n            // kein stars\n            System.out.println();\n        }\n        // kein row\n        System.out.println();\n    }\n\n}\n</code></pre> Vorlesung Iteration - while-Schleife <pre><code>package vorlesungen.vorl1111;\n\npublic class Iteration3\n{\n\n    public static void main(String[] args)\n    {\n        printTriangleLeft(7);\n        //printNStarsInOneRow(10);\n        //printNStarsInOneRow(1);\n\n        printCollatz(7);\n        printGGT(-148, 144);\n    }\n\n    public static void printNStarsInOneRow(int nrOfStars)\n    {\n        for(int stars = 1; stars &lt;= nrOfStars; stars++)\n        {\n            System.out.print(\"* \");\n        }\n        System.out.println();\n    }\n\n    public static void printNCharsInOneRow(int n, char c)\n    {\n        for(int stars = 1; stars &lt;= n; stars++)\n        {\n            System.out.print(c + \" \");\n        }\n    }\n\n    public static void printTriangleLeft(int height)\n    {\n\n        for(int row = 1; row &lt;= height; row++)\n        {\n            printNCharsInOneRow(height-row, ' ');\n            printNCharsInOneRow(row, '*');\n            System.out.println();\n        }\n    }\n\n    public static void printCollatz(int anfang)\n    {\n        int n = anfang;\n\n        while( n &gt; 1 )\n        {\n            System.out.print(n + \" \");\n            if(n % 2 == 0)\n            {\n                n = n/2;\n            }\n            else\n            {\n                n = 3 * n + 1;\n            }\n        }\n\n        System.out.println(n + \"      ende f\u00fcr anfang = \" + anfang);\n    }\n\n    public static void printGGT(int nr1, int nr2)\n    {\n        int a = nr1;        \n        int b = nr2;\n        if(a &lt; 0)\n        {\n            a = -a;     // wenn a negativ, dann |a|\n        }\n        if(b &lt; 0)\n        {\n            b = -b;     // wenn b negativ, dann |b|\n        }\n        if(a == 0)\n        {\n            a = b;      // wenn a gleich 0, dann b ist ggT\n        }\n        if(b == 0)\n        {\n            b = a;      // wenn b gleich 0, dann a ist ggT\n        }\n        while(a != b)\n        {\n            System.out.println(\"a = \" + a + \", b = \" + b);\n            if(a &gt; b)\n            {\n                a = a - b;\n            }\n            else\n            {\n                b = b - a;\n            }\n        }\n        System.out.println(\"ggT von \" + nr1 + \" und \" + nr2 + \" ist \" + a);\n    }\n\n}\n</code></pre> Klasse und Objekte - Adresse Adresse.javaProgrammklasse.java <pre><code>package vorlesungen.vorl1113;\n\npublic class Adresse\n{\n    // Objektvariablen\n    private String strasse;\n    private int nummer;\n    private int plz;\n    private String wohnort;\n\n\n    // Konstruktor\n    public Adresse(String str, int nr, int postleitzahl, String ort)\n    {\n        strasse = str;\n        nummer = nr;\n        plz = postleitzahl;\n        wohnort = ort;\n    }\n\n\n    // Objektmethode\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + plz + \" \" + wohnort;\n    }\n\n    public void strasseUmbenennen(String neuerStrassenname)\n    {\n        strasse = neuerStrassenname;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl1113;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse(\"Wilhelminenhofstrasse\", 75, 12459, \"Berlin\");   // ein Objekt erzeugt\n        Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10435, \"Berlin\"); // noch ein Objekt erzeugt\n\n        /*\n        adresse1.strasse = \"Wilhelminenhofstrasse\"; // geht nicht wegen private\n        adresse1.nummer = 75;\n        adresse1.plz = 12459;\n        adresse1.wohnort = \"Berlin\";\n        */\n        System.out.println(adresse1.getAdresse());\n        adresse1.strasseUmbenennen(\"Neue Strasse\");\n        System.out.println(adresse1.getAdresse());\n\n        /*\n        adresse2.strasse = \"Treskowallee\";\n        adresse2.nummer = 8;\n        adresse2.plz = 10435;\n        adresse2.wohnort = \"Berlin\";\n        */\n        System.out.println(adresse2.getAdresse());\n\n\n    }\n\n}\n</code></pre> Klasse und Objekte - Point Point.javaProgrammklasse.java <pre><code>package vorlesungen.vorl1118;\n\npublic class Point\n{\n    // Objektvariablen\n    private int x;\n    private int y;\n\n    // Konstruktor\n    public Point(int px, int py)\n    {\n        x = px;\n        y = py;\n    }\n\n    // Objektmethoden\n    // Getter\n    public int getX()\n    {\n        return x;\n    }\n\n    public int getY()\n    {\n        return y;\n    }\n\n    public void print()\n    {\n        System.out.println(\"[ x=\" + x + \", y=\" + y + \" ]\");\n    }\n\n    public void translate(int deltaX, int deltaY)\n    {\n        x = x + deltaX;\n        y = y + deltaY;\n    }\n\n    public boolean isLeft(Point otherPoint)\n    {\n        return x &lt; otherPoint.x;\n    }\n\n\n}\n</code></pre> <pre><code>package vorlesungen.vorl1118;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        Point p1 = new Point(-1, 3);\n        Point p2 = new Point(2, 2);\n\n        // p1.x = 5;    // Fehler wegen private\n        System.out.println(\"p1.x = \" + p1.getX());\n        System.out.println(\"p1.y = \" + p1.getY());\n\n        System.out.println(\"p2.x = \" + p2.getX());\n        System.out.println(\"p2.y = \" + p2.getY());\n\n        p1.print();\n        p2.print();\n\n        System.out.println(\"----------- p3 ---------------\");\n        Point p3 = new Point(1, 5);\n        p3.print();\n        p3.translate(-1, -3);\n        p3.print();\n\n        System.out.println(\"----------- p1 ---------------\");\n        p1.print();\n        p2.print();\n        System.out.println(\"p1 links von p2 ? \" + p1.isLeft(p2));\n        p2.print();\n\n\n        Point p4 = p3;\n        p4.print();\n        p3.print();\n        p3.translate(1, -1);\n        p4.print();\n\n\n    }\n\n}\n</code></pre> Klasse und Objekte - Circle Circle.javaProgrammklasse.java <pre><code>package vorlesungen.vorl1120;\n\npublic class Circle\n{\n    // Obejektvariable\n    private double radius;\n\n    // Konstruktor (parametrisiert)\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    // Konstruktor (parameterlos)\n    public Circle()\n    {\n        this.radius = 1.0;\n    }\n\n    public double getDiameter()\n    {\n        return 2.0 * this.radius;\n    }\n\n    public double getRadius()\n    {\n        return this.radius;\n    }\n\n    public double getPerimeter()\n    {\n        return Math.PI * this.getDiameter();\n    }\n\n    public double getArea()\n    {\n        return Math.PI * Math.pow(this.radius, 2);\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius         \" + this.radius);\n        System.out.println(\"Durchmesser    \" + this.getDiameter());\n        System.out.println(\"Umfang         \" + this.getPerimeter());\n        System.out.println(\"Flaecheninhalt \" + this.getArea());\n        System.out.println();\n    }\n\n    public boolean isBigger(Circle c)\n    {\n        return this.radius &gt; c.radius;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl1120;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        Circle c1 = new Circle(3.0);\n        Circle c2 = new Circle(4.0);\n        Circle c3 = new Circle();\n\n        System.out.println(\"c1 Radius : \" + c1.getRadius() + \" Durchmesser : \" + c1.getDiameter());\n        System.out.println(\"c2 Radius : \" + c2.getRadius() + \" Durchmesser : \" + c2.getDiameter());\n\n        c1.print();\n        c2.print();\n        c3.print();\n\n        System.out.println(\"c3 groesser als c1 ? \" + c3.isBigger(c1));\n\n        Circle c4 = c3; // 2 Referenzen auf dasselbe Objekte\n        Circle c5 = new Circle();\n        c5.print();\n\n        Circle c6;      // Referenz ist null                \n    }\n\n}\n</code></pre> Klasse und Objekte - Person Adresse.java (anderes Package)Person.java (anderes Package)Programmklasse.java <pre><code>package vorlesungen.vorl1113;\n\npublic class Adresse\n{\n    // Objektvariablen\n    private String strasse;\n    private int nummer;\n    private int plz;\n    private String wohnort;\n\n\n    // Konstruktor\n    public Adresse(String strasse, int nummer, int plz, String wohnort)\n    {\n        this.strasse = strasse;\n        this.nummer = nummer;\n        this.plz = plz;\n        this.wohnort = wohnort;\n    }\n\n\n    // Objektmethode\n    public String adresseToString()\n    {\n        return this.strasse + \" \" + this.nummer + \" in \" + this.plz + \" \" + this.wohnort;\n    }\n\n    public void strasseUmbenennen(String neuerStrassenname)\n    {\n        this.strasse = neuerStrassenname;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl1125;\n\nimport vorlesungen.vorl1113.Adresse;\n\npublic class Person\n{\n    private String vorname;\n    private String nachname;\n    private Adresse adresse;\n\n    public Person(String vorname, String nachname, Adresse adresse)\n    {\n        this.vorname = vorname;\n        this.nachname = nachname;\n        this.adresse = adresse;\n    }\n\n    public void print()\n    {\n        System.out.printf(\"%s %s %n%s %n\", this.vorname, this.nachname, \"wohnt in\");\n        System.out.println(this.adresse.adresseToString());\n        System.out.println();\n    }\n\n    public Adresse getAdresse()\n    {\n        return this.adresse;\n    }\n}\n</code></pre> <pre><code>package vorlesungen.vorl1125;\n\nimport vorlesungen.vorl1113.Adresse;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse wh = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");\n        Adresse ta = new Adresse(\"Treskowallee\", 8, 10435, \"Berlin\");\n\n        Person max = new Person(\"Max\", \"Muster\", new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\"));\n        Person maria = new Person(\"Maria\", \"Schmidt\", ta);\n        Person mo = new Person(\"Mo\", \"Mueller\", wh);\n        Person bo = new Person(\"Bo\", \"Mueller\", wh);\n\n        max.print();\n        maria.print();      // Treskowallee\n        mo.print();\n        bo.print();\n\n        ta.strasseUmbenennen(\"Neue Strasse\");\n\n        maria.print();\n\n        System.out.println();\n\n        System.out.println(max.getAdresse().adresseToString());\n\n    }\n\n}\n</code></pre>"},{"location":"algorithmen/","title":"Was ist Programmieren?","text":"<p>Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus. Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. </p> <p>Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algorithmus zu sein:</p> <ol> <li>Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein.</li> <li>Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein.</li> <li>Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen.</li> <li>Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen.</li> <li>Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern.</li> <li>Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.</li> </ol>"},{"location":"algorithmen/#beispiel-euklidischer-algorithmus","title":"Beispiel: Euklidischer Algorithmus","text":"<p>Mit dem euklidischen Algorithmus<sup>1</sup> kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat Euklid diesen Algorithmus ungef\u00e4hr so formuliert:</p> <p>Euklidischer Algorithmus</p> <p>Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst.</p> <p>Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken (<code>AB</code> und <code>CD</code>). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind (... CD aber AB nicht misst...).</p> <p>Beispiel: ggT von 24 und 40</p> <ol> <li>AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 </li> <li>AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 =  8</li> <li>AB: 16, CD: 8,  AB gr\u00f6\u00dfer als CD \u2192 16 -  8 =  8  </li> <li>AB:  8, CD: 8,  AB gleich CD \u2192 Ende \u2192 ggT ist 8</li> </ol> <p>Wir versuchen, den Algorithmus in eine verst\u00e4ndlichere und genauere Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode:</p> <p>Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind <code>a</code> und <code>b</code>:</p> <pre><code>solange a ungleich b ist, wiederhole\n    wenn a gr\u00f6\u00dfer ist als b, dann:\n        ziehe b von a ab und weise das Ergebnis a zu\n    andernfalls:\n        ziehe a von b ab und weise das Ergebnis b zu\nwenn a gleich b ist, dann:\n    a (oder auch b) ist der gesuchte ggT\n</code></pre> <p>Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik). In Zeile <code>1</code> formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen <code>2</code> bis <code>5</code> formuliert. Zeile <code>1</code> formuliert eine Schleife und in den Zeilen <code>2</code>-<code>5</code> befindet sich der Schleifeninhalt. Die Zeilen <code>2</code>-<code>5</code> formulieren ein eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob <code>a</code> gr\u00f6\u00dfer ist als <code>b</code>. Wenn das der Fall ist, dann wird die Alternative <code>ziehe b von a ab und weise das Ergebnis a zu</code> ausgef\u00fchrt (In der Programmierung werden das sp\u00e4ter als <code>a = a - b</code> schreiben - das sieht f\u00fcr uns jetzt noch sehr \"falsch\" aus). Ist jedoch <code>a</code> nicht gr\u00f6\u00dfer als <code>b</code>, dann wird die Alternative <code>ziehe a von b ab und weise das Ergebnis b zu</code> (<code>b = b - a</code>) ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative) genannt. Nachdem entweder Zeile <code>3</code> oder Zeile <code>5</code> ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile <code>1</code> gepr\u00fcft, ob <code>a ungleich b</code> ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile <code>6</code> wird ausgef\u00fchrt. Die in Zeile <code>6</code> formulierte Bedingung <code>wenn a gleich b ist</code>, ist eigentlich unn\u00f6tig. </p> <p>Frage</p> <p>Warum ist die Bedingung <code>wenn a gleich b ist</code> in Zeile <code>6</code> unn\u00f6tig?</p> <p>Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen): </p> <ol> <li>Iteration: die Schleife, die in Zeile <code>1</code> formuliert wird und die als Schleifeninhalt die Zeilen <code>2</code>-<code>5</code> hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss.</li> <li>Selektion: die bedingte Alternative, die eine Bedingung pr\u00fcft (Zeile <code>2</code>) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile <code>3</code> oder Zeile <code>4</code>), wird Selektion genannt (siehe Zeilen <code>2</code>-<code>5</code>).</li> <li>Sequenz: die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile <code>1</code>, dann Zeile <code>2</code>, dann entweder Zeile <code>3</code>oder Zeile <code>4</code> usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. </li> </ol> <p>Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: </p> <ol> <li>Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben).</li> <li>Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden.</li> <li>Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen.</li> <li>Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt?</li> <li>Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen <code>a</code>und <code>b</code>) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. </li> <li>Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen, um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. </li> </ol>"},{"location":"algorithmen/#beispielzahlen-fur-den-euklidischen-algorithmus","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus","text":"<p>Wir nehmen die Zahlen <code>a=40</code> und <code>b=24</code> und spielen damit unseren Algorithmus durch:</p> \u00a0Schritt \u00a0Programmzeile \u00a0Begr\u00fcndung 1 Zeile <code>1</code> <code>a (40) ist ungleich b (24)</code>, also wird der Schleifeninhalt ausgef\u00fchrt 2 Zeile <code>2</code> <code>a ist gr\u00f6\u00dfer als b</code>, also wird Zeile <code>3</code> ausgef\u00fchrt (und genau nicht Zeilen <code>4</code> und <code>5</code>) 3 Zeile <code>3</code> \u00a0das Ergebnis von <code>a-b</code> ist 16. Der neue Wert von <code>a</code> ist 16. 4 Zeile <code>1</code> \u00a0wegen wiederhole (Iteration): <code>a (16) ist ungleich b (24)</code>, also wird der Schleifeninhalt ausgef\u00fchrt 5 Zeile <code>2</code> <code>a ist nicht gr\u00f6\u00dfer als b</code>, also wird Zeile <code>5</code> ausgef\u00fchrt (und genau nicht Zeile <code>3</code>) 6 Zeile <code>5</code> \u00a0das Ergebnis von <code>b-a</code> ist 8. Der neue Wert von <code>b</code> ist 8. 7 Zeile <code>1</code> \u00a0wegen wiederhole (Iteration): <code>a (16) ist ungleich b (8)</code>, also wird der Schleifeninhalt ausgef\u00fchrt 8 Zeile <code>2</code> <code>a ist gr\u00f6\u00dfer als b</code>, also wird Zeile <code>3</code> ausgef\u00fchrt (und genau nicht Zeile <code>5</code>) 9 Zeile <code>3</code> \u00a0das Ergebnis von <code>a-b</code> ist 8. Der neue Wert von <code>a</code> ist 8. 10 Zeile <code>1</code> \u00a0wegen wiederhole (Iteration): <code>a (8) ist nicht ungleich b (8)</code>, also wird der Schleifeninhalt nicht ausgef\u00fchrt 11 Zeile <code>6</code> <code>a (8) ist gleich b (8)</code> 12 Zeile <code>7</code> \u00a0der gesuchte <code>ggT</code> ist <code>8</code> 13 Ende <p>F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe <code>a=40</code> und <code>b=24</code> stets <code>8</code> ist. </p> <p>Fragen</p> <ul> <li>Was \u00e4ndert sich, wenn am Anfang <code>a=24</code> und <code>b=40</code> sind?</li> <li>Was \u00e4ndert sich, wenn am Anfang <code>a=-40</code> und <code>b=24</code> sind?</li> <li>Was \u00e4ndert sich, wenn am Anfang <code>a=0</code> und <code>b=24</code> sind?</li> <li>Was \u00e4ndert sich, wenn am Anfang <code>a=24</code> und <code>b=24</code> sind?</li> </ul>"},{"location":"algorithmen/#beispiel-3n1-vermutung-collatz-problem","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)","text":"<p>Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. <code>5</code>. Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger <code>1</code> ist. </p> <p>Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist <code>n</code>:</p> <pre><code>solange n ungleich 1 ist, wiederhole\n    wenn n ungerade, dann:\n        berechne 3*n +1 und weise das Ergebnis n zu\n    andernfalls:\n        berechne n/2 und weise das Ergebnis n zu\n</code></pre> <p>Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der Nachfolger <code>1</code>ist. Betrachten wir den Algorithmus f\u00fcr die Eingabe von <code>n=5</code>:</p> \u00a0Schritt \u00a0Programmzeile \u00a0Begr\u00fcndung 1 Zeile <code>1</code> <code>n (5) ist ungleich 1</code>, also wird der Schleifeninhalt ausgef\u00fchrt 2 Zeile <code>2</code> <code>n ist ungerade</code>, also wird Zeile <code>3</code> ausgef\u00fchrt (und genau nicht Zeilen <code>4</code> und <code>5</code>) 3 Zeile <code>3</code> \u00a0 das Ergebnis von <code>3*5+1</code> ist <code>16</code>. Der neue Wert von <code>n</code> ist 16. 4 Zeile <code>1</code> \u00a0 wegen wiederhole (Iteration): <code>n (16) ist ungleich 1</code>, also wird der Schleifeninhalt ausgef\u00fchrt 5 Zeile <code>2</code> <code>n ist nicht ungerade</code>, also wird Zeile <code>5</code> ausgef\u00fchrt (und genau nicht Zeile <code>3</code>) 6 Zeile <code>5</code> \u00a0 das Ergebnis von <code>16/2</code> ist <code>8</code>. Der neue Wert von <code>n</code> ist 8. 7 Zeile <code>1</code> \u00a0 wegen wiederhole (Iteration): <code>n (8) ist ungleich 1</code>, also wird der Schleifeninhalt ausgef\u00fchrt 8 Zeile <code>2</code> <code>n ist nicht ungerade</code>, also wird Zeile <code>5</code> ausgef\u00fchrt (und genau nicht Zeile <code>3</code>) 9 Zeile <code>5</code> \u00a0 das Ergebnis von <code>8/2</code> ist <code>4</code>. Der neue Wert von <code>n</code> ist 4. 10 Zeile <code>1</code> \u00a0 wegen wiederhole (Iteration): <code>n (4) ist ungleich 1</code>, also wird der Schleifeninhalt ausgef\u00fchrt 11 Zeile <code>2</code> <code>n ist nicht ungerade</code>, also wird Zeile <code>5</code> ausgef\u00fchrt (und genau nicht Zeile <code>3</code>) 12 Zeile <code>5</code> \u00a0 das Ergebnis von <code>4/2</code> ist <code>2</code>. Der neue Wert von <code>n</code> ist 2. 13 Zeile <code>1</code> \u00a0 wegen wiederhole (Iteration): <code>n (2) ist ungleich 1</code>, also wird der Schleifeninhalt ausgef\u00fchrt 14 Zeile <code>2</code> <code>n ist nicht ungerade</code>, also wird Zeile <code>5</code> ausgef\u00fchrt (und genau nicht Zeile <code>3</code>) 15 Zeile <code>5</code> \u00a0 das Ergebnis von <code>2/2</code> ist <code>1</code>. Der neue Wert von <code>n</code> ist 1. 16 Zeile <code>1</code> \u00a0 wegen wiederhole (Iteration): <code>n (1) ist nicht ungleich 1</code>, also wird der Schleifeninhalt nicht ausgef\u00fchrt 17 Ende <p>Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die Eingabe <code>n=5</code> stets <code>1</code> ist. </p> <p>Fragen</p> <ul> <li>Spielen Sie den Algorithmus ruhig einmal f\u00fcr <code>n=7</code> durch oder auch f\u00fcr andere <code>n</code></li> <li>Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl <code>n</code> terminiert?</li> <li>Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche) liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden?</li> </ul> <p>Success</p> <p>Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus-Begriff erlangt und wissen, was Finitheit, Determiniertheit, Determinismus und Terminierung bedeuten. </p>"},{"location":"algorithmen/#programmablaufstrukturen","title":"Programmablaufstrukturen","text":"<p>Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind:</p> <ul> <li>die Sequenz: die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt</li> <li>die Iteration: die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife</li> <li>die Selektion: die Abl\u00e4ufe werden selektiv, d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung  oder bedingte Alternative</li> </ul> <p>Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.</p>"},{"location":"algorithmen/#die-sequenz","title":"Die Sequenz","text":"<p>Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird.</p> Sequenz von 3 Anweisungen <pre><code>Anweisung1\nAnweisung2\nAnweisung3\n</code></pre> <p>Ein Beispiel (mit 2 Anweisungen) w\u00e4re:</p> <pre><code>berechne 3*n und weise das Ergebnis n zu\nberechne n+1 und weise das Ergebnis n zu \n</code></pre> <p>Zur Visualisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufdiagramm so aus:</p> <p></p> <p>So ein Diagramm wird von oben nach unten gelesen. Es wird also erst <code>Anweisung1</code> ausgef\u00fchrt, dann <code>Anweisung2</code> und zuletzt <code>Anweisung3</code>. Innerhalb einer Sequenz gilt immer single entry/single exit, d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrere Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-deterministisch  und somit ein Versto\u00df gegen unseren Algorithmusbegriff.</p> <p></p>"},{"location":"algorithmen/#die-iteration","title":"Die Iteration","text":"<p>Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife. </p> <p>Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt:</p> <pre><code>solange a ungleich b ist, wiederhole\n    hier die Anweisung \n    oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt\n</code></pre> <p>bzw.</p> <pre><code>solange n ungleich 1 ist, wiederhole\n    hier die Anweisung \n    oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt\n</code></pre> <p>Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt:</p> <ul> <li>es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. <code>a ungleich b ist</code> oder ob <code>n ungleich 1</code>. Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. <code>a gleich b ist</code> oder <code>n gleich 1 ist</code>, dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. </li> </ul> <p>Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus:</p> <p></p> <p>Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird <code>Anweisung1</code> ausgef\u00fchrt.</p> <p>Beachte</p> <p><code>Anweisung1</code> muss nicht zwingend nur genau eine Anweisung sein. Bei <code>Anweisung1</code> kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln!</p> <p>Nach jeder Ausf\u00fchrung von <code>Anweisung1</code> wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird <code>Anweisung1</code> erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird <code>Anweisung1</code> nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt (<code>Anweisung2</code>) oder das Programm ist dann zu Ende.</p> <p>Beachte</p> <p>Es kann sein, dass <code>Anweisung1</code> gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt. Es kann sein, dass <code>Anweisung1</code> gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem!  Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). </p> <p>Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. </p>"},{"location":"algorithmen/#die-selektion","title":"Die Selektion","text":"<p>Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus:</p> <pre><code>wenn a gr\u00f6\u00dfer ist als b, dann:\n    ziehe b von a ab und weise das Ergebnis a zu\nandernfalls:\n    ziehe a von b ab und weise das Ergebnis b zu\n</code></pre> <p>Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem):</p> <pre><code>wenn n ungerade, dann:\n    berechne 3*n +1 und weise das Ergebnis n zu\nandernfalls:\n    berechne n/2 und weise das Ergebnis n zu\n</code></pre> <p>Es gibt also immer eine Bedingung (z.B. <code>wenn a gr\u00f6\u00dfer ist als b</code>) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. <code>ziehe b von a ab und weise das Ergebnis a zu</code>)  oder die andere (z.B. <code>ziehe a von b ab und weise das Ergebnis b zu</code>) ausgef\u00fchrt. </p> <p>Das Ablaufdiagramm einer Selektion sieht so aus:</p> <p></p> <p>Beachte</p> <p><code>Anweisung1</code> und auch <code>Anweisung2</code> m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!</p>"},{"location":"algorithmen/#verschachteln-von-kontrollstrukturen","title":"Verschachteln von Kontrollstrukturen","text":"<p>Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. <code>Anweisung1</code>) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anweisungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. </p> <p>Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur:</p> <p></p> \u00dcbung Programmablaufpl\u00e4ne <p>Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan!</p> \u00dcbung Algorithmus und Programmablaufplan <p>Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. </p> <p>Success</p> <p>Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. </p> <ol> <li> <p>Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit.\u00a0\u21a9</p> </li> </ol>"},{"location":"arrays/","title":"Arrays","text":"<p>In einer Variable k\u00f6nnen wir genau einen Wert speichern. Wenn wir 5 Werte speichern wollen, ben\u00f6tigen wir 5 Variablen und wenn wir 1000 Werte speichern wollen, ben\u00f6tigen wir 1000 Variablen. Das ist nat\u00fcrlich unzweckm\u00e4\u00dfig. Wenn Sie mehrere Werte gleichen Typs speichern wollen, dann verwenden Sie dazu besser Arrays (Felder). Arrays sind Objekte.</p> <p>Wir schauen uns mal ein einf\u00fchrendes Beispiel an. Angenommen, wir wollen 5 <code>int</code>-Werte <code>0</code>, <code>1</code>, <code>4</code>, <code>9</code> und <code>16</code> speichern. Bis jetzt ben\u00f6tigten wir dazu 5 Variablen:</p> <pre><code>int number1 = 0;\nint number2 = 1;\nint number3 = 4;\nint number4 = 9;\nint number5 = 16;\n</code></pre> <p>Jetzt wollen wir dazu ein Array verwenden. Die Erzeugung und Initialisierung sieht so aus:</p> <pre><code>int[] numbers = new int[5];     // Array der Laenge 5\nnumbers[0] = 0;                 // erstes Element Wert 0\nnumbers[1] = 1;                 // zweites Element Wert 1\nnumbers[2] = 4;                 // drittes Element Wert 4\nnumbers[3] = 9;                 // viertes Element Wert 9\nnumbers[4] = 16;                // fuenftes Element Wert 16\n</code></pre> <ol> <li>Ein Array erkennen wir an den eckigen Klammern <code>[]</code>. </li> <li>Unser Array im Beispiel ist vom Typ <code>int</code>, d.h. jedes Element in diesem Array ist vom Typ <code>int</code>. Arrays k\u00f6nnen von einem beliebigen Typ sein, sowohl Wertetypen als auch Referenztypen. Ein Array wird immer f\u00fcr genau einen Typ deklariert, bei uns <code>int</code> \u2192 deshalb <code>int[]</code>. Best\u00fcnde das Array aus lauter Strings, dann w\u00e4re der Typ <code>String[]</code>.</li> <li>In unserem Beispiel ist <code>numbers</code> die Referenzvariable, die auf unser Array-Objekt zeigt. </li> <li>Mithilfe des Schl\u00fcsselwortes <code>new</code> wird unser Array erzeugt. Nach <code>new</code> kommt nochmal das Array (<code>Typ[]</code>), aber in den eckigen Klammern steht die L\u00e4nge des Arrays. In unserem Beispiel <code>5</code>. Bei der Erzeugung des Arrays muss immer die L\u00e4nge angegeben werden. Die L\u00e4nge eines Arrays kann sich nicht \u00e4ndern.</li> <li>Der Zugriff auf die einzelnen Elemente erfolgt \u00fcber den Index. Jedes Array ist automatisch \"nummeriert\". Die \"Nummerierung\" (der Index) beginnt immer mit <code>0</code> und erh\u00f6ht sich f\u00fcr jedes Element um <code>1</code>. Der Index eines Arrays ist immer vom Typ <code>int</code>.</li> </ol> <p>Wir k\u00f6nnen uns unser Array <code>numbers</code> so vorstellen:</p> <p></p> <p>Wir haben 5 Elemente (L\u00e4nge <code>5</code>), die jeweils durch den Index nummeriert sind. Diese Elemente k\u00f6nnen nun Werte enthalten:</p> <p></p> <p>Der Zugriff auf die Werte eines Arrays erfolgt dann immer unter Verwendung der Referenzvariable, dahinter eckige Klammern und in den Klammern der entsprechende Index:</p> <p><code>Referenzvariable[Index]=Wert;</code></p> <p>Also in unserem Beispiel <code>numbers[0]</code>.</p>"},{"location":"arrays/#erzeugung-und-initialisierung-eines-arrays","title":"Erzeugung und Initialisierung eines Arrays","text":"<p>Die Erzeugung und Initialisierung eines Arrays erfolgt in drei Schritten:</p> <ol> <li>Schritt: Definition einer Referenzvariablen, die auf das Array-Objekt zeigt  (siehe oben in Zeile <code>1</code>: <code>int[] numbers</code>t)</li> <li>Schritt: Erzeugen des Arrays, d. h. eines Array-Objektes, das aus Elementen eines bestimmten Datentyps besteht (und Zuweisung an die zuvor definiere Referenzvariable - siehe oben Zeile <code>1</code>: <code>new int[5]</code>)</li> <li>Schritt: Belegen der Array-Elemente mit Werten, d. h. Initialisierung des Arrays (siehe oben Zeilen <code>2-6</code>). </li> </ol> <p>Beispiele verschiedene Arrays erzeugen:</p> <pre><code>double[] noten = new double[10];        // Array aus double-Elemente Laenge 10\nString[] satz = new String[30];         // Array aus Zeichenketten Laenge 30\nboolean[] filled = new boolean[100];    // Array aus boolean-Elementen Laenge 100\nint[] statistics = new int[10000];      // Array aus int-Elementen Laenge 10000\n</code></pre> <p>Die Initialisierung erfolgt elementweise \u00fcber den Zugriff auf den Index, z.B. (siehe oben):</p> <pre><code>numbers[0] = 0;                 // erstes Element Wert 0\nnumbers[1] = 1;                 // zweites Element Wert 1\nnumbers[2] = 4;                 // drittes Element Wert 4\nnumbers[3] = 9;                 // viertes Element Wert 9\nnumbers[4] = 16;                // fuenftes Element Wert 16\n</code></pre> <p>Da der Index stets vom Typ <code>int</code> ist, h\u00e4tten wir unser Array auch wie folgt initialisieren k\u00f6nnen:</p> <pre><code>for(int index=0; index&lt;5; index++)\n{\n    numbers[index] = (index*index);\n}\n</code></pre> <p>Beachten Sie:</p> <ol> <li>Der gr\u00f6\u00dfte Index ist immer um eins kleiner als die L\u00e4nge des Arrays (L\u00e4nge ist <code>5</code>, gr\u00f6\u00dfter Index ist <code>4</code> \u2192 deshalb <code>index &lt; 5</code>)</li> <li>Der Index ist immer <code>int</code>, egal von welchem Typ das Array ist</li> <li>In unserem Beispiel entsprechen die Werte der einzelnen Elementen Quadratzahlen. Deshalb konnten wir als Wert <code>(index * index)</code> verwenden.</li> </ol>"},{"location":"arrays/#die-eigenschaft-length","title":"Die Eigenschaft <code>length</code>","text":"<p>Jedes Array besitzt die Eigenschaft <code>length</code>. Dar\u00fcber k\u00f6nnen wir die L\u00e4nge des Arrays auslesen. Der Wert von <code>length</code> kann nicht neu gesetzt werden (ist konstant). Wir benutzen die Eigenschaft <code>length</code> insbesondere in den Schleifen, mit denen wir auf den Index zugreifen.</p> <p><code>Referenzvariable.length</code></p> <p>Unser obiges Initialisierungsbeispiel h\u00e4tte also besser so ausgesehen:</p> <pre><code>for(int index=0; index&lt;numbers.length; index++)\n{\n    numbers[index] = (index*index);\n}\n</code></pre>"},{"location":"arrays/#ausgabe-der-werte","title":"Ausgabe der Werte","text":"<p>Den jetzt bereits bekannten Zugriff auf die einzelnen Elemente k\u00f6nnen wir auch f\u00fcr das Auslesen der Werte eines Arrays verwenden:</p> <pre><code>for(int index=0; index&lt;numbers.length; index++)\n{\n    System.out.println(numbers[index]);\n}\n</code></pre>"},{"location":"arrays/#verwenden-der-werte","title":"Verwenden der Werte","text":"<p>Wir erl\u00e4utern ein einfaches Beispiel zur Verwendung der Werte, wir bilden die Summe aller Werte \u00fcber das Array (wir gehen davon aus, dass das <code>numbers</code>-Array so wie oben erzeugt un initialisiert wurde):</p> <pre><code>int sum = 0;\nfor(int index=0; index&lt;numbers.length; index++)\n{\n    sum = sum + numbers[index];\n}\nSystem.out.println(\"Summe aller Elemente : \" + sum);\n</code></pre>"},{"location":"arrays/#mogliche-andere-form-der-erzeugung-und-initialisierung","title":"M\u00f6gliche andere Form der Erzeugung und Initialisierung","text":"<p>Das Array kann auch in einer anderen Form erzeugt und initilisiert werden:</p> <pre><code>int[] numbers = {0, 1, 4, 9, 16};\n</code></pre> <p>Diese Form erzeugt ein <code>int[]</code>-Array der L\u00e4nge <code>5</code> mit den Werten </p> <pre><code>numbers[0] = 0;                 // erstes Element Wert 0\nnumbers[1] = 1;                 // zweites Element Wert 1\nnumbers[2] = 4;                 // drittes Element Wert 4\nnumbers[3] = 9;                 // viertes Element Wert 9\nnumbers[4] = 16;                // fuenftes Element Wert 16\n</code></pre> <p>Es handelt sich um eine einfache Form der Erzeugung und Initialisierung in einem Schritt. </p>"},{"location":"arrays/#weitere-beispiele-von-arrays","title":"Weitere Beispiele von Arrays","text":"<p>Wir zeigen einige Beispiele anderer Arrays:</p> <pre><code>String[] satz = new String[4];\nsatz[0] = \"Das\";\nsatz[1] = \"ist\";\nsatz[2] = \"ein\";\nsatz[3] = \"Satz\";\nfor(int index=0; index&lt;satz.length-1; index++)\n{\n    System.out.print(satz[index] + \" \");\n}\nSystem.out.println(satz[satz.length-1] + \".\");\n</code></pre> <p>Das Beispiel zeigt die Erzeugung und Initialisierung eines Arrays, in dem alle Elemente vom Typ <code>String</code> sind. Nach der Erzeugung und Initialisierung in den Zeilen <code>1</code> bis <code>5</code> folgt die Ausgabe der Werte des Arrays. Es werden alle Werte ausgegeben und ein Leerzeichen angeh\u00e4ngt. Das gilt aber nur f\u00fcr alle Elemente einschlie\u00dflich des vorletzten (<code>index&lt;satz.length-1</code>). Hinter das letzte Element (<code>satz[satz.length-1]</code>) folgt kein Leerzeichen, sondern ein Punkt.</p> <p>Wir h\u00e4tten das Array auch so erzeugen und initialisieren k\u00f6nnen: <code>String[] satz = {\"Das\", \"ist\", \"ein\", \"Satz\"};</code></p> <p>Ein weiteres Beispiel mit einem <code>char</code>-Array:</p> <pre><code>char[] alphabet = new char[26];\nfor(int index=0; index&lt;26; index++)\n{\n    alphabet[index] = (char) (index+65);\n}\nfor(int index=0; index&lt;26; index++)\n{\n    System.out.print(alphabet[index]+\" \");\n}\n</code></pre> <p>Es wird zun\u00e4chst ein <code>char</code>-Array erzeugt (Zeile <code>1</code>) und initialisiert (Zeilen <code>2</code> bis <code>5</code>). Anschlie\u00dfend wird es ausgelesen Zeilen <code>6</code> bis <code>9</code>). Es entsteht folgende Ausgabe:</p> <pre><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n</code></pre> <p>Success</p> <p>Wir k\u00f6nnen uns Arrays erzeugen und initialisieren. Wir k\u00f6nnen Werte in diesen Arrays \u00e4ndern und aus den Arrays auslesen. Wir kennen die <code>length</code>-Variable von Arrays und k\u00f6nnen den Index verwenden, um auf die einzelnen Elemente zuzugreifen.  N\u00e4chste Woche geht es mit Arrays weiter!</p>"},{"location":"arrays/#algorithmen-uber-arrays","title":"Algorithmen \u00fcber Arrays","text":"<p>Wir werden uns mit verschiedenen Algorithmen besch\u00e4ftigen, die alle Arrays zur Grundlage haben. Wir beginnen zur Auffrischung mal mit einer kleinen \u00dcbung. Wir wollen ein Array erstellen, in dem die Fibonacci-Folge enthalten ist. Diese geht so, dass das erste Element den Wert <code>0</code> hat und das zweite Element den Wert <code>1</code> und alle nachfolgenden Elemente als Wert die Summe der Werte ihrer beiden Vorg\u00e4nger hat, also <code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</code>. </p> <p>Ausgangspunkt ist also etwas in der folgenden Art:</p> <pre><code>public static void main(String[] args)\n{\n    int length = 20;\n    int[] fibonacci = new int[length];\n    fibonacci[0] = 0;\n    fibonacci[1] = 1;\n}\n</code></pre> Bef\u00fcllen Sie den Rest des <code>fibonacci</code>-Arrays! <pre><code>public static void main(String[] args)\n{\n    int length = 20;\n    int[] fibonacci = new int[length];\n    fibonacci[0] = 0;\n    fibonacci[1] = 1;\n    for(int index=2; index&lt;fibonacci.length; index++)\n    {\n        fibonacci[index] = fibonacci[index-1] + fibonacci[index-2];\n    }\n}\n</code></pre> <p>Wir wollen dieses Array nun mehrfach verwenden, um anhand von Beispielen einige Algorithmen \u00fcber Arrays kennenzulernen. Beachten Sie, dass wir f\u00fcr das <code>fibonacci</code>-Array die L\u00e4nge auf <code>20</code> festgesetzt hatten. Dies k\u00f6nnen wir aber problemlos \u00e4ndern und deutlich l\u00e4ngere <code>fibonacci</code>-Arrays erstellen. Alles, was wir dazu tun m\u00fcssen, ist den Wert von <code>length</code> zu \u00e4ndern. Beachten Sie au\u00dferdem, dass <code>length</code> eine von uns erzeugte Variable ist, aber <code>fibonacci.length</code> eine Variable des Arrays (deren Wert wir nicht \u00e4ndern, sondern nur auslesen k\u00f6nnnen). </p>"},{"location":"arrays/#methoden-mit-arrays-als-parameter","title":"Methoden mit Arrays als Parameter","text":"<p>Wir werden uns einige Methoden erstellen, um z.B. ein als Parameter \u00fcbergebenes Array auszugeben oder einige Berechnungen \u00fcber die Werte des Arrays durchzuf\u00fchren. Wir beginnen damit, uns eine Methode zu schreiben, die ein als Parameter \u00fcbergebenes Array auf die Konsole ausgibt.</p>"},{"location":"arrays/#ausgabe-der-werte-auf-die-konsole","title":"Ausgabe der Werte auf die Konsole","text":"<p>Zun\u00e4chst wollen wir alle Werte nur durch Leerzeichen getrennt auf die Konsole ausgeben. Die dazugeh\u00f6rige Methode sieht so aus:</p> <pre><code>    public static void printArray(int[] a)\n    {\n        for(int index=0; index&lt;a.length; index++)\n        {\n            System.out.print(a[index] + \" \");\n        }\n        System.out.println();\n    }\n</code></pre> <p>Wir \u00fcbergeben also ein <code>int[]</code>-Array als Parameter und durchlaufen es in einer Schleife vollst\u00e4ndig von <code>index=0</code> bis <code>index=a.length-1</code> und geben alle Werte von <code>a[index]</code> auf die Konsole durch Leerzeichen getrennt aus. </p> <p>Wenn wir nun in <code>main()</code> <code>printArray(fibonacci);</code> aufrufen, bekommen wir folgende Ausgabe:</p> <pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 \n</code></pre> <p>Jetzt wollen wir die Ausgabe \u00e4ndern. Das Array soll in folgender Form ausgegeben werden:</p> <pre><code>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181 ]\n</code></pre> <p>Das hei\u00dft, die Werte sollen alle innerhalb von eckigen Klammern erscheinen und die Werte sind durch Komma getrennt. Das Hauptproblem dabei ist, dass nach dem letzten Wert kein Komma ausgegeben werden soll. Angenommen, wir \u00e4ndern obigen Code nur geringf\u00fcgig:</p> <pre><code>    public static void printArray(int[] a)\n    {\n        System.out.print(\"[ \");\n        for(int index=0; index&lt;a.length; index++)\n        {\n            System.out.print(a[index] + \", \");\n        }\n        System.out.println(\" ]\");\n    }\n</code></pre> <p>dann h\u00e4tten wir eine Ausgabe in der Form:</p> <pre><code>[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181,  ]\n</code></pre> <p>Wir h\u00e4tten also schonmal die eckigen Klammern, aber nach dem letzten Wert k\u00e4me noch ein Komma. Deshalb lassen wir nun die Schleife nur noch bis <code>index&lt;a.length-1</code> laufen und behandeln das letzte Element extra. Welchen Index hat das letzte Element von <code>a</code>? Wir kennen die L\u00e4nge nicht, wir kennen aber <code>a.length</code>. Das letzte Element hat den Index <code>a.length-1</code>, d.h. der gr\u00f6\u00dfte Index ist stets die L\u00e4nge des Arrays minus 1. Wir k\u00f6nnten die Methode also so schreiben:</p> <pre><code>    public static void printArray(int[] a)\n    {\n        System.out.print(\"[ \");\n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            System.out.print(a[index] + \", \");\n        }\n        System.out.print(a[a.length-1]);\n        System.out.println(\" ]\");\n    }\n</code></pre> <p>Jetzt gibt es nur noch ein kleines Problem: Was passiert, wenn die L\u00e4nge des Arrays <code>0</code> ist, das als Parameter \u00fcbergebene Array also gar keine Elemente besitzt? Ein solches Array lie\u00dfe sich z.B. durch </p> <pre><code>int[] arr1 = new int[0];\nint[] arr2 = {};\n</code></pre> <p>erzeugen. Wenn <code>a</code> die L\u00e4nge <code>0</code> h\u00e4tte, dann w\u00fcrden wir mit <code>a[a.length-1]</code> auf das Element von <code>a</code> mit dem Index <code>-1</code> zugreifen wollen und ein solches Element/ein solcher Index existiert nicht. Es w\u00fcrde eine <code>ArrayIndexOutOfBounds</code>-Exception geworfen werden. Um sich dagegen zu sch\u00fctzen, pr\u00fcfen wir vor diesem Zugriff noch, ob die L\u00e4nge gr\u00dfer als <code>0</code> ist:</p> <pre><code>    public static void printArray(int[] a)\n    {\n        System.out.print(\"[ \");\n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            System.out.print(a[index] + \", \");\n        }\n        if(a.length&gt;0)\n        {\n            System.out.print(a[a.length-1]);\n        }\n        System.out.println(\" ]\");\n    }\n</code></pre> Was wird ausgegeben, wenn <code>a</code> die L\u00e4nge <code>0</code> hat? <pre><code>[  ]\n</code></pre> Schreiben Sie die obige Methode so, dass die Ausgabe nicht auf der Konsole erfolgt, sondern der Ausgabe-String zur\u00fcckgegeben wird! <pre><code>    public static String getOutputStringOfArray(int[] a)\n    {\n        String s = \"[ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + a[index] + \", \";\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + a[a.length-1] + \" ]\";\n        }\n        return s;\n    }\n</code></pre>"},{"location":"arrays/#maximumwert-ermitteln","title":"Maximumwert ermitteln","text":"<p>Angenommen, wir bekommen ein <code>int[]</code>-Array als Parameter \u00fcbergeben und sollen den gr\u00f6\u00dften Wert innerhalb dieses Arrays ermitteln (und zur\u00fcckgeben). Eine Idee f\u00fcr einen solchen Algorithmus w\u00e4re:</p> <ul> <li>wir merken uns das aktuelle Maximum in einer Variablen</li> <li>wir laufen durch das Array durch und immer wenn der aktuelle Wert im Array gr\u00f6\u00dfer ist, als unser aktuelles Maximum, speichern wir den Wert als (neues) aktuelles Maximum</li> <li>wenn wir vollst\u00e4ndig durch das Array durchgelaufen sind, haben wir den gr\u00f6\u00dften Wert als aktuelles Maximum gespeichert und k\u00f6nnen ihn zur\u00fcckgeben</li> </ul> <p>Eine solche Implementierung k\u00f6nnte so aussehen:</p> <pre><code>    public static int getMaximum(int[] a)\n    {\n        int currentMaximum = 0; \n        for (int index = 0; index &lt; a.length; index++)\n        {\n            if(a[index]&gt;currentMaximum)\n            {\n                currentMaximum = a[index];\n            }\n        }       \n        return currentMaximum;\n    }\n</code></pre> <p>Das sieht zun\u00e4chst exakt wie die Implementierung des oben beschriebenen Algorithmus' aus. In Zeile <code>3</code> erstellen wir unsere Variable <code>currentMaximum</code>, mit der wir uns das aktuelle Maximum speichern wollen. Mit der <code>for</code>-Schleife laufen wir durch alle Elemente unseres Arrays (Zeile <code>4</code>) und wenn ein Wert aus dem Array gr\u00f6\u00dfer ist als das bis dahin gespeicherte Maximum (Zeile <code>6</code>), speichern wir den Wert des Elements als neues Maximum (Zeile <code>8</code>). Nach dem Verlassen der <code>for</code>-Schleife ist der gr\u00f6\u00dfte Wert in <code>currentMaximum</code> gespeichert und kann zur\u00fcckgegeben werden. </p> <p>Wir testen das mal in <code>main()</code> mit unserer Fibonacci-Folge und rufen <code>System.out.println(getMaximum(fibonacci));</code> auf. Wir erhalten:</p> <pre><code>4181\n</code></pre> <p>Es scheint also zu funktionieren. Wir haben jedoch ein Problem: Was passiert, wenn die Werte in <code>a</code> alle negativ sind? Dann w\u00fcrde der Vergleich in Zeile <code>6</code> nie <code>true</code> sein und <code>currentMaximum</code> nie den Wert \u00e4ndern, da der initiale Wert von <code>currentMaximum</code> gr\u00f6\u00dfer als alle Werte aus dem Array ist. Wir m\u00fcssen also etwas am initialen Wert von <code>currentMaximum</code> \u00e4ndern. Eine Idee ist, dass wir <code>currentMaximum</code> mit dem ersten Wert aus dem <code>a</code>-Array initialisieren:</p> <pre><code>    public static int getMaximum(int[] a)\n    {\n        int currentMaximum = a[0];  \n        for (int index = 1; index &lt; a.length; index++)\n        {\n            if(a[index]&gt;currentMaximum)\n            {\n                currentMaximum = a[index];\n            }\n        }       \n        return currentMaximum;\n    }\n</code></pre> <p>Dann m\u00fcssen wir beim Schleifendurchlauf nur noch alle Elemente betrachten, deren Index <code>&gt;=1</code> ist, da wir das Element mit dem Index <code>0</code> (das erste Element aus <code>a</code>) bereits bei der Initialisierung von <code>currentMaximum</code> betrachtet haben. Nun funktioniert unsere Methode auch f\u00fcr Arrays, die nur negative Werte enthalten. </p> <p>Ein Problem bleibt noch: Was passiert, wenn das Array <code>a</code> leer ist, also eine L\u00e4nge von <code>0</code> hat? Dann k\u00f6nnen wir n\u00e4mlich auch nicht <code>a[0]</code> aufrufen, da dieses Element (der Index <code>0</code>) nicht existiert. Wir bek\u00e4men eine <code>ArrayIndexOutOfBounds</code>-Exception. Hierbei stellt sich die grunds\u00e4tzliche Frage, was durch unsere Methode zur\u00fcckgegeben werden soll, wenn das \u00fcbergebene Array gar kein Maximum hat, n\u00e4mlich dann, wenn es leer ist? Darauf gibt es keine befriedigende Antwort. W\u00fcr m\u00fcssen ein <code>int</code> zur\u00fcckgeben, aber kein <code>int</code> aus dem Wertebereich w\u00e4re korrekt. Grunds\u00e4tzlich sollte so etwas vor Aufruf der Methode gepr\u00fcft werden. Wir k\u00f6nnten uns z.B. eine Methode <code>isEmpty()</code> schreiben:</p> <pre><code>    public static boolean isEmpty(int[] a)\n    {\n        return (a.length==0);\n    }\n</code></pre> <p>Diese Methode gibt <code>true</code> zur\u00fcck, wenn das Array <code>a</code> leer ist (also die L\u00e4nge <code>0</code>) hat und <code>false</code> sonst. Diese Methode kann man f\u00fcr den Aufruf von <code>getMaximum()</code> verwenden:</p> <pre><code>if(!isEmpty(arr1))\n{\n    int maximum = getMaximum(arr1);\n}\n</code></pre> <p>Das hei\u00dft, wir rufen die Methode <code>getMaximum()</code> f\u00fcr ein Array nur dann auf, wenn wir wissen, dass dieses Array nicht leer ist. Dann arbeitet unsere Methode n\u00e4mlich korrekt - und nur dann.</p>"},{"location":"arrays/#zwei-arrays-auf-gleichheit-prufen","title":"Zwei Arrays auf Gleichheit pr\u00fcfen","text":"<p>Wir wollen eine Methode schreiben, die \u00fcberpr\u00fcft, ob 2 Arrays gleich sind - also vollst\u00e4ndig gleiche Werte enthalten. Z.B. sollen diese Arrays gleich sein:</p> <p><pre><code>int[] arr1 = {8, 9, 2, 3, 7, 4, 1, 0, 9, 6 };\nint[] arr2 = {8, 9, 2, 3, 7, 4, 1, 0, 9, 6 };\n</code></pre> aber  <pre><code>int[] arr3 = {8, 9, 2, 3, 7, 5, 1, 0, 9, 6 };\n</code></pre></p> <p>ist ungleich zu <code>arr1</code> und <code>arr2</code>, da <code>arr3</code> an 6. Stelle den Wert <code>5</code> statt <code>4</code> hat.</p> <p>Die algorithmische Idee ist:</p> <ul> <li>wir laufen gleichzeitig durch beide Arrays durch</li> <li>solange die Werte bei gleichem Index gleich sind, machen wir weiter</li> <li>sobald zwei Werte bei gleichem Index ungleich sind, wissen wir, dass die Arrays ungleich sind</li> <li>wenn wir alle Elemente betrachtet haben und alle waren gleich, dann sind auch unsere Arrays gleich</li> </ul> <pre><code>public static boolean areEqual(int[] a, int[] b)\n{   \n    boolean areEqual = true;\n    for(int index=0; index &lt; a.length; index++)\n    {\n        if(a[index]!=b[index])\n        {\n            areEqual = false;\n        }\n    }\n    return areEqual;\n}\n</code></pre> <p>Diese Methode setzt unseren Algorithmus um und wenn wir die Methode mit den obigen Arrays testen</p> <pre><code>System.out.println(areEqual(arr1, arr2));\nSystem.out.println(areEqual(arr1, arr3));\n</code></pre> <p>, dann wird auch korrekt </p> <pre><code>true\nfalse\n</code></pre> <p>ausgegeben. Doch was passiert, wenn wir die Methode f\u00fcr diese beiden Arrays aufrufen:</p> <pre><code>int[] arr4 = {8, 9, 2 };\nint[] arr5 = {8, 9, 2, 3 };\n</code></pre> Welcher Wert wird bei Aufruf <code>System.out.println(areEqual(arr4, arr5));</code> ausgegeben? <pre><code>true\n</code></pre> <p>Wollen wir das?</p> Welcher Wert wird bei Aufruf <code>System.out.println(areEqual(arr5, arr4));</code> ausgegeben? <ul> <li>keiner, sondern  <pre><code>Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n</code></pre></li> </ul> <p>Warum?</p> <p>Grunds\u00e4tzlich sollte es bei einer solchen Methode egal sein, welche Reihenfolge die \u00fcbergebenen Arrays in der Parameterliste haben, d.h. <code>areEqual(arr4, arr5)</code> und <code>areEqual(arr5, arr4)</code> sollten den gleichen Wert zur\u00fcckliefern, denn entweder sind sie gleich <code>true</code> oder sie sind es nicht <code>false</code>. Die Gleichheit ist eine symmetrische Relation. </p> <p>Was ist das Problem unserer bisherigen L\u00f6sung? Wir durchlaufen die Schleife auch dann, wenn die Arrays unterschiedliche L\u00e4nge haben. In dem Aufruf <code>areEqual(arr4, arr5)</code> wird das letzte Element von <code>arr5</code> gar nicht mehr gepr\u00fcft, da der <code>index</code> in der Schleife nur bis <code>arr4.length-1</code> l\u00e4uft. In dem Aufruf <code>areEqual(arr5, arr4)</code> wird versucht, das letzte Element von <code>arr5</code> mit einem Element von <code>arr4</code> zu vergleichen, das gar nicht existiert. Der Zugriff auf <code>arr4[3]</code> f\u00fchrt zu einer <code>ArrayIndexOutOfBoundsException</code>. Wir werden deshalb zun\u00e4chst pr\u00fcfen, ob die beiden Arrays \u00fcberhaupt gleich lang sind und nur dann durchlaufen wir die beiden Arrays:</p> <pre><code>public static boolean areEqual(int[] a, int[] b)\n{   \n    boolean areEqual = true;\n    if(a.length != b.length)\n    {\n        areEqual = false;\n    }\n    for(int index=0; index &lt; a.length &amp;&amp; areEqual; index++)\n    {\n        if(a[index]!=b[index])\n        {\n            areEqual = false;\n        }\n    }\n    return areEqual;\n}\n</code></pre> <p>Au\u00dferdem haben wir in die <code>for</code>-Schleife die Bedingung um <code>&amp;&amp; areEqual</code> erweitert. Das hat zwei Gr\u00fcnde:</p> <ul> <li>erstens betreten wir die <code>for</code>-Schleife dann gar nicht, wenn die beiden Arrays unterschiedliche L\u00e4ngen haben, denn dann ist <code>areEqual==fasle</code> und somit ist die gesamte Bedingung <code>index &lt; a.length &amp;&amp; areEqual</code> <code>false</code>. \u2192 das ist also notwendig, um korrekt zu sein (wir k\u00f6nnten auch die <code>for</code>-Schleife in den <code>else</code>-Block der Selektion packen)</li> <li>zweitens beenden wir das Durchlaufen der <code>for</code>-Schleife sofort, wenn wir ungleiche Elemente gefunden haben, denn dann setzen wir ja auch <code>areEqual</code> auf <code>false</code>. Es gen\u00fcgt ja, zwei ungleiche Elemente zu finden, dann sind die Arrays ungleich und wir m\u00fcssen gar nicht weiter suchen. \u2192 das ist also nicht notwendig, aber performanter</li> </ul> <p>Zur \u00dcbung mit einem Array als Parameter k\u00f6nnen Sie:</p> Bestimmen Sie die Summe aller Werte eines <code>int</code>-Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie die Summe zur\u00fcck. <pre><code>public static int getSumme(int[] a)\n{\n    int sum = 0;\n    for (int i = 0; i &lt; a.length; i++)\n    {\n        sum += a[i];\n    }\n    return sum;\n}\n</code></pre> Bestimmen Sie den Durchschnitt/Mittelwert aller Werte eines <code>int</code>-Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie den Durchschnitt zur\u00fcck zur\u00fcck. <pre><code>public static double getAverage(int[] a)\n{\n    /*\n     * diese Aufgabe ist leider komplizierter, da wir \n     * das Problem haben, dass getSumme(a) ein int\n     * zurueckliefert und a.length ebenfalls ein int ist\n     * und wir somit int / int rechnen, also eine\n     * ganzzahlige Division durchf\u00fchren\n     * Mithilfe des Typkonvertierungsoperators (double) \n     * k\u00f6nnen wir aber aus einem int ein double machen,\n     * z.B. wird mit (double)a.length aus der Laenge ein \n     * double\n     * int / double ist eine Gleitkommadivision\n     * Probieren Sie es einmal ohne (double) und\n     * einmal mit (double) aus\n     */\n    double average = getSumme(a)/ (double)a.length;\n    return average;\n}\n</code></pre>"},{"location":"arrays/#methoden-mit-array-als-ruckgabe","title":"Methoden mit Array als R\u00fcckgabe","text":"<p>Wir betrachten nun Methoden, die ein Array zur\u00fcckgeben. Wir fangen an mit einer Methode, der eine <code>int length</code> \u00fcbergeben wird und die damit ein <code>int[]</code> der L\u00e4nge <code>length</code> erzeugt und dieses Array mit Zufallszahlen bef\u00fcllt:</p> <pre><code>public static int[] createAndFillArray(int length)\n{\n    int[] a = new int[length];\n    Random r = new Random();                    \n    for(int i=0; i&lt;a.length; i++)\n    {\n        a[i]=r.nextInt();\n    }\n    return a;\n}\n</code></pre> <p>Betrachten wir die Methode genauer:</p> <ul> <li>in Zeile <code>3</code> wird eine Variable <code>a</code> vom Typ <code>int[]</code> deklariert und ein <code>int[]</code>-Array der L\u00e4nge <code>length</code> erzeugt. Die Variable <code>a</code> zeigt auf dieses neu erzeugte Array. </li> <li>in Zeile <code>4</code> erzeugen wir ein <code>Random</code>-Objekt und die Referenzvariable <code>r</code> vom Typ <code>Random</code> zeigt auf dieses Objekt. Beachten Sie, dass Sie die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket importieren m\u00fcssen!</li> <li>in den Zeilen <code>5-8</code> laufen wir durch das Array durch und belegen jedes Element mit einer Zufallszahl indem wir <code>r.nextInt()</code> aufrufen. </li> <li>in Zeile <code>9</code> wird das Array zur\u00fcckgegeben. </li> </ul> <p>Aufruf der Methode in <code>main()</code> (oder einer anderen Methode):</p> <pre><code>int[] arr6 = createAndFillArray(5);\nprintArray(arr6);\n</code></pre> <p>Wir rufen die Methode mit einem Wert <code>5</code> f\u00fcr <code>length</code> auf. Das bedeutet, dass die Methode ein Array der L\u00e4nge <code>5</code> erzeugt und mit Zufallszahlen bef\u00fcllt. Das zur\u00fcckgegebene Arry speichern wir in der Variablen <code>arr6</code>, die ebenfalls vom Typ <code>int[]</code> ist. Wir geben das Array mithilfe der von uns erzeugten Methode <code>printArray(arr6);</code> aus (wir h\u00e4tten auch direkt <code>printArray(createAndFillArray(5));</code> aufrufen k\u00f6nnen, dann h\u00e4tten wir das erzeugte Array aber nirgendwo gespeichert). Es erscheint z.B. eine Ausgabe wie:</p> <pre><code>[ 1463666318, -2121738539, -1174806146, 337579240, -108604609 ]\n</code></pre> <p>Wenn wir den Wertebereich der zuf\u00e4llig erzeugten Zahlen eingrenzen m\u00f6chten, z.B. nur Werte aus dem Bereich <code>[0, 1, ..., 19]</code>, k\u00f6nnen wir die <code>nextInt(int bound)</code>-Methode von <code>Random</code> verwenden (siehe). Wir erweitern die Methode <code>createAndFillArray()</code> um einen solchen <code>bound</code>-Parameter:</p> <pre><code>public static int[] createAndFillArray(int length, int bound)\n{\n    int[] a = new int[length];\n    Random r = new Random();                    \n    for(int i=0; i&lt;a.length; i++)\n    {\n        a[i]=r.nextInt(bound);\n    }\n    return a;\n}\n</code></pre> <p>Beachten Sie, dass bei <code>nextInt(int bound)</code> der Wert von <code>bound</code> exklusiv ist, d.h. dieser Wert gibt die erste Zahl an, die nicht mehr zuf\u00e4llig erzeugt wird. Wenn wir also zuf\u00e4llig Zahlen aus dem Bereich <code>[0, 1, ..., 19]</code> erzeugen wollen, dann muss <code>bound=20</code> sein. </p> <p>Der Aufruf von </p> <pre><code>int[] arr7 = createAndFillArray(10, 20);\nprintArray(arr7);\n</code></pre> <p>erzeugt dann z.B. eine solche Ausgabe (bei Ihnen nat\u00fcrlich anders - sind ja Zufallszahlen):</p> <pre><code>[ 2, 17, 7, 5, 17, 3, 19, 8, 6, 18 ]\n</code></pre>"},{"location":"arrays/#array-kopieren","title":"Array kopieren","text":"<p>Wir erstellen eine Methode, der ein Array als Parameter \u00fcbergeben wird und die davon eine Kopie erstellt und diese Kopie zur\u00fcckgibt. </p> <pre><code>public static int[] copyArray(int[] original)\n{\n    int length = original.length;\n    int[] copy = new int[length];\n    for(int index=0; index&lt;length; index++)\n    {\n        copy[index] = original[index];\n    }\n    return copy;\n}\n</code></pre> <ul> <li>in Zeile <code>1</code> wird das Original-Array \u00fcbergeben und in der Referenzvariablen <code>original</code> gespeichert,</li> <li>in Zeile <code>3</code> erstellen wir uns eine Variable <code>length</code> vom Typ <code>int</code>, in der die L\u00e4nge des Original-Arrays gespeichert wird,</li> <li>in Zeile <code>4</code> wird das <code>copy</code>-Array erstellt, das genau so lang ist, wie das Original,</li> <li>In den Zeilen <code>5-8</code> kopieren wir jeden einzelnen Wert aus dem Original-Array in das <code>copy</code>-Array (elementweise),</li> <li>in Zeile <code>9</code> geben wir das <code>copy</code>-Array zur\u00fcck<sup>1</sup> </li> </ul> <p>Der Aufruf der Methode, z.B. </p> <pre><code>int[] original = createAndFillArray(10, 20);\nSystem.out.print(\"original : \");\nprintArray(original);\nint[] copy = copyArray(original);\nSystem.out.print(\"copy     : \");\nprintArray(copy);\n</code></pre> <p>erzeugt folgende Ausgabe (Zufallszahlen):</p> <pre><code>original : [ 2, 2, 5, 19, 19, 6, 1, 1, 4, 8 ]\ncopy     : [ 2, 2, 5, 19, 19, 6, 1, 1, 4, 8 ]\n</code></pre> <p>Angenommen, wir \u00fcbergeben unserer Methode nicht nur das Original-Array, sondern auch eine L\u00e4nge, bis zu der das Original-Array kopiert werden soll. Der Methodenkopf w\u00fcrde dann also so aussehen:</p> <pre><code>public static int[] copyArray(int[] original, int newLength)\n</code></pre> <p>Dann gibt es 3 verschiedene Varianten:</p> <ul> <li>Original-Array und Kopie des Arrays gleich lang (wenn <code>newLength == original.length</code>)</li> <li>Original-Array k\u00fcrzer als Kopie (z.B. falls Original-Array zu klein geworden ist, um weitere Elemente einzuf\u00fcgen; wenn <code>newLength &gt; original.length</code>) Original-Array l\u00e4nger als Kopie (falls nur ein Teil kopiert werden soll; wenn <code>newLength &lt; original.length</code>)</li> </ul> <p>Wir f\u00fcgen in unsere Methode eine entsprechende Fallunterscheidung ein:</p> <pre><code>public static int[] copyArray(int[] original, int newLength)\n{\n    int[] copy = new int[newLength];\n    if(original.length&lt;=newLength)\n    {\n        for(int index=0; index&lt;original.length; index++)\n        {\n            copy[index]=original[index];\n        }\n    }\n    else\n    {\n        for(int index=0; index&lt;copy.length; index++)\n        {\n            copy[index]=original[index];\n        }\n    }\n    return copy;\n}\n</code></pre> <ul> <li>in Zeile <code>1</code> wurde der neue Parameter <code>newLength</code> hinzugef\u00fcgt, der die L\u00e4nge des <code>copy</code>-Arrays bestimmt,</li> <li>in Zeile <code>3</code> wird das <code>copy</code>-Array mit der L\u00e4nge <code>newLength</code> erzeugt, </li> <li>in Zeile <code>4</code> erfolgt die Fallunterscheidung:<ul> <li>falls die Kopie mindestens so lang ist wie das Original, werden alle Elemente aus dem Original in die Kopie kopiert (Zeilen <code>6-9</code>) \u2192 Beachten Sie Verwendung von original.length in der Bedingung der <code>for</code>-Schleife,</li> <li>falls die Kopie k\u00fcrzer ist als das Original, werden nur die ersten <code>newLength</code> Elemente aus dem Original-Array kopiert (Zeilen <code>13-16</code>) \u2192 Beachten Sie Verwendung von copy.length in der Bedingung der <code>for</code>-Schleife,</li> </ul> </li> </ul> <p>Bei dem Aufruf von </p> <pre><code>int[] original = createAndFillArray(10, 20);    // Original Laenge 10\nSystem.out.print(\"original : \");\nprintArray(original);\nint[] copy = copyArray(original, 8);            // Kopie Laenge 8\nSystem.out.print(\"copy     : \");\nprintArray(copy);\n</code></pre> <p>erfolgt folgende Ausgabe (Zufallszahlen):</p> <pre><code>original : [ 8, 13, 11, 4, 7, 2, 5, 1, 15, 5 ]\ncopy     : [ 8, 13, 11, 4, 7, 2, 5, 1 ]\n</code></pre> <p>Bei dem Aufruf von </p> <pre><code>int[] original = createAndFillArray(10, 20);    // Original Laenge 10\nSystem.out.print(\"original : \");\nprintArray(original);\nint[] copy = copyArray(original, 18);           // Kopie Laenge 18\nSystem.out.print(\"copy     : \");\nprintArray(copy);\n</code></pre> <p>erfolgt folgende Ausgabe (Zufallszahlen):</p> <pre><code>original : [ 1, 18, 0, 9, 12, 18, 2, 8, 17, 12 ]\ncopy     : [ 1, 18, 0, 9, 12, 18, 2, 8, 17, 12, 0, 0, 0, 0, 0, 0, 0, 0 ]    \n</code></pre> <p>Beachten Sie, dass Elementen, denen kein Wert zugewiesen wurde, den Wert <code>0</code> haben (Standardwert von <code>int</code>). </p>"},{"location":"arrays/#array-verketten","title":"Array verketten","text":"<p>Wir erstellen eine Methode, der zwei Arrays als Parameter \u00fcbergeben werden und die daraus ein neues Array erstellt, welche alle Elemente des einen und alle Elemente des anderen Arrays enth\u00e4lt. Die algorithmische Idee dabei ist wie folgt:</p> <p>Array <code>a</code> und Array <code>b</code> aneinanderh\u00e4ngen:</p> <ul> <li>neues Array <code>c</code> erzeugen (die L\u00e4nge von <code>c</code> ergibt sich aus <code>a.length + b.length</code>),</li> <li>Elemente von <code>a</code> nach <code>c</code> kopieren (bis Index <code>a.length-1</code>),</li> <li>Elemente von <code>b</code> nach <code>c</code> kopieren (ab Index <code>a.length</code>),  </li> <li><code>c</code> zur\u00fcckgeben</li> </ul> <p>Die folgende Abbildung verdeutlicht ein Beispiel mit <code>a.length==6</code> und <code>b.length==4</code>. Es wird ein Array <code>c</code> mit L\u00e4nge <code>10</code> erzeugt. In die ersten 6 Elemente von <code>c</code>werden die Werte von <code>a</code> kopiert und in die folgenden 4 Elemente die Werte von <code>b</code>. Beachten Sie, dass in dem Beispiel z.B. <code>c[6]=b[0]</code>kopiert wird. </p> <p></p> <p>Eine m\u00f6gliche Methode k\u00f6nnte so aussehen:</p> <pre><code>public static int[] concatArrays(int[] a, int[] b)\n{\n    int[] c = new int[a.length+b.length];\n\n    for(int index=0; index&lt;a.length; index++)\n    {\n        c[index] = a[index];\n    }\n    for(int index=0; index&lt;b.length; index++)\n    {\n        c[index+a.length] = b[index];\n    }\n    return c;\n}\n</code></pre> <p>Wichtig ist hier, unbedingt zu verstehen, warum wir innerhalb der zweiten <code>for</code>-Schleife <code>c[index+a.length] = b[index];</code> verwenden! </p>"},{"location":"arrays/#suchen-in-arrays","title":"Suchen in Arrays","text":"<p>Bei der Suche in Arrays geht es darum, einen bestimmten Wert zu finden, der im Array enthalten ist (oder er wird nicht gefunden, falls er nicht im Array existiert.) Grunds\u00e4tzlich m\u00fcssen wir zwischen der Suche in </p> <ul> <li>unsortierten und</li> <li>sortierten </li> </ul> <p>Arrays unterscheiden. In sortierten Arrays sind die Elemente alle hinsichtlich ihrer Werte geordnet, also z.B. numerisch bei Zahlen oder alphanumerisch bei Zeichen und Zeichenketten. Wir beginnen mit der Suche in unsortierten Arrays.</p>"},{"location":"arrays/#suche-in-unsortierten-arrays","title":"Suche in unsortierten Arrays","text":"<p>Wir wollen eine Methode erstellen, der ein Array \u00fcbergeben wird und ein Element gleichen Typs. Die Methode soll ein <code>true</code> zur\u00fcckgeben, wenn das Element in dem Array enthalten ist und ein <code>false</code>, wenn nicht. Die Idee dabei ist</p> <ul> <li>wir durchlaufen das Array solange, bis <ul> <li>wir entweder das Element gefunden haben \u2192 dann k\u00f6nnen wir die Suche beenden und ein <code>true</code> zur\u00fcckgeben</li> <li>oder wir am Ende des Arrays angekommen sind und das Element nicht gefunden haben \u2192 dann geben wir ein <code>false</code> zur\u00fcck</li> </ul> </li> </ul> <p>Eine solche Methode k\u00f6nnte so aussehen: </p> <pre><code>public static boolean contains(int[] a, int element)\n{\n    boolean found = false;\n    for(int index=0; index&lt;a.length &amp;&amp; !found; index++)\n    {\n        if(a[index]==element)\n        {\n            found = true;\n        }\n    }\n    return found;\n}\n</code></pre> <p>Wir pr\u00fcfen also, ob <code>element</code> als Wert in <code>a</code> enthalten ist. </p> <ul> <li>in Zeile <code>3</code> definieren wir uns eine Variable <code>found</code>, deren Wert initial auf <code>false</code> gesetzt wird (<code>element</code> noch nicht gefunden)</li> <li>in Zeilen <code>4-10</code> durchlaufen wir das Array, entweder so lange <ul> <li>bis wir das <code>element</code> gefunden haben (Zeilen <code>6-9</code>) \u2192 <code>found==true</code> oder</li> <li>bis wir das Ende des Arrays erreicht haben (<code>index==a.length</code>) \u2192 <code>found==false</code></li> </ul> </li> <li>in Zeile <code>11</code> geben wir den Wert von <code>found</code> zur\u00fcck</li> </ul> <p>Beachten Sie, dass es wichtig ist, dass <code>found</code> initial den Wert <code>false</code> bekommt und dass die Schleife sofort verlassen wird, sobald wir das Element gefunden haben (Schleifen bedingung <code>&amp;&amp; !found</code>). </p> <p>Wir bleiben bei der Suche in unsortierten Arrays. Jetzt soll unsere Methode aber den Index zur\u00fcckgeben, an dem das Element im Array enthalten ist. Wir wissen, dass der Index nur Werte zwischen <code>0</code> und <code>array.length-1</code> annehmen kann, also nur positive Werte. Wenn das Element nicht im Array enthalten ist, dann geben wir eine <code>-1</code> zur\u00fcck. Hierbei sind zwei Sachen zu beachten:</p> <ul> <li>Erstens sollten wir solche \"Codierungen\" von R\u00fcckgabewerten vermeiden. Die aufrufende Methode muss ja \"wissen\", dass ein negativer R\u00fcckgabewert bedeutet, dass das Element gar nicht im Array enthalten ist. Auf der anderen Seite m\u00fcssen wir aber ein <code>int</code> zur\u00fcckgeben. Im Gegensatz zur <code>getMaximum()</code>-Methode oben, gibt es hier jedoch zumindest eine \"L\u00f6sung\" f\u00fcr das Problem, dass das Element nicht enthalten ist. Trotzdem sollte man auf jeden Fall zun\u00e4chst <code>contains()</code> aufrufen und nur, wenn <code>contains()</code> ein <code>true</code>zur\u00fcckliefert, dann die <code>getIndex()</code>-Methode.</li> <li>Zweitens ist die <code>-1</code> eine sogenannte magic number. Wir sollten ihr einen Namen geben. Wir betrachten die Methode zun\u00e4chst ohne einen Namen f\u00fcr die <code>-1</code>:</li> </ul> <pre><code>public static int getIndex(int[] a, int element)\n{\n    int indexAtElement = -1;\n    for(int index=0; index&lt;a.length; index++)\n    {\n        if(a[index]==element)\n        {\n            indexAtElement = index; \n        }\n    }\n    return indexAtElement;\n}\n</code></pre> <p>Wir durchlaufen das Array und sobald wir das <code>element</code> \"finden\" (Zeile <code>6</code>), merken wir uns den aktuellen Index (Zeile <code>8</code>). Am Ende wird der gemerkte Index zur\u00fcckgegeben (Zeile <code>11</code>). Wenn Zeile <code>8</code> nie ausgef\u00fchrt wurde, dann wird der initiale Wert von <code>indexAtElement</code> zur\u00fcckgegeben, n\u00e4mlich <code>-1</code>. Diese <code>-1</code> ist eine sogenannte magic number. Man kennt die Bedeutung dieses Wertes nicht. Es ist deshalb besser, daf\u00fcr einen Namen einzuf\u00fchren - als Konstante (zu Konstanten siehe hier). </p> <pre><code>public static int getIndex(int[] a, int element)\n{\n    final int NOT_FOUND = -1;\n    int indexAtElement = NOT_FOUND;\n    for(int index=0; index&lt;a.length; index++)\n    {\n        if(a[index]==element)\n        {\n            indexAtElement = index; \n        }\n    }\n    return indexAtElement;\n}\n</code></pre> <p>Eine Konstante ist eine Variable, die genau einmal einen Wert zugewiesen bekommt (initailisiert wird) und deren Wert nie wieder \u00fcberschrieben werden kann. Die Namen von Konstanten schreiben wir durchgehend GROSS. </p> Angenommen, das <code>element</code> kommt mehrmals im Array <code>a</code> vor. Wird der erste Index des Auftretens von <code>element</code> im Array zur\u00fcckgegeben oder der letzte Index? Wie k\u00f6nnte man das \u00e4ndern? <ul> <li>Der letzte. Man k\u00f6nnte beim ersten Finden des Elementes die Schleife sofort verlassen (aber nicht <code>break;</code> verwenden!)</li> </ul>"},{"location":"arrays/#suche-in-sortierten-arrays","title":"Suche in sortierten Arrays","text":"<p>In sortierten Arrays sucht es sich etwas schneller nach einem <code>element</code>. Daf\u00fcr gibt es zwei Gr\u00fcnde:</p> <ul> <li>einerseits kann eine sequentielle Suche (also das Durchlaufen des Arrays) schneller abgebrochen werden, falls das Element nicht im Array enthalten ist, denn sobald man einen Wert im Array erreicht, der gr\u00f6\u00dfer ist, als der gesuchte Wert, kann das <code>element</code> ja gar nicht mehr vorkommen (falls das Array aufsteigend sortiert ist)</li> <li>andererseits kann man Algorithmen anwenden, die den Suchraum schnell einschr\u00e4nken, eine sogenannte bin\u00e4re Suche.</li> </ul> <p>Wir betrachten zun\u00e4chst die sequentielle Suche. Angenommen, wir haben folgendes aufsteigend sortiertes Array:</p> <pre><code>[ 0, 2, 2, 3, 4, 4, 5, 7, 8, 9, 11, 11, 11, 14, 16, 16, 18, 18, 18, 19 ]\n</code></pre> <p>und angenommen, wir wollen pr\u00fcfen, ob die <code>10</code> im Array enthalten ist. In einem unsortierten Array m\u00fcssten wir das gesamte Array durchlaufen, um zu merken, dass die <code>10</code> nicht enthalten ist. Hier, bei dem sortierten Array, merken wir das schon, wenn wir die erste <code>11</code> gefunden haben, denn danach kann die <code>10</code> nicht mehr kommen. Die <code>contains()</code>-Methode kann also ein weiteres Abbruchkriterium der Suche enthalten:</p> <pre><code>public static boolean containsSorted(int[] aSorted, int element)\n{\n    boolean found = false;\n    boolean greater = false;\n    for(int index=0; index&lt;aSorted.length &amp;&amp; !found &amp;&amp; !greater; index++)\n    {\n        if(aSorted[index]==element)\n        {\n            found = true;\n        }\n        if(aSorted[index]&gt;element)\n        {\n            greater = true;\n        }\n    }\n    return found;\n}\n</code></pre> <p>Im Vergleich zur <code>contains()</code>-Methode f\u00fcr unsortierte Arrays haben wir einen weiteren \"Schalter\" hinzugef\u00fcgt, <code>greater</code>. Damit haben wir auch die Bedingung in der <code>for</code>-Schleife erweitert (<code>&amp;&amp; !greater</code>). Sollten wir das <code>element</code> noch nicht gefunden haben, der Wert <code>aSorted[index]</code> aber gr\u00f6\u00dfer als <code>element</code> sein (Zeile <code>11</code>), setzen wir <code>greater</code> auf <code>true</code> und die Schleife wird verlassen. </p> Funktioniert die <code>contains()</code>-Methode, die wir f\u00fcr unsortierte Arrays implementiert haben, auch f\u00fcr sortierte Arrays? <ul> <li>Ja, wir nutzen nur die M\u00f6glichkeit des fr\u00fcheren Abbruchs der Suche nicht aus. </li> </ul> Schreiben Sie eine Methode <code>getIndexSorted(int[] aSorted, int element)</code>, die den Index von <code>element</code> in <code>a</code> zur\u00fcckgibt (und sonst <code>-1</code>). Genau wie <code>getIndex()</code> f\u00fcr unsortierte Arrays, aber auch hier nutzen Sie die fr\u00fchere Abbruchm\u00f6glichkeit der Suche aus. <pre><code>public static int getIndexSorted(int[] aSorted, int element)\n{\n    final int NOT_FOUND = -1;\n    boolean greater = false;\n    int indexAtElement = NOT_FOUND;\n    for(int index=0; index&lt;aSorted.length &amp;&amp; !greater; index++)\n    {\n        if(aSorted[index]==element)\n        {\n            indexAtElement = index; \n        }\n        if(aSorted[index]&gt;element)\n        {\n            greater = true;\n        }\n    }\n    return indexAtElement;\n}\n</code></pre> <p>Bis jetzt sind wir immer sequenziell durch das Array durchgelaufen, also von vorne nach hinten, beginnend mit dem Index <code>0</code> bis wir bei <code>array.length</code> angekommen waren. In sortierten Arrays k\u00f6nnen wir das Prinzip \u00e4ndern: </p> <ul> <li>Wir fangen einfach in der Mitte des Arrays an und wenn der Wert, den wir suchen, kleiner ist, als der Wert in der Mitte, dann suchen wir links weiter und sonst suchen wir rechts weiter. </li> <li>Dann gehen wir mit der linken bzw. rechten H\u00e4lft egenau so vor usw.</li> </ul> <p>Diese Suche nennt sich bin\u00e4re Suche (binary search), in jedem Schritt wird der (verbliebene) Suchraum halbiert. Angenommen, wir suchen in dem folgenden Array die 25:</p> <p></p> <ol> <li>wir ermitteln zun\u00e4chst den Index, der in der Mitte des Arrays ist (<code>mid</code>). Dieser ergibt sich aus dem Mittelwert von <code>lo</code> (das ist der kleinste Index, der ist am Anfang <code>0</code>) und <code>hi</code> (das ist der gr\u00f6\u00dfte Index, der ist am Anfang <code>14</code>, da unser Beispiel-Array die L\u00e4nge 15 hat). Unserer Index in der Mitte ist also <code>mid=7</code>. </li> <li>Wir greifen \u00fcber diesen Index <code>mid</code> auf den Wert in dem Array zu; der Wert ist <code>34</code>. </li> <li><code>34</code> ist gr\u00f6\u00dfer als die gesuchte <code>25</code> \u2192 wir suchen also in dem linken Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index <code>hi</code> in diesem Teil (der ist um <code>1</code> kleiner als <code>mid</code> davor, also <code>6</code>). Der Wert von <code>lo</code> bleibt <code>0</code>. Der neue Wert von <code>mid</code> ist <code>3</code>.</li> <li>Wir greifen \u00fcber diesen Index <code>mid</code> auf den Wert in dem Array zu; der Wert ist <code>16</code>. </li> <li><code>16</code> ist kleiner als die gesuchte <code>25</code> \u2192 wir suchen also in dem rechten Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index <code>lo</code> in diesem Teil (der ist um <code>1</code> gr\u00f6\u00dfer als <code>mid</code> davor, also <code>4</code>). Der Wert von <code>hi</code> bleibt <code>6</code>. Der neue Wert von <code>mid</code> ist <code>5</code>.</li> <li>Wir greifen \u00fcber diesen Index <code>mid</code> auf den Wert in dem Array zu; der Wert ist <code>25</code>. Wir haben das Element gefunden. </li> </ol> Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die <code>41</code> suchen. Achten Sie insbesondere darauf, wie sich die Werte von <code>lo</code>, <code>mid</code> und <code>high</code> in jedem Suchschritt \u00e4ndern. <ol> <li>wir beginnen mit <code>lo=0</code>, <code>hi=14</code> und also <code>mid=7</code>. Der Wert im Index <code>7</code> ist <code>34</code> und somit kleiner als die gesuchte <code>41</code> \u2192 wir suchen rechts weiter</li> <li><code>lo=8</code>, <code>hi=14</code> und also <code>mid=11</code>. Der Wert im Index <code>11</code> ist <code>46</code> und somit gr\u00f6\u00dfer als die gesuchte <code>41</code> \u2192 wir suchen links weiter</li> <li><code>lo=8</code>, <code>hi=10</code> und also <code>mid=9</code>. Der Wert im Index <code>9</code> ist <code>41</code> \u2192 gefunden</li> </ol> Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die <code>42</code> suchen. Wann stellen Sie fest, dass die <code>42</code> nicht im Array enthalten ist? <ol> <li>wir beginnen mit <code>lo=0</code>, <code>hi=14</code> und also <code>mid=7</code>. Der Wert im Index <code>7</code> ist <code>34</code> und somit kleiner als die gesuchte <code>42</code> \u2192 wir suchen rechts weiter</li> <li><code>lo=8</code>, <code>hi=14</code> und also <code>mid=11</code>. Der Wert im Index <code>11</code> ist <code>46</code> und somit gr\u00f6\u00dfer als die gesuchte <code>42</code> \u2192 wir suchen links weiter</li> <li><code>lo=8</code>, <code>hi=10</code> und also <code>mid=9</code>. Der Wert im Index <code>9</code> ist <code>41</code> und somit kleiner als die gesuchte <code>42</code> \u2192 wir suchen rechts weiter</li> <li><code>lo=10</code>, <code>hi=10</code> und also <code>mid=10</code>. Der Wert im Index <code>10</code> ist <code>46</code> \u2192 nicht gefunden (<code>hi</code> und <code>lo</code> haben den gleichen Wert \u2192 zu Ende)</li> </ol> <pre><code>public static boolean containsBinarySearch(int[] aSorted, int element)\n{\n    boolean found = false;\n    int lo = 0;\n    int hi = aSorted.length-1;\n    while(lo&lt;=hi &amp;&amp; !found)\n    {\n        int mid = (hi+lo)/2;\n        if(element == aSorted[mid])     // gefunden\n        {\n            found = true;\n        }\n        else                            // nicht gefunden\n        {\n            if(element &lt; aSorted[mid])          // links weitersuchen\n            {\n                hi = mid-1;\n            }\n            else    //  element &gt; aSorted[mid]     rechts weitersuchen\n            {\n                lo = mid+1; \n            }\n        }\n    }\n    return found;\n}\n</code></pre> <ul> <li>in Zeile <code>4</code> wir die <code>lo</code>-Variable mit dem Index-Wert <code>0</code> initialisiert (kleinster Index),</li> <li>in Zeile <code>5</code> wir die <code>hi</code>-Variable mit dem Index-Wert <code>aSorted.length-1</code> initialisiert (gr\u00f6\u00dfter Index),</li> <li>in Zeile <code>6</code> steht die Bedingung, wie lange die Suche fortgesetzt werden soll:<ul> <li>solange das Element noch nicht gefunden wurde (<code>!found</code>) oder</li> <li>solange der kleinere Index <code>lo</code> kleiner (gleich) <code>hi</code> ist; falls <code>element</code> nicht gefunden wurde</li> </ul> </li> <li>in Zeile <code>8</code> steht die Berechnung des mittleren Index <code>mid</code>. Beachten Sie, dass es sich um eine Integer-Division handelt. Es k\u00f6nnte also auch sein, dass die Summe von <code>lo</code> und <code>hi</code> ungerade ist, aber selbst dann ist <code>mid</code> eine ganze positive Zahl</li> <li>wenn das <code>element</code> gefunden wird (Bedingung in Zeile <code>9</code> ist <code>true</code>), dann wird <code>found</code> auf <code>true</code> gesetzt und die <code>while</code>-Schleife wird verlassen</li> <li>wenn links weiter gesucht wird (Bedingung in Zeile <code>15</code> ist <code>true</code>), dann  wird <code>hi</code> neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft</li> <li>wenn rechts weiter gesucht wird (Bedingung in Zeile <code>15</code> ist <code>false</code>), dann  wird <code>lo</code> neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft</li> <li>zur\u00fcckgegeben (Zeile <code>25</code>)  wird <code>true</code>, wenn das <code>element</code> gefunden wurde (Zeilen <code>9-12</code>oder <code>false</code>, wenn es nicht gefunden wurde - initialer Wert von <code>found</code>)</li> </ul> Implementieren Sie eine <code>getIndexBinarySearch()</code>-Methode unter Verwendung des Prinzips der bin\u00e4ren Suche! <pre><code>public static int getIndexBinarySearch(int[] aSorted, int element)\n{\n    boolean found = false;\n    final int NOT_FOUND = -1;\n    int indexAtElement = NOT_FOUND; \n    int lo = 0;\n    int hi = aSorted.length-1;\n    while(lo&lt;=hi &amp;&amp; !found)\n    {\n        int mid = (hi+lo)/2;\n        if(element == aSorted[mid])     // gefunden\n        {\n            found = true;\n            indexAtElement = mid;\n        }\n        else                            // nicht gefunden\n        {\n            if(element &lt; aSorted[mid])          // links weitersuchen\n            {\n                hi = mid-1;\n            }\n            else    //  element &gt; aSorted[mid]     rechts weitersuchen\n            {\n                lo = mid+1; \n            }\n        }\n    }\n    return indexAtElement;\n}\n</code></pre> <p>Nur zur Info : </p> <p>Mithilfe der bin\u00e4ren Suche ist die Suche nach einem Element in einem sortierten Array enorm beschleunigt. Unter der Komplexit\u00e4t eines Algorithmus wird der Bedarf des Algorithmus an den zur Verf\u00fcgung stehenden Ressourcen </p> <ul> <li>Laufzeit (wie schnell?) \u2192 sogenannte Zeitkomplexit\u00e4t </li> <li>Speicherplatz (wie viel Speicherplatz n\u00f6tig?)  \u2192 sogenannte Speicherkomplexit\u00e4t</li> </ul> <p>verstanden. Die Komplexit\u00e4t eines Algorithmus in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe <code>n</code> der von ihm bearbeiteten Daten ausgedr\u00fcckt. Daf\u00fcr hat sich die Landau-Notation durchgesetzt. Diese beschreibt mit <code>O(n)</code> sogenannte Komplexit\u00e4tsklassen. Beispielsweise wird die Verkettung von zwei Arrays der L\u00e4nge <code>n</code> und <code>m</code> mit der Komplexit\u00e4tsklasse <code>O(n+m)</code> angegeben (maximale Zeit- und Speicherkomplexit\u00e4t), w\u00e4hrend die Komplexit\u00e4tsklasse der sequentiellen Suche in unsortierten und sortierten Arrays <code>O(n)</code> ist und die bin\u00e4re Suche in sortierten Arrays <code>O(log n)</code>. </p> <p>Wir messen im Folgenden einmal den Zeitverbrauch der Methoden <code>getIndex()</code>, <code>getIndexSorted()</code> und <code>getIndexBinarySearch()</code> unter Verweung der Klassen <code>Instant</code> und <code>Duration</code> aus dem Paket <code>java.time</code>:</p> <pre><code>int[] test = createAndFillArray(100000000, 10000000);\nArrays.sort(test);\nInstant start = Instant.now();\nint index = getIndex(test, 80000000);\nInstant finish = Instant.now();\nlong duration = Duration.between(start, finish).toMillis();\nSystem.out.println(\"index : \" + index + \" duration : \" + duration);\n\nstart = Instant.now();\nindex = getIndexSorted(test, 80000000);\nfinish = Instant.now();\nduration = Duration.between(start, finish).toMillis();\nSystem.out.println(\"index : \" + index + \" duration : \" + duration);\n\nstart = Instant.now();\nindex = getIndexBinarySearch(test, 80000000);\nfinish = Instant.now();\nduration = Duration.between(start, finish).toMillis();\nSystem.out.println(\"index : \" + index + \" duration : \" + duration);\n</code></pre> <ul> <li>Zeile <code>1</code>: Wir erstellen uns mithilfe der Methode <code>createAndFillArray()</code> ein Array mit 100 Millionen Eintr\u00e4gen. </li> <li>Zeile <code>2</code>: Unter Verwendung der Klasse <code>Arrays</code> (aus dem <code>java.util</code>-Paket) wird dieses Array sortiert (die Klasse kennen wir noch nicht). </li> <li>Zeile <code>3</code>: Mithilfe der <code>Instant</code>-Klasse (aus <code>java.time</code>) und deren Methode <code>now()</code> ermitteln wir die aktuelle Zeit und speichern sie in der Variablen <code>start</code> (vom Typ <code>Instant</code>); die Klasse kennen wir noch nicht</li> <li>Zeile <code>4</code>: Wir verwenden die Methode <code>getIndex()</code>, um das Element mit dem Wert <code>8.000.000</code> im Array <code>test</code> zu suchen</li> <li>Zeile <code>5</code>: Mithilfe <code>Instant.now()</code> ermitteln wir erneut die aktuelle Zeit und speichern sie in der Variablen <code>finish</code></li> <li>Zeile <code>6</code>: wir berechnen die Differenz zwischen <code>finish</code> und <code>start</code> in Millisekunden und speichern sie in der Variablen <code>duration</code> vom Typ <code>long</code> (zur Differenzberechnung verwenden wir die Klassae <code>Duration</code> aus dem <code>java.time</code>-Paket; die Klasse kennen wir noch nicht)</li> <li>Zeile <code>7</code>: wir geben die Index und die Dauer der Ausf\u00fchrung aus</li> <li>Zeile <code>10</code>: wir wiederholen alles mit der <code>getIndexSorted()</code>-Methode</li> <li>Zeile <code>16</code>: wir wiederholen alles mit der <code>getIndexBinarySearch()</code>-Methode</li> </ul> <p>Es erfolgt folgende Ausgabe (Element wurde in diesem Fall nicht gefunden):</p> <pre><code>index : -1 duration : 47\nindex : -1 duration : 94\nindex : -1 duration : 0\n</code></pre> <p><code>getIndexBinarySearch()</code> verbraucht also (fast) keine Zeit. Es \u00fcberrrascht vielleicht, dass <code>getIndexSorted()</code> doppelt so viel Zeit verbraucht, wie <code>getIndex()</code>. Das liegt aber daran, dass in <code>getIndex()</code> einerseits die Bedingung der <code>for</code>-Schleife nur eine Pr\u00fcfung enth\u00e4lt, w\u00e4hrend es in <code>getIndexSorted()</code> drei Teilbedingungen sind, die verkn\u00fcpft werden m\u00fcssen und es au\u00dferdem in <code>getIndex()</code> innerhalb der <code>for</code>-Schleife nur eine Bedingung zur Pr\u00fcfung gibt, w\u00e4hrend es in <code>getIndexSorted()</code> zwei sind. Da das gesuchte Element mit dem Wert <code>8 Mio</code> relativ weit hinten im Array liegen w\u00fcrde (der Bereich der Zufallszahlen ist <code>[0 ... 9999999]</code> Zufallszahlen in den <code>100 Mio</code>Eintr\u00e4gen des Arrays), ist der Vorteil der Suche im sortierten Array hier zu gering. </p> <p>W\u00fcrden wir z.B. stattdessen nach der Zahl <code>100000</code> suchen, w\u00e4re das Ergebnis so:</p> <pre><code>index : 1000579 duration : 53\nindex : 1000579 duration : 4\nindex : 1000575 duration : 0\n</code></pre>"},{"location":"arrays/#einfugen-in-arrays","title":"Einf\u00fcgen in Arrays","text":"<p>Hier geht es darum, dass wir ein Element in ein Array einf\u00fcgen wollen. Wir unterscheiden wieder zwischen dem Einf\u00fcgen in ein unsortiertes und dem Einf\u00fcgen in ein sortiertes Array. Wir betrachten zun\u00e4chst das EInf\u00fcgen in ein unsortiertes Array. </p>"},{"location":"arrays/#einfugen-in-ein-unsortiertes-array","title":"Einf\u00fcgen in ein unsortiertes Array","text":"<p>Angenommen, wir haben folgendes <code>int</code>-Array <code>a</code>:</p> <p></p> <p>und wir wollen ein weiteres Element mit dem Wert <code>13</code> einf\u00fcgen. Man k\u00f6nnte auf die Idee kommen, dass die Elemente mit dem Index <code>10</code> bis <code>14</code> daf\u00fcr zur Verf\u00fcgung stehen, da diese mit dem Standartwert f\u00fcr <code>int</code>, der <code>0</code> belegt sind. Aber woher sollen wir wissen, dass dies gar keine \"richtigen\" Werte sind? Da das Array ein unsortiertes <code>int</code>-Array ist, k\u00f6nnen Nullen an allen Stellen vorkommen. Bei dem Einf\u00fcgen in ein unsortiertes Array handelt es sich eigentlich um ein Anh\u00e4ngen (<code>append</code>) des neuen Elementes an das alte Array. Wir ben\u00f6tigen dazu ein neues Array, das um <code>1</code> l\u00e4nger ist als das urspr\u00fcngliche Array. Wir gehen also wie folgt vor: </p> <ol> <li>wir erzeugen ein neues Array <code>b</code>, das um <code>1</code> l\u00e4nger ist als das Array <code>a</code></li> <li>wir kopieren alle Werte aus <code>a</code> nach <code>b</code></li> <li>wir speichern in das letzte Element von <code>b</code> den neuen Wert <code>element</code></li> </ol> <p>Eine m\u00f6gliche Implementierung daf\u00fcr sieht so aus:</p> <pre><code>public static int[] append(int[] a, int element)\n{\n    int[] b = new int[a.length+1];\n    for(int index=0; index&lt;a.length; index++)\n    {\n        b[index]=a[index];\n    }\n\n    b[b.length-1] = element;\n    return b;\n}\n</code></pre> <ul> <li>in Zeile <code>3</code> wird das neue Array <code>b</code> erzeugt, das um <code>1</code> \u00e4nger ist als <code>a</code></li> <li>in den Zeilen <code>4-7</code> werden alle Werte aus <code>a</code> nach <code>b</code> kopiert</li> <li>in Zeile <code>9</code> wird dem letzten Element von <code>b</code> der Wert <code>element</code> zugewiesen</li> </ul> <p>Es geschieht also folgendes:</p> <p></p> <p>Wir merken uns also: das Einf\u00fcgen in ein unsortiertes Array ist in Wirklichkeit ein Anh\u00e4ngen des Elementes an ein unsortiertes Array. Dazu muss ein neues Array erzeugt werden, das um <code>1</code> l\u00e4nger ist als das Array, an das angeh\u00e4ngt werden soll. </p>"},{"location":"arrays/#einfugen-in-ein-sortiertes-array","title":"Einf\u00fcgen in ein sortiertes Array","text":"<p>Das Einf\u00fcgen in ein sortiertes Array ist deutlich komplizierter, denn das einzuf\u00fcgende Element muss korrekt, d.h. an die richtige Stelle entsprechend der Sortierung, eingef\u00fcgt werden. Angenommen, wir haben folgende Ausgangsposition:</p> <p></p> <p>Das einzuf\u00fcgende Element mit dem Wert <code>13</code> muss zwischen die beiden Elemente mit den Werten <code>12</code> und <code>14</code> eingef\u00fcgt werden. Wir gehen dabei wie folgt vor:</p> <ol> <li>wir erzeugen ein neues Array <code>b</code>, das um <code>1</code> l\u00e4nger ist als <code>a</code></li> <li>wir kopieren alle Werte aus <code>a</code> nach <code>b</code> solange die Werte kleiner sind als das einzuf\u00fcgende Element</li> <li>wenn wir auf das erste Element in <code>a</code> sto\u00dfen, das gr\u00f6\u00dfer ist als das einzuf\u00fcgende Element, f\u00fcgen wir das Element ein</li> <li>danach kopieren wir die restlichen Werte aus <code>a</code> nach <code>b</code> </li> </ol> <p></p> <p>Wir setzen obigen Algorithmus in folgender Methode um: </p> <pre><code>public static int[] insertIntoSortedArray(int[] a, int element)\n{\n    int[] b = new int[a.length+1];\n    int indexB=0, indexA =0;\n    while(indexA&lt;a.length &amp;&amp; a[indexA]&lt;element)  \n    {\n        b[indexB++]=a[indexA++];\n    }\n\n    b[indexB++] = element;  // from now on indexB = indexA+1\n\n    while(indexB&lt;b.length)\n    {\n        b[indexB++]=a[indexA++];\n    }\n    return b;\n}\n</code></pre> <ul> <li>in Zeile <code>3</code> wird das Array <code>b</code> erzeugt, welches um <code>1</code> l\u00e4nger ist als <code>a</code></li> <li>in Zeilen <code>5-8</code> kopieren wir alle Werte aus <code>a</code> nach <code>b</code>, die kleiner sind als unser <code>element</code></li> <li>in Zeile <code>10</code> wird <code>element</code> in <code>b</code> eingef\u00fcgt</li> <li>in Zeilen <code>12-15</code> kopieren wir die restlichen Werte aus <code>a</code> nach <code>b</code></li> </ul> <p>Beachten Sie:</p> <ul> <li>in der Anweisung <code>b[indexB++]=a[indexA++];</code> passieren mehrere Sachen auf einmal: <ul> <li>einerseits <code>b[indexB]=a[indexA];</code> und</li> <li>au\u00dferdem noch <code>indexB++;</code> </li> <li>und <code>indexA++</code>; </li> </ul> </li> <li>nach der Anweisung <code>b[indexB++] = element;</code> ist <code>indexB</code> um <code>1</code> gr\u00f6\u00dfer als <code>indexA</code> (was ja auch gut ist, siehe im Bild das \"rote\" Kopieren)</li> </ul> Spielen Sie den Fall durch, dass eine <code>0</code> in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! <ul> <li>Dann wird die erste <code>while</code>-Schleife gar nicht betreten, da die (Teil-)Bedingung <code>a[indexA]&lt;element</code> gleich <code>false</code> ist</li> </ul> Spielen Sie den Fall durch, dass eine <code>27</code> in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! <ul> <li>Dann wird die zweite <code>while</code>-Schleife gar nicht betreten, da die Bedingung <code>indexB&lt;b.length</code> gleich <code>false</code> ist</li> </ul> Die Bedingung der ersten <code>while</code>-Schleife lautet <code>indexA&lt;a.length &amp;&amp; a[indexA]&lt;element</code>. K\u00f6nnte man das auch umdrehen und <code>a[indexA]&lt;element &amp;&amp; indexA&lt;a.length</code> schreiben? <ul> <li>Nein, das k\u00f6nnte zu einem Fehler f\u00fchren. Der Operator <code>&amp;&amp;</code> hat (im Gegensatz zum Operator <code>&amp;</code>) die Eigenschaft, dass die zweite Teilbedingung (also <code>a[indexA]&lt;element</code>) gar nicht mehr gepr\u00fcft wird, wenn die erste bereits <code>false</code> ist. Angenommen, die Teilbedingung <code>indexA&lt;a.length</code> ist <code>false</code>, dann ist <code>indexA==a.length</code>. Dann k\u00f6nnen wir aber nicht mehr mit <code>a[indexA]</code> auf ein Element in <code>a</code> zugreifen, da der Index <code>a.length</code> nicht existiert. Wir w\u00fcrden eine <code>ArrayIndexOutOfBoundsException</code> geworfen bekommen. F\u00fcr den Fall also, dass das neu einzuf\u00fcgende Element ganz an das Ende des neuen Arrays <code>b</code> kommt, muss die Bedingung genau in dieser Reihenfolge formuliert werden. </li> </ul> <p>Success</p> <p>Wir kennen jetzt Arrays. Wir k\u00f6nnen sie erzeugen, wir k\u00f6nnen sie miteinander verbinden. Wir k\u00f6nnen Elemente darin suchen, sowohl in sortierten als auch in unsortierten Arrays. Wir k\u00f6nnen Elemente einf\u00fcgen. Bitte beachten Sie, dass die Elemente eines Arrays von jedem beliebigen Typ sein k\u00f6nnen, auch Referenztypen. Jetzt lernen wir noch, wie wir Arrays sortieren k\u00f6nnen und werden uns sp\u00e4ter nochmal mit Arrays besch\u00e4ftigen, deren Elemente von Referenztypen sind und somit Objekte beinhalten. </p> <ol> <li> <p>ganz genau geben wir die Referenz auf das <code>copy</code>-Array zur\u00fcck, aber dazu sp\u00e4ter\u00a0\u21a9</p> </li> </ol>"},{"location":"aufgaben/","title":"Aufgaben","text":"<p>Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier. Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. </p>"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","title":"Hinweise zur Abgabe der Aufgaben","text":"<p>Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. </p> <p>Bitte laden Sie weder L\u00f6sungen hoch, die Sie mithilfe von KI erstellt haben, noch die L\u00f6sung, die vollst\u00e4ndig der L\u00f6sung aus dem Tutorium entspricht! Ein Hochladen einer L\u00f6sung ist nicht zwingend notwendig! Es geht mir darum, Ihre L\u00f6sungen bzw. L\u00f6sungsversuche zu betrachten, um Schwerpunkte in der Vorlesung setzen zu k\u00f6nnen. Ihnen sollte es darum gehen, m\u00f6glichst viel selbst\u00e4ndig zu programmieren und versuchen, eigene L\u00f6sungen zu entwickeln. Am Ende sollen Sie programmieren und nicht fremde L\u00f6sungen in Moodle hochladen k\u00f6nnen. Es ist viel mehr wert, es versucht zu haben und nicht fertig geworden zu sein, als es gar nicht erst selbst\u00e4ndig versucht zu haben. Sie lernen Programmieren nur durch Programmieren! Es gibt keinen anderen Weg.</p>"},{"location":"aufgaben/#eclipse","title":"Eclipse","text":"<p>Sie sind in der Wahl Ihrer Entwicklungsumgebung frei. Ich verwende in der Veranstaltung Eclipse. Daf\u00fcr gelten die folgenden Hinweise: </p> <ul> <li>Achten Sie darauf, dass Sie die Quelldateien (also die <code>.java</code>-Dateien aus dem <code>src</code>-Verzeichnis) hochladen. </li> <li>Ihre Klassen erstellen Sie immer in einem package <code>aufgaben.aufgabeX</code>. Das hei\u00dft, Aufgabe1 ist im package <code>aufgaben.aufgabe1</code>, Aufgabe2 im package <code>aufgaben.aufgabe2</code> usw. </li> <li>In Ihrem <code>workspace</code>gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. <code>WS24</code> (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein <code>bin</code>- und ein <code>src</code>-Ordner. In dem <code>src</code>-Ordner befindet sich dann ein Ordner <code>aufgaben</code> und darin ein Ordner <code>aufgaben1</code> (f\u00fcr Aufgabe1). Darin befindet sich Ihre <code>.java</code>-Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse <code>Aufgabe1</code> genannt, dann hei\u00dft die Klasse also <code>Aufgabe1.java</code>. Sie folgen also dem Pfad <code>workspace</code>\u2192 Java-Projekt (z.B. <code>WS24</code>) \u2192 <code>src</code> \u2192 <code>aufgaben</code> \u2192 <code>aufgabe</code>X.</li> <li>Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren <code>.java</code>-Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den <code>aufgabeX</code>-Ordner und laden das <code>.zip</code>-File hoch. </li> <li>In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein (<code>/** ... */</code>). Dieser enth\u00e4lt ein <code>@author</code>-Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus:     <pre><code>package aufgaben.aufgabe1;\n\n/**\n * \n * @author J\u00f6rn Freiheit\n * \n * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus.\n * Der Rhombus ist entweder gefuellt oder ungefuellt. \n *\n */\npublic class Aufgabe1\n{\n    // hier Ihre Implementierung\n}\n</code></pre></li> <li>Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das <code>@author</code>-Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!</li> </ul>"},{"location":"aufgaben/#aufgaben_1","title":"Aufgaben","text":"Aufgabe1 - Rhombus <ul> <li>Erstellen Sie eine Klasse <code>Aufgabe1</code> mit <code>main()</code>-Methode im package <code>aufgaben.aufgabe1</code> </li> <li>Implementieren Sie eine Methode <code>public static void printRhombus(int upperHalf, boolean filled){}</code></li> <li>Ist der Parameterwert von <code>filled</code> <code>true</code>, dann soll ein Rhombus (eine Raute) wie folgt auf die Konsole ausgegeben werden:     <pre><code>      *\n     ***\n    *****\n   *******\n  *********\n ***********\n  *********\n   *******\n    *****\n     ***\n      *\n</code></pre></li> <li>Ist der Parameterwert von <code>filled</code> <code>false</code>, dann soll der Rhombus ungef\u00fcllt sein, also so:     <pre><code>      *\n     * *\n    *   *\n   *     *\n  *       *\n *         *\n  *       *\n   *     *\n    *   *\n     * *\n      *\n</code></pre></li> <li>der Wert f\u00fcr <code>upperHalf</code> gibt die H\u00f6he einer H\u00e4lfte des Rhombus an. Die Gesamth\u00f6he des Rhombus berechnet sich aus `     <pre><code>int height = 2 * upperHalf +1;\n</code></pre></li> <li>In unserem oben gezeigten Beispiel ist der Wert von <code>upperHalf</code> <code>5</code> und die Gesamth\u00f6he des Rhombus <code>11</code>. </li> <li>Die obere Ausgabe ist also durch die Anweisung <code>printRhombus(5, true);</code> und die untere durch die Anweisung <code>printRhombus(5, false);</code> entstanden.</li> <li>Die Berechnung der H\u00f6he aus dem Parameterwert <code>upperHalf</code> hat die Vorteile, <ul> <li>dass die H\u00f6he dadurch immer eine ungerade Zahl ist (was notwendig ist) und </li> <li>dass Sie den Wert <code>upperHalf</code> gut verwenden k\u00f6nnen (was ebenfalls notwendig ist, wie Sie merken werden)</li> </ul> </li> <li> <p>Tipps:: </p> <ul> <li> <p>Fangen Sie auf keinen Fall gleich an zu programmieren, sondern \u00fcberlegen sich mithilfe von Zettel und Stift z.B. die Antworten auf folgende Fragen:</p> <ul> <li>Wieviele Zeilen hat der Rhombus insgesamt f\u00fcr einen gegebenen Wert von <code>upperHalf</code>?</li> <li>Wenn die obere H\u00e4lfte des Rhombus gezeichnet wird und Sie sind in Zeile <code>i</code>, wieviele Leerzeichen werden zun\u00e4chst ausgegeben und wieviele Sterne folgen dann?</li> <li>Wieviele Sterne m\u00fcssen Sie in der mittleren Zeile ausgeben?</li> <li>Wenn die untere H\u00e4lfte des Rhombus gezeichnet wird und Sie sind in Zeile <code>i</code>, wieviele Leerzeichen werden zun\u00e4chst ausgegeben und wieviele Sterne folgen dann?</li> </ul> </li> <li> <p>Zerlegen Sie den Rhombus gedanklich in drei Teile: eine obere H\u00e4lfte, die mittlere Zeile und eine untere H\u00e4lfte.</p> </li> <li>Schreiben Sie sich zwei weitere Methoden <code>public static void printRhombusFilled(int upperHalf){}</code> und <code>public static void printRhombusUnfilled(int upperHalf){}</code>, die Sie entsprechend des Wertes von <code>filled</code> aufrufen. In der einen Methode erstellen Sie die ausgef\u00fcllte Raute und in der anderen die ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. </li> </ul> </li> <li> <p>Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Wert <code>50</code>) positive Zahlen (also <code>&gt; 0</code>) von <code>upperHalf</code> funktionieren. Insbesondere sind die Tests f\u00fcr <code>upperhalf == 1</code> interessant. </p> </li> <li>Viel Spa\u00df und viel Erfolg!</li> </ul> Aufgabe2 - Numbers <ul> <li>Erstellen Sie eine Klasse <code>Aufgabe2</code> mit <code>main()</code>-Methode im package <code>aufgaben.aufgabe2</code>.</li> <li>Bei der L\u00f6sung der Aufgabe soll nicht der Datentyp <code>String</code> verwendet werden! </li> <li> <p>Implementieren Sie eine Methode <code>public static int lengthOfNumber(int number){}</code>. Diese Methode gibt die L\u00e4nge von <code>number</code> zur\u00fcck, d.h. die Anzahl der Ziffern in der Zahl. Beachten Sie: f\u00fcr <code>number == 0</code> soll jedoch <code>0</code> zur\u00fcckgegeben werden.  Beispiele: <pre><code>number  --&gt; R\u00fcckgabewert\n0       --&gt; 0\n1       --&gt; 1\n9       --&gt; 1\n10      --&gt; 2\n1234    --&gt; 4\n-1234   --&gt; 4\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int firstDigit(int number){}</code>. Diese Methode gibt die erste Ziffer von <code>number</code> zur\u00fcck.   Beispiele: <pre><code>number  --&gt; R\u00fcckgabewert\n0       --&gt; 0\n1       --&gt; 1\n9       --&gt; 9\n10      --&gt; 1\n1234    --&gt; 1\n-1234   --&gt; 1\n5678    --&gt; 5\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int powerOf10ToN(int n){}</code>. Diese Methode gibt den Wert f\u00fcr <code>10 ^ n</code> zur\u00fcck. Sie k\u00f6nnen davon ausgehen, dass <code>n &gt;= 0</code> gilt.   Beispiele: <pre><code>n       --&gt; R\u00fcckgabewert\n0       --&gt; 1\n1       --&gt; 10\n2       --&gt; 100\n3       --&gt; 1000\n4       --&gt; 10000\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int cutFirstDigit(int number){}</code>. Diese Methode entfernt von <code>number</code> die erste Ziffer.  F\u00fcr <code>-10 &lt; number &lt; 10</code> wird <code>0</code> zur\u00fcckgegeben.  Beispiele: <pre><code>number  --&gt; R\u00fcckgabewert\n0       --&gt; 0\n1       --&gt; 0\n9       --&gt; 0\n-9      --&gt; 0\n11      --&gt; 1\n91      --&gt; 1\n1234    --&gt; 234\n-1234   --&gt; -234\n9999    --&gt; 999\n-9999   --&gt; -999\n1023    --&gt; 23  // Achtung! f\u00fchrende Nullen in der verbleibenden Zahl entfallen\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static boolean secondDigitIsZero(int number){}</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn die zweite Ziffer in <code>number</code> eine <code>0</code> ist. Sonst <code>false</code>.  Beispiele: <pre><code>number  --&gt; R\u00fcckgabewert\n0       --&gt; false\n1       --&gt; false\n9       --&gt; false\n11      --&gt; false\n101     --&gt; true\n111     --&gt; false\n1001    --&gt; true\n-10234  --&gt; true\n1111    --&gt; false\n10000   --&gt; true\n</code></pre></p> </li> <li> <p>Testen Sie alle Methoden ausf\u00fchrlich in der <code>main()</code>-Methode.</p> </li> <li> <p>Viel Spa\u00df und viel Erfolg!</p> </li> </ul> Aufgabe 3 - Triangle <ul> <li> <p>Wir erstellen uns einen neuen Datentyp <code>Triangle</code></p> </li> <li> <p>Erstellen Sie im package <code>aufgaben.aufgabe3</code> eine Klasse <code>Triangle</code> ohne <code>main()</code>-Methode und eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. </p> </li> <li> <p>In der Klasse <code>Triangle</code> erstellen Sie drei Objektvariablen <code>a</code>, <code>b</code> und <code>c</code> jeweils vom Typ <code>int</code> und alle <code>private</code>. Das sollen die Seiten unseres Dreiecks sein. </p> </li> <li> <p>Erstellen Sie einen Konstruktor, dem drei Parameterwerte \u00fcbergeben werden <code>pa</code>, <code>pb</code> und <code>pc</code> alle vom Typ <code>int</code>. Mit diesen Werten werden die Objektvariablen initialisiert. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>, die die Seitenl\u00e4ngen des Dreiecks in der folgenden Form ausgibt:     <pre><code>Seiten          : a=3, b=4, c=5\n</code></pre>     f\u00fcr den Fall, dass die Seitenl\u00e4ngen <code>3</code>, <code>4</code> und <code>5</code> sind. </p> </li> <li> <p>Wenn Sie jetzt in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen ausf\u00fchren     <pre><code>Triangle t1 = new Triangle(3, 4, 5);\nTriangle t2 = new Triangle(4, 4, 7);\nTriangle t3 = new Triangle(5, 5, 5);\nTriangle t4 = new Triangle(4, 5, 3);\nTriangle t5 = new Triangle(4, 3, 5);\nTriangle t6 = new Triangle(3, 4, 5);\n\nt1.print();\nt2.print();\nt3.print();\nt4.print();\nt5.print();\nt6.print();\n</code></pre>     dann sollte die Ausgabe ungef\u00e4hr so aussehen:     <pre><code>Seiten          : a=3, b=4, c=5\nSeiten          : a=4, b=4, c=7\nSeiten          : a=5, b=5, c=5\nSeiten          : a=4, b=5, c=3\nSeiten          : a=4, b=3, c=5\nSeiten          : a=3, b=4, c=5\n</code></pre></p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public int circumference()</code>, die den Umfang des Dreiecks zur\u00fcckgibt (also die Summe der drei Seitenl\u00e4ngen).</p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public double area()</code>, die den Flaecheninhalt des Dreiecks zur\u00fcckgibt.  Der Fl\u00e4cheninhalt <code>A</code> eines Dreiecks l\u00e4sst sich nach der Heron'schen Formel wie folgt berechnen:</p> <ul> <li>`A = Math.sqrt(s * (s-a) * (s-b) * (s-c)) (siehe Klasse Math)</li> <li>wobei <code>s = (a + b + c) / 2</code></li> <li>Achten Sie darauf, dass Sie stets mit <code>double</code> rechnen!</li> <li>Beachten Sie, dass in einem Dreieck keine Seite l\u00e4nger sein darf als die Summe der beiden anderen. F\u00fcr die oben in der <code>main()</code>-Methode erstellten Objekte gilt das aber. Wir m\u00fcssen deshalb nichts weiter beachten. </li> </ul> </li> <li> <p>Erweitern Sie die Objektmethode <code>print()</code> nun so, dass auch der Umfang und der Flaecheninhalt in der folgenden Form ausgegeben werden (Sie k\u00f6nnen in die <code>print()</code>-methode auch die Leerzeile integrieren):     <pre><code>Seiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\n\nSeiten          : a=4, b=4, c=7\nUmfang          : 15\nFlaecheninhalt  : 6.777720855862979\n\nSeiten          : a=5, b=5, c=5\nUmfang          : 15\nFlaecheninhalt  : 10.825317547305483\n\nSeiten          : a=4, b=5, c=3\nUmfang          : 12\nFlaecheninhalt  : 6.0\n\nSeiten          : a=4, b=3, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\n\nSeiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\n</code></pre></p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean equilateral()</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das Dreieck gleichseitig ist (also alle Seiten des Dreiecks gleich lang sind) und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean isosceles()</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das Dreieck gleichschenklig ist (also zwei Seiten des Dreiecks gleich lang sind) und <code>false</code> sonst.</p> </li> <li> <p>Erweitern Sie die Objektmethode <code>print()</code> nun so, dass die Pr\u00fcfungen, ob sich um ein gleichseitiges oder gleichschenkliges (oder unregelm\u00e4\u00dfiges) Dreieck handelt, in der folgenden Form ausgegeben werden:     <pre><code>Seiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\n\nSeiten          : a=4, b=4, c=7\nUmfang          : 15\nFlaecheninhalt  : 6.777720855862979\nDas Dreieck ist gleichschenklig.\n\nSeiten          : a=5, b=5, c=5\nUmfang          : 15\nFlaecheninhalt  : 10.825317547305483\nDas Dreieck ist gleichseitig.\n\nSeiten          : a=4, b=5, c=3\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\n\nSeiten          : a=4, b=3, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\n\nSeiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\n</code></pre></p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean sameCircumference(Triangle t)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt den gleichen Umfang hat wie <code>t</code> und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean isSmaller(Triangle t)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren Fl\u00e4cheninhalt hat, als <code>t</code> und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean isBigger(Triangle t)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt einen gr\u00f6\u00dferen Fl\u00e4cheninhalt hat, als <code>t</code> und <code>false</code> sonst.</p> </li> <li> <p>Testen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> die drei zuletztgeschriebenen Methoden, so dass folgende Ausgaben erzeugt werden:     <pre><code>t1 und t2 gleicher Umfang ? : false\nt1 und t3 gleicher Umfang ? : false\nt2 und t3 gleicher Umfang ? : true\n\nt1 kleiner als t2 ? : true\nt2 kleiner als t1 ? : false\nt1 kleiner als t4 ? : false\nt4 kleiner als t1 ? : false\n\nt1 groesser als t2 ? : false\nt2 groesser als t1 ? : true\nt1 groesser als t4 ? : false\nt4 groesser als t1 ? : false\n</code></pre></p> </li> </ul> <ul> <li>Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional :</li> </ul> <ul> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean sidesAreEqual(Triangle t)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt die gleichen Seitenl\u00e4ngen hat wie <code>t</code> und <code>false</code> sonst.</p> <ul> <li>Beachten Sie, dass folgende Dreiecke mit z.B. dem Dreieck (<code>a=3, b=4, c=5</code>) gleich sein sollen: (<code>a=3, b=4, c=5</code>), aber auch (<code>a=4, b=5, c=3</code>), aber auch (<code>a=5, b=3, c=4</code>) \u2192 die \"Benennung\" der Seiten ist also egal</li> <li>Jedoch soll z.B. (<code>a=4, b=3, c=5</code>) nicht gleich zu (<code>a=3, b=4, c=5</code>) sein</li> <li>f\u00fcr die obigen Objekte soll somit gelten:     <pre><code>t1 und t2 gleiche Seiten ? : false\nt1 und t4 gleiche Seiten ? : true\nt1 und t5 gleiche Seiten ? : false\nt1 und t6 gleiche Seiten ? : true\n</code></pre>     Erzeugen Sie diese Ausgabe in <code>main()</code>.</li> </ul> </li> <li> <p>Erstellen Sie in der Klasse <code>Triangle</code> eine Objektmethode <code>public boolean isRightAngled()</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das Dreieck rechtwinklig ist und <code>false</code> sonst.</p> <ul> <li>der Satz des Pythagoras besagt, dass in einem rechtwinkligen Dreieck gilt: <code>a^2 + b^2 = c^2</code></li> <li>es gilt aber auch die Umkehrung, d.h. wenn von 2 Seiten die Summe der Quadrate dem Quadrat der dritten Seite entspricht, dann ist das Dreieck rechtwinklig </li> </ul> </li> <li> <p>Erweitern Sie die Objektmethode <code>print()</code> nun so, dass die Pr\u00fcfungen, ob sich um ein rechtwinkliges Dreieck handelt, in der folgenden Form ausgegeben werden:     <pre><code>Seiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\nDas Dreieck ist rechtwinklig.\n\nSeiten          : a=4, b=4, c=7\nUmfang          : 15\nFlaecheninhalt  : 6.777720855862979\nDas Dreieck ist gleichschenklig.\nDas Dreieck ist nicht rechtwinklig.\n\nSeiten          : a=5, b=5, c=5\nUmfang          : 15\nFlaecheninhalt  : 10.825317547305483\nDas Dreieck ist gleichseitig.\nDas Dreieck ist nicht rechtwinklig.\n\nSeiten          : a=4, b=5, c=3\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\nDas Dreieck ist rechtwinklig.\n\nSeiten          : a=4, b=3, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\nDas Dreieck ist rechtwinklig.\n\nSeiten          : a=3, b=4, c=5\nUmfang          : 12\nFlaecheninhalt  : 6.0\nDas Dreieck ist unregelmaessig.\nDas Dreieck ist rechtwinklig.\n</code></pre></p> </li> <li> <p>Viel Spa\u00df und viel Erfolg!</p> </li> </ul> Aufgabe 4 - Bruch <ul> <li> <p>Wir erstellen uns einen neuen Datentyp <code>Bruch</code></p> </li> <li> <p>Erstellen Sie im package <code>aufgaben.aufgabe4</code> eine Klasse <code>Bruch</code> ohne <code>main()</code>-Methode und eine Klasse <code>BruchTest</code> mit <code>main()</code>-Methode. </p> </li> <li> <p>In der Klasse <code>Bruch</code> erstellen Sie zwei Objektvariablen <code>zaehler</code> und <code>nenner</code> jeweils vom Typ <code>int</code> und <code>private</code>. </p> </li> <li> <p>Implementieren Sie fu\u0308r die Klasse <code>Bruch</code> zwei verschiedene Konstruktoren</p> <ul> <li>parameterlos \u2192 <code>zaehler</code> und <code>nenner</code> erhalten jeweils den Wert <code>1</code></li> <li>mit zwei Parametern (<code>int zaehler, int nenner</code>) \u2192 entspr. Werte der Objektvariablen </li> </ul> </li> <li> <p>Implementieren Sie folgende Objektmethoden</p> <ul> <li><code>public Bruch plus(Bruch b)</code> \u2192 gibt den geku\u0308rzten Bruch aus der Addition eines Bruchs mit <code>b</code> zuru\u0308ck</li> <li><code>public Bruch minus(Bruch b)</code> \u2192 gibt den geku\u0308rzten Bruch aus der Subtraktion eines Bruchs mit <code>b</code> zuru\u0308ck</li> <li><code>public Bruch mal(Bruch b)</code> \u2192 gibt den geku\u0308rzten Bruch aus der Multiplikation eines Bruchs mit <code>b</code> zuru\u0308ck</li> <li><code>public Bruch geteilt(Bruch b)</code> \u2192 gibt den geku\u0308rzten Bruch aus der Division eines Bruchs mit <code>b</code> zuru\u0308ck</li> <li><code>public Bruch kuerzen()</code> \u2192 gibt den geku\u0308rzten Bruch zuru\u0308ck (Sie brauchen dazu den <code>ggT</code>) _ <code>public String toString()</code> \u2192 gibt einen Bruch als <code>String</code> in der Form <code>zaehler / nenner</code> zur\u00fcck</li> <li><code>public int ggT(int zahl1, int zahl2)</code> \u2192 gibt den gr\u00f6\u00dften gemeinsamen Teiler (ggT) der beiden Zahlen <code>zahl1</code> und <code>zahl2</code> als <code>int</code> zuru\u0308ck - siehe Euklidischer Algorithmus</li> </ul> </li> <li> <p>Geben Sie in die <code>main()</code>-Methode der <code>BruchTest</code>-Klasse mindestens folgende Anweisungen ein:     <pre><code>Bruch b1 = new Bruch(3,7);\nBruch b2 = new Bruch(4,8);\nBruch b3 = new Bruch(2,5);\nBruch b4 = new Bruch(5,11);\nBruch b5 = new Bruch();\n\nSystem.out.printf(\"%n%n------------------------- Rechnen -----------------------------------%n%n\");\nSystem.out.printf(\"%5s + %5s = %5s %n\", b1.toString(), b2.toString(), b1.plus(b2).toString());\nSystem.out.printf(\"%5s - %5s = %5s %n\", b3.toString(), b4.toString(), b3.minus(b4).toString());\nSystem.out.printf(\"%5s * %5s = %5s %n\", b1.toString(), b3.toString(), b1.mal(b3).toString());\nSystem.out.printf(\"%5s / %5s = %5s %n\", b2.toString(), b1.toString(), b2.geteilt(b1).toString());\nSystem.out.printf(\"%5s + %5s = %5s %n\", b5.toString(), b4.toString(), b5.plus(b4).toString());  \nSystem.out.printf(\"%5s - %5s = %5s %n\", b1.toString(), b1.toString(), b1.minus(b1).toString());     // nenner sollte ungleich 0 bleiben!    \n</code></pre>     und f\u00fchren Sie die <code>BruchTest</code>-Klasse aus. Es sollten folgende Augaben entstehen:     <pre><code>------------------------- Rechnen -----------------------------------\n\n  3/7 +   4/8 = 13/14 \n  2/5 -  5/11 = -3/55 \n  3/7 *   2/5 =  6/35 \n  4/8 /   3/7 =   7/6 \n  1/1 +  5/11 = 16/11\n  3/7 -   3/7 =   0/1 \n</code></pre></p> </li> </ul> <ul> <li>Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional :</li> </ul> <ul> <li> <p>Implementieren Sie folgende Objektmethoden</p> <ul> <li><code>public boolean istGroesser(Bruch b)</code> \u2192 gibt <code>true</code> zur\u00fcck, wenn der aufrufende Bruch gr\u00f6\u00dfer als <code>b</code> ist, <code>false</code> sonst</li> <li><code>public boolean istKleiner(Bruch b)</code> \u2192 gibt <code>true</code> zur\u00fcck, wenn der aufrufende Bruch kleiner als <code>b</code> ist, <code>false</code> sonst</li> <li><code>public boolean istGleich(Bruch b)</code> \u2192 gibt <code>true</code> zur\u00fcck, wenn der aufrufende Bruch gleich <code>b</code> ist, <code>false</code> sonst</li> </ul> </li> <li> <p>Geben Sie in die <code>main()</code>-Methode der <code>BruchTest</code>-Klasse mindestens folgende weitere Anweisungen ein:     <pre><code>System.out.printf(\"%n%n------------------------- Vergleichen -----------------------------------%n%n\");\nSystem.out.printf(\"%5s  &gt; %5s ? %b %n\", b1.toString(), b2.toString(), b1.istGroesser(b2));\nSystem.out.printf(\"%5s  &lt; %5s ? %b %n\", b1.toString(), b2.toString(), b1.istKleiner(b2));\nSystem.out.printf(\"%5s == %5s ? %b %n\", b1.toString(), b2.toString(), b1.istGleich(b2));\nSystem.out.printf(\"%5s  &gt; %5s ? %b %n\", b3.toString(), b4.toString(), b3.istGroesser(b4));\nSystem.out.printf(\"%5s  &lt; %5s ? %b %n\", b3.toString(), b4.toString(), b3.istKleiner(b4));\nSystem.out.printf(\"%5s == %5s ? %b %n\", b3.toString(), b4.toString(), b3.istGleich(b4));\nSystem.out.printf(\"%5s  &gt; %5s ? %b %n\", b5.toString(), b5.toString(), b5.istGroesser(b5));\nSystem.out.printf(\"%5s  &lt; %5s ? %b %n\", b5.toString(), b5.toString(), b5.istKleiner(b5));\nSystem.out.printf(\"%5s == %5s ? %b %n\", b5.toString(), b5.toString(), b5.istGleich(b5));\n</code></pre>     und f\u00fchren Sie die <code>BruchTest</code>-Klasse aus. Es sollten folgende weitere Augaben entstehen:     <pre><code>------------------------- Vergleichen -----------------------------------\n\n  3/7  &gt;   4/8 ? false \n  3/7  &lt;   4/8 ? true \n  3/7 ==   4/8 ? false \n  2/5  &gt;  5/11 ? false \n  2/5  &lt;  5/11 ? true \n  2/5 ==  5/11 ? false \n  1/1  &gt;   1/1 ? false \n  1/1  &lt;   1/1 ? false \n  1/1 ==   1/1 ? true \n</code></pre></p> </li> <li> <p>Viel Spa\u00df und viel Erfolg!</p> </li> </ul> Aufgabe 5 - Doppelt-verkettete Liste <ul> <li> <p>Wir erstellen uns einen neuen Datentyp <code>ListElement</code>. Dieser Datentyp wird f\u00fcr ein Element aus einer doppelt verketteten Liste verwendet. Eine Liste kann aus vielen <code>ListElement</code>-Elementen bestehen. Ein <code>ListElement</code> hat einen Vorg\u00e4nger (<code>predecessor</code>) und einen Nachfolger (<code>successor</code>) in der Liste. Nur das erste Element hat keinen Vorg\u00e4nger und das letzte Element hat keinen Nachfolger.</p> </li> <li> <p>Erstellen Sie im package <code>aufgaben.aufgabe5</code> eine Klasse <code>ListElement</code> ohne <code>main()</code>-Methode und eine Klasse <code>Programmklasse</code> mit <code>main()</code>-Methode. </p> </li> <li> <p>In der Klasse <code>ListElement</code> erstellen Sie f\u00fcnf nur in der Klasse sichtbare Objektvariablen:</p> <ul> <li><code>value</code> vom Typ <code>char</code> </li> <li><code>hasPredecessor</code> vom Typ <code>boolean</code> </li> <li><code>hasSuccessor</code> vom Typ <code>boolean</code></li> <li><code>predecessor</code> vom Typ <code>ListElement</code> und</li> <li><code>successor</code> vom Typ <code>ListElement</code></li> </ul> </li> <li> <p>Implementieren Sie fu\u0308r die Klasse <code>ListElement</code> einen Konstruktor, dem ein Zeichen (<code>char</code>) als Parameter \u00fcbergeben wird. Dieses Zeichen wird verwendet, um der Objektvariablen <code>value</code> einen Wert zuzuweisen. Setzen Sie au\u00dferdem die Objektvariablen <code>hasPredecessor</code> und <code>hasSuccessor</code> jeweils auf <code>false</code>. </p> </li> <li> <p>Implementieren Sie die Objektmethode <code>public void insertBefore(ListElement element)</code>. Durch Aufruf dieser Methode soll das aufrufende <code>ListElement</code>-Objekt vor das <code>ListElement</code>-Objekt <code>element</code> in die Liste eingef\u00fcgt werden. Dabei sind mehrere Dinge zu beachten:</p> <ul> <li> <p>Angenommen, wir haben zwei einzelne <code>ListElement</code>-Objekte <code>l1</code> und <code>l2</code>. Dann entsteht durch <code>li.insertBefore(l2)</code> die Liste <code>l1 &lt;--&gt; l2</code>. Das hei\u00dft, <code>l2</code> wird der <code>successor</code> von <code>l1</code> und <code>l1</code> wird der <code>predecessor</code> von <code>l2</code>. Setzen Sie entsprechend auch die Variablenwerte f\u00fcr <code>hasSuccessor</code> und <code>hasPredecessor</code>.</p> </li> <li> <p>Angenommen, wir haben ein einzelnes <code>ListElement</code>-Objekt <code>l1</code> und eine Liste aus lauter <code>ListElement</code>-Objekten <code>l2 &lt;--&gt; l3 &lt;--&gt; l4 &lt;--&gt; l5</code>. Dann </p> <ul> <li>ensteht durch <code>l1.insertBefore(l2)</code> die Liste <code>l1 &lt;--&gt; l2 &lt;--&gt; l3 &lt;--&gt; l4 &lt;--&gt; l5</code> und alles ist, wie im Fall zuvor, d.h. <code>l1</code> ist der <code>predecessor</code> von <code>l2</code> und <code>l2</code> ist der <code>successor</code> von <code>l1</code>.</li> <li>entsteht durch <code>l1.insertBefore(l3)</code> die Liste <code>l2 &lt;--&gt; l1 &lt;--&gt; l3 &lt;--&gt; l4 &lt;--&gt; l5</code>. Das bedeutet, dass <code>l3</code> der <code>successor</code> von <code>l1</code> wird und <code>l1</code> der <code>predecessor</code> von <code>l3</code>. Der alte <code>predecessor</code> von <code>l3</code> (<code>l2</code>) wird der neue <code>predecessor</code> von <code>l1</code> und <code>l1</code> wird der neue <code>successor</code> von <code>l2</code>.</li> </ul> </li> <li> <p>Angenommen, wir haben eine Liste aus lauter <code>ListElement</code>-Objekten <code>l1 &lt;--&gt; l2 &lt;--&gt; l3</code> und ein einzelnes <code>ListElement</code>-Objekt <code>l4</code>. Dann </p> <ul> <li>ensteht sowohl durch <code>l1.insertBefore(l4)</code> als auch durch <code>l2.insertBefore(l4)</code> als auch durch <code>l3.insertBefore(l4)</code> die Liste <code>l1 &lt;--&gt; l2 &lt;--&gt; l3 &lt;--&gt; l4</code>.</li> </ul> </li> <li> <p>Angenommen, wir haben eine Liste aus lauter <code>ListElement</code>-Objekten <code>l1 &lt;--&gt; l2 &lt;--&gt; l3</code> und eine Liste aus lauter <code>ListElement</code>-Objekten <code>l4 &lt;--&gt; l5 &lt;--&gt; l6 &lt;--&gt; l7</code>. Dann </p> <ul> <li>ensteht durch <code>l1.insertBefore(l4)</code> die Liste <code>l1 &lt;--&gt; l2 &lt;--&gt; l3 &lt;--&gt; l4 &lt;--&gt; l5 &lt;--&gt; l6 &lt;--&gt; l7</code>. Das hei\u00dft, es wird die gesamte Liste, die mit <code>l1</code> beginnt, vor <code>l4</code> eingef\u00fcgt (und damit vor die Liste <code>l4 &lt;--&gt; l5 &lt;--&gt; l6 &lt;--&gt; l7</code>). </li> <li>entsteht durch <code>l1.insertBefore(l6)</code> die Liste <code>l4 &lt;--&gt; l5 &lt;--&gt; l1 &lt;--&gt; l2 &lt;--&gt; l3 &lt;--&gt; l6 &lt;--&gt; l7</code>. </li> <li>\u00fcbrigens: wenn Sie f\u00fcr die gebebenen Lsten z.B. <code>l2.insertBefore(l5)</code> aufrufen, dann f\u00e4llt <code>l1</code> weg, d.h. die entstehende Liste ist <code>l4 &lt;--&gt; l2 &lt;--&gt; l5 &lt;--&gt; l6 &lt;--&gt; l7</code>. Sie k\u00f6nnen sich \u00fcberlegen, ob das \u00fcberhaupt ein richtiges Verhalten ist oder ob es ein besseres gibt. </li> </ul> </li> </ul> </li> <li> <p>Tipp: Beginnen Sie mit der Implementierung des ersten (und einfachsten) Falls. F\u00fcgen Sie dann die weiteren F\u00e4lle schrittweise hinzu. Sie werden feststellen, dass Sie gar nicht viele Fallunterscheidungen machen m\u00fcssen. Ich bin z.B. mit einem <code>if</code> und einer <code>while</code>-Schleife ausgekommen und die gesamte Methode hat nur ca. 10 Zeilen.</p> </li> <li> <p>Implementieren Sie die Objektmethode <code>public void print()</code>. Diese Methode soll den <code>value</code> des aufrufenden <code>ListElement</code>-Objektes auf die Konsole ausgeben (ohne Zeilenumbruch) und dann die <code>print()</code>-Methode des <code>successor</code>-Elementes aufrufen. Nur wenn das aufrufende <code>ListElement</code> keinen <code>successor</code> hat (Ende der Liste), wird der Wert des Objektes mit Zeilenumbruch ausgegeben und keine weitere <code>print()</code>-Methode aufgerufen. </p> </li> <li> <p>Geben Sie in die <code>main()</code>-Methode der <code>Programmklasse</code> mindestens folgende Anweisungen ein:     <pre><code>ListElement l1 = new ListElement('W');\nListElement l2 = new ListElement('e');\nListElement l3 = new ListElement('i');\nListElement l4 = new ListElement('h');\nListElement l5 = new ListElement('n');\nListElement l6 = new ListElement('a');\nListElement l7 = new ListElement('c');\nListElement l8 = new ListElement('h');\nListElement l9 = new ListElement('t');\nListElement l10 = new ListElement('e');\nListElement l11 = new ListElement('n');\n\nSystem.out.printf(\"? : %15s\", \"W == \");l1.print();\nl1.insertBefore(l2);        // W-e\nSystem.out.printf(\"? : %15s\", \"We == \");l1.print();\n\nl5.insertBefore(l6);        // n-a\nl5.insertBefore(l7);        // na-c\nl7.insertBefore(l8);        // nac-h\nl6.insertBefore(l9);        // nach-t\nSystem.out.printf(\"? : %15s\", \"nacht == \");l5.print();\n\nl1.insertBefore(l5);        // We-nacht\nSystem.out.printf(\"? : %15s\", \"Wenacht == \");l1.print();            \n\nl10.insertBefore(l11);      // e-n\nl9.insertBefore(l10);       // Wenacht-en\nSystem.out.printf(\"? : %15s\", \"Wenachten == \");l1.print();\nSystem.out.printf(\"? : %15s\", \"nachten == \");l5.print();\n\nl3.insertBefore(l5);        // We-i-nachten\nSystem.out.printf(\"? : %15s\", \"inachten == \");l3.print();\nSystem.out.printf(\"? : %15s\", \"Weinachten == \");l1.print();\nl4.insertBefore(l5);        // Wei-h-nachten\nSystem.out.printf(\"? : %15s\", \"Weihnachten == \");l1.print();\n</code></pre>     und f\u00fchren Sie die <code>Programmklasse</code> aus. Es sollten folgende Augaben entstehen:     <pre><code>? :           W == W\n? :          We == We\n? :       nacht == nacht\n? :     Wenacht == Wenacht\n? :   Wenachten == Wenachten\n? :     nachten == nachten\n? :    inachten == inachten\n? :  Weinachten == Weinachten\n? : Weihnachten == Weihnachten\n</code></pre></p> </li> </ul> <ul> <li> <p>Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende Aufgabe ist optional :</p> <ul> <li>F\u00fcgen Sie der Klasse <code>ListElement</code> die Objektvariable <code>private int index</code> hinzu und sorgen Sie daf\u00fcr, dass in einer verketteten Liste die <code>ListElement</code>-Objekte den jeweils passenden Index entsprechend ihrer Position in der Liste haben (beginnend bei <code>0</code>). Also in der Liste <code>l1 &lt;--&gt; l2 &lt;--&gt; l3 &lt;--&gt; l4 &lt;--&gt; l5</code> hat <code>l1</code> den Index <code>0</code>, <code>l2</code> den Index <code>1</code>, <code>l3</code> den Index <code>2</code> usw. Wenn Sie daf\u00fcr selbst\u00e4ndig eine L\u00f6sung entwickelt haben, dann schicken Sie mir bitte eine E-Mail mit der L\u00f6sung.</li> </ul> </li> </ul> <ul> <li>Viel Spa\u00df und viel Erfolg!</li> </ul> Aufgabe 6 - Arrays ausgeben <ul> <li> <p>Wir geben Arrays in verschiedenen Arten auf der Konsole aus. </p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int[] createAndFillArray(int length, int fromInclusive, int toInclusive)</code>. Diese Methode soll genau so sein, wie die <code>createAndFillArray(int length, int bound)</code>-Methode in Methoden mit Array als R\u00fcckgabe mit dem einzigen Unterschied, dass wir nicht den <code>bound</code> angeben (der sorgt ja daf\u00fcr, dass wir Zufallswerte aus dem Bereich <code>[0, 1, ... , bound-1]</code> erzeugen), sondern <code>fromInclusive</code> und <code>toExclusive</code>, so dass wir Zufallswerte aus dem Wertebereich <code>[fromInclusive, ... , toInclusive]</code> erzeugen. Siehe dazu auch <code>nextInt(bound)</code>.</p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void printArray(int[] a)</code> so, dass sie ein <code>int</code>-Array in der Form <code>[ 27, 30, 25, 26, 23, 20, 30, 30, 22, 21, 29, 29, 21, 20 ]</code> (also Werte durch Komma getrennt in eckigen Klammern) ausgibt. Siehe dazu Ausgabe von Arrays.  </p> </li> <li> <p>Rufen Sie in der <code>main()</code> die beiden Methoden wie folgt auf:     <pre><code>int length = r.nextInt(10)+10;\nint[] arr1 = createAndFillArray(length, 20, 30);\n\nSystem.out.printf(\"%n%n%n----------- printArray -----------------%n%n%n\");\nprintArray(arr1);\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void printTable(int[] a)</code>. Diese gibt das Array <code>a</code> als Tabelle in folgender Form aus:     <pre><code>|\u00a0Index :    |   0  |   1  |   2  |   3  |   4  |   5  |   6  |   7  |   8  |   9  |  10  |  11  |  12  |  13  |\n|------------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|\n|\u00a0Wert :     |  27  |  30  |  25  |  26  |  23  |  20  |  30  |  30  |  22  |  21  |  29  |  29  |  21  |  20  |\n</code></pre></p> </li> <li> <p>Rufen Sie in der <code>main()</code> die Methode <code>printTable()</code> wie folgt auf:     <pre><code>System.out.printf(\"%n%n%n----------- printTable -----------------%n%n%n\");\nprintTable(arr1);\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void printHorizontal(int[] a)</code>. Diese gibt das Array <code>a</code> in folgender Form aus:     <pre><code>    |\u00a0\n  0 | ***************************\n    |\u00a0\n  1 | ******************************\n    |\u00a0\n  2 | *************************\n    |\u00a0\n  3 | **************************\n    |\u00a0\n  4 | ***********************\n    |\u00a0\n  5 | ********************\n    |\u00a0\n  6 | ******************************\n    |\u00a0\n  7 | ******************************\n    |\u00a0\n  8 | **********************\n    |\u00a0\n  9 | *********************\n    |\u00a0\n 10 | *****************************\n    |\u00a0\n 11 | *****************************\n    |\u00a0\n 12 | *********************\n    |\u00a0\n 13 | ********************\n    |\u00a0\n</code></pre>     Das hei\u00dft, f\u00fcr jeden Wert im Array wird die entsprechende Anzahl von Sternen ausgegeben. Ganz links steht jeweils der Index, unter dem der Wert im Array gespeichert wird. </p> </li> <li> <p>Rufen Sie in der <code>main()</code> die Methode <code>printTable()</code> wie folgt auf:     <pre><code>System.out.printf(\"%n%n%n----------- printHorizontal ------------%n%n%n\");\nprintHorizontal(arr1);\n</code></pre></p> </li> </ul> <ul> <li>Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional :</li> </ul> <ul> <li> <p>Implementieren Sie eine Methode <code>public static void printUpsideDown(int[] a)</code> oder eine Methode <code>public static void printVertical(int[] a)</code> (beide gleicher Aufwand). Diese geben das Array <code>a</code> in folgender Form aus: <pre><code>----------- printUpsideDown ------------\n\n\n    |\u00a0  0    1    2    3    4    5    6    7    8    9   10   11   12   13  \n----+----------------------------------------------------------------------\n  1 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  2 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  3 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  4 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  5 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  6 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  7 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  8 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  9 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 10 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 11 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 12 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 13 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 14 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 15 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 16 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 17 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 18 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 19 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 20 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 21 |\u00a0  *    *    *    *    *         *    *    *    *    *    *    *       \n 22 |\u00a0  *    *    *    *    *         *    *    *         *    *            \n 23 |\u00a0  *    *    *    *    *         *    *              *    *            \n 24 |\u00a0  *    *    *    *              *    *              *    *            \n 25 |\u00a0  *    *    *    *              *    *              *    *            \n 26 |\u00a0  *    *         *              *    *              *    *            \n 27 |\u00a0  *    *                        *    *              *    *            \n 28 |\u00a0       *                        *    *              *    *            \n 29 |\u00a0       *                        *    *              *    *            \n 30 |\u00a0       *                        *    *                                \n\n\n\n\n----------- printVertical --------------\n\n\n 30 |\u00a0       *                        *    *                                \n 29 |\u00a0       *                        *    *              *    *            \n 28 |\u00a0       *                        *    *              *    *            \n 27 |\u00a0  *    *                        *    *              *    *            \n 26 |\u00a0  *    *         *              *    *              *    *            \n 25 |\u00a0  *    *    *    *              *    *              *    *            \n 24 |\u00a0  *    *    *    *              *    *              *    *            \n 23 |\u00a0  *    *    *    *    *         *    *              *    *            \n 22 |\u00a0  *    *    *    *    *         *    *    *         *    *            \n 21 |\u00a0  *    *    *    *    *         *    *    *    *    *    *    *       \n 20 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 19 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 18 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 17 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 16 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 15 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 14 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 13 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 12 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 11 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n 10 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  9 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  8 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  7 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  6 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  5 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  4 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  3 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  2 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n  1 |\u00a0  *    *    *    *    *    *    *    *    *    *    *    *    *    *  \n----+----------------------------------------------------------------------\n    |\u00a0  0    1    2    3    4    5    6    7    8    9   10   11   12   13  \n</code></pre></p> </li> <li> <p>Rufen Sie in der <code>main()</code> die beiden Methoden (oder die, die Sie implememntiert haben) wie folgt auf:     <pre><code>System.out.printf(\"%n%n%n----------- printUpsideDown ------------%n%n%n\");\nprintUpsideDown(arr1);\nSystem.out.printf(\"%n%n%n----------- printVertical --------------%n%n%n\");\nprintVertical(arr1);\n</code></pre></p> </li> <li> <p>Tipps zum L\u00f6sen der Zusatzaufgabe: </p> <ul> <li>Sie m\u00fcssen zun\u00e4chst ermitteln, welcher der gr\u00f6\u00dfte Wert innerhalb des Arrays ist, denn dieser gibt Ihnen die Anzahl der Zeilen im Diagramm vor.</li> <li>Stellen Sie sich das Problem als eine Matrix aus Zeilen und Spalten vor. Die Spalten lassen sich auf den Index des Arrays mappen und die Zeilen auf die Werte im Array. </li> </ul> </li> <li> <p>Viel Spa\u00df und viel Erfolg!</p> </li> </ul> Aufgabe 7 - Arrays bef\u00fcllen <ul> <li> <p>Wir bef\u00fcllen ein <code>char</code>-Array, aber das ist leider gar nicht so einfach ;-)</p> </li> <li> <p>einleitende Vorbetrachtung: angenommen, wir haben die folgende Schleife: </p> <pre><code>for(int asciiValue = 97; asciiValue&lt;123; asciiValue++)\n{\n    char c = (char) asciiValue;\n    System.out.print(c + \" \");\n}\n</code></pre> </li> <li> <p>Durch diese wird uns das gesamte Alphabet in Kleinbuchstaben ausgegeben:</p> <pre><code>a b c d e f g h i j k l m n o p q r s t u v w x y z \n</code></pre> </li> <li> <p>Kopieren Sie die Schleife einfach in Ihre <code>main()</code>-Methode und f\u00fchren Sie sie aus, dann erhalten Sie obige Ausgabe. Dahinter steckt, dass wir der <code>int</code>-Variablen <code>asciiValue</code> den ASCII-Code der Kleinbuchstaben zuweisen (beginnend bei <code>97</code> - das ist ein <code>a</code>). Siehe z.B. hier. Der letzte kleine Buchstabe <code>z</code> hat den ASCII-Wert <code>122</code>, deshalb l\u00e4uft die Schleife auch bis <code>&lt;123</code>. In Zeile <code>3</code> der Schleife findet eine Typkonvertierung statt. Aus dem <code>int</code> wird ein <code>char</code>. Dies geschieht durch den Typkonvertierungsoperator <code>(char)</code>. In Zeile <code>4</code> wird das Zeichen <code>c</code> vom Typ <code>char</code> ausgegeben. </p> </li> <li> <p>Aufgabe Die Aufgabe ist es nun, ein <code>char</code>-Array zu bef\u00fcllen. Es gelten folgende Bedingungen:</p> <ul> <li>das Array hat (nur) die L\u00e4nge <code>25</code></li> <li>in dem Array darf es keine Doppelungen geben (also kein Zeichen darf doppelt enthalten sein)</li> <li>die Zeichen werden zuf\u00e4llig erzeugt, d.h. mithilfe der Klasse <code>Random</code> und der Methode <code>nextInt(bound)</code>, die Werte zwischen <code>97</code> und einschlie\u00dflich <code>122</code> erzeugen soll</li> </ul> </li> <li> <p>Schreiben Sie daf\u00fcr eine Methode <code>public static char[] createAndFillCharArray()</code></p> <ul> <li>in dieser Methode erzeugen Sie das <code>char[]</code>der L\u00e4nge <code>25</code>,</li> <li>ein <code>Random</code>-Objekt, mit dem Sie unter Verwendung der <code>nextInt(bound)</code>-Methode zuf\u00e4llig Zahlen zwischen <code>97</code> und einschlie\u00dflich <code>122</code>erzeugen,</li> <li>die erzeugten <code>int</code>-Werte konvertieren Sie mithilfe des <code>(char)</code>-Typecast-Operators nach <code>char</code>,</li> <li>dann bef\u00fcllen Sie das <code>char[]</code> \u2192 passen Sie aber auf, dass Sie kein Zeichen hinzuf\u00fcgen, das bereits im Array enthalten ist \u2192 dazu ben\u00f6tigen Sie die <code>contains()</code>-Methode:</li> </ul> </li> <li> <p>Schreiben Sie eine Methode <code>public static boolean contains(char[] ca, char c)</code>. Diese gibt ein <code>true</code> zur\u00fcck, wenn <code>c</code> in <code>ca</code> enthalten ist und ein <code>false</code>, wenn nicht.</p> </li> <li> <p>Schreiben Sie eine Methode <code>public static char[] sort(char[] a)</code>. Diese gibt ein <code>char[]</code> zur\u00fcck, welches sortiert ist. Das \u00fcbergebene Array <code>a</code> ist unsortiert. Siehe dazu Sortieren von Arrays.</p> </li> <li> <p>Schreiben Sie eine Methode <code>public static void print(char[] a)</code>, die ein \u00fcbergebenes <code>char[]</code> in der Form</p> <pre><code>[ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ]\n</code></pre> <p>ausgibt. Kennen wir aus \u00dcbung 8, aber gute \u00dcbung, es nochmal zu machen.</p> </li> <li> <p>Geben Sie in Ihre <code>main()</code>-Methode folgende Anweisungen ein:</p> <pre><code>System.out.printf(\"%n%n----------------- Erzeugen ------------------%n%n\");\nchar[] ca1 = createAndFillCharArray();\nprint(ca1);\n\nSystem.out.printf(\"%n%n----------------- Sortieren ------------------%n%n\");        \nchar[] ca2 = sort(ca1);\nprint(ca2); \n</code></pre> <p>Es sollten Ausgaben in der Form:</p> <pre><code>----------------- Erzeugen ------------------\n\n[ o, g, f, p, a, c, s, i, e, q, h, l, t, r, w, z, v, x, y, u, b, j, k, m, n ]\n\n\n----------------- Sortieren ------------------\n\n[ a, b, c, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z ]\n</code></pre> <p>erscheinen. Beachten Sie, dass die Eintr\u00e4ge im Array zuf\u00e4llig erzeugt wurden. Beachten Sie au\u00dferdem, dass ein Buchstabe aus dem Alphabet fehlt, hier z.B. <code>d</code> (das Array hat die L\u00e4nge <code>25</code>, das Alphabet hat <code>26</code> Buchstaben). </p> </li> </ul> <ul> <li>Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional :</li> </ul> <ul> <li> <p>Schreiben Sie eine Methode <code>public static char getMissingLetter(char[] a)</code>. Dieser Methode wird ein durch die obige Methode <code>createAndFillCharArray()</code> erstelltes <code>char</code>-Array \u00fcbergeben. Das Array hat also die L\u00e4nge <code>25</code> hat und aus dem Alphabet fehlt genau ein kleiner Buchstabe. Finden Sie den Buchstaben und geben ihn zur\u00fcck. </p> </li> <li> <p>Schreiben Sie eine Methode <code>public static void findWord(String word)</code>. Dieser Methode wird eine Zeichenkette \u00fcbergeben, die nur aus Buchstaben besteht. Sie k\u00f6nnen annehmen, dass es nur kleine Buchstaben sind, Sie k\u00f6nnen aber erstmal die <code>toLowerCase()</code>-Methode anwenden (siehe String). Rufen Sie f\u00fcr jedes Zeichen aus dem String die beiden Methoden <code>createAndFillCharArray()</code> und <code>getMissingLetter()</code> auf, bis das von der <code>getMissingLetter()</code>-Methode zur\u00fcckgegebene Zeichen dem Zeichen des Strings entspricht, das Sie gerade betrachten. Eine Ausgabe als Beispiel:</p> <pre><code>P..........p (11)\nr.r (2)\no..o (3)\ng............g (13)\nr..............................r (31)\na........a (9)\nm..m (3)\nm...........................................................m (60)\ni....i (5)\ne.....e (6)\nrr (1)\ne......e (7)\nn............n (13)\n</code></pre> <p>Die Ausgabe erfolgte durch den Aufruf von <code>findWord(\"Programmieren\");</code>. Ganz links in der Zeile steht immer das Zeichen des Strings, das gerade betrachtet wird. Dann kommen f\u00fcr jeden fehlgeschlagenen Versuch, durch <code>getMissingLetter()</code> das <code>'p' zur\u00fcck zu bekommen, die Ausgabe eines Punktes. Sollte</code>getMissingLetter()<code>das</code>'p'` zur\u00fcckgeben, wird es ausgegeben und au\u00dferdem noch in Klammern die Anzahl der Versuche. Der Cursor wechselt in die n\u00e4chste Zeile und das n\u00e4chste Zeichen des Strings ist dran. </p> </li> <li> <p>Viel Spa\u00df und viel Erfolg!</p> </li> </ul> Aufgabe 8 - SortedArray <ul> <li> <p>Wir erstellen uns einen neuen Datentyp <code>SortedArray</code></p> </li> <li> <p>Idee: Ein Objekt dieser Klasse beschreibt (enth\u00e4lt) ein <code>int</code>-Array, in dem </p> <ul> <li>die Elemente aufsteigend sortiert sind und </li> <li>kein Element doppelt vorkommt.</li> </ul> <p>Das Array ist stets genau so gro\u00df, so viele Elemente es enth\u00e4lt!</p> </li> <li> <p>Erstellen Sie im package <code>aufgaben.aufgabe7</code> eine Klasse <code>SortedArray</code> ohne <code>main()</code>-Methode und eine Klasse <code>SortedArrayTest</code> mit <code>main()</code>-Methode. </p> </li> <li> <p>In der Klasse <code>SortedArray</code> erstellen Sie eine Objektvariable <code>s</code> vom Typ <code>int[]</code> (<code>private</code>). </p> </li> <li> <p>Implementieren Sie fu\u0308r die Klasse <code>SortedArray</code> zwei verschiedene Konstruktoren</p> <ul> <li>parameterlos \u2192 der Konstruktor erzeugt ein leeres Array <code>s</code> (mit der L\u00e4nge <code>0</code>)</li> <li>mit einem Parameter (<code>int element</code>) \u2192 der Konstruktor erzeugt ein einelementiges Array <code>s</code> (mit der L\u00e4nge <code>1</code>), wobei <code>s[0]</code> den Wert von <code>element</code> annimmt.</li> </ul> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public boolean insert(int element)</code>. Diese Methode gibt ein <code>false</code> zuru\u0308ck, wenn <code>element</code> bereits in <code>s</code> enthalten ist. Dann wird das <code>element</code> nicht dem Array hinzugefu\u0308gt. Die Methode gibt <code>true</code> zuru\u0308ck, wenn <code>element</code> in <code>s</code> eingefu\u0308gt wurde. Um <code>element</code> einzufu\u0308gen, wird ein neues Array fu\u0308r <code>s</code> erzeugt, in dem alle vorherigen Werte aus <code>s</code> und das neue <code>element</code> (an der richtigen Stelle einsortiert) enthalten sind.</p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public boolean delete(int element)</code>. Diese Methode gibt ein <code>false</code> zuru\u0308ck, wenn <code>element</code> nicht in <code>s</code> enthalten ist. Die Methode gibt <code>true</code> zuru\u0308ck, wenn <code>element</code> aus <code>s</code> gel\u00f6scht wurde. Beachten Sie, dass nach L\u00f6schen aus <code>s</code> die L\u00e4nge von <code>s</code> um eins kleiner ist, als vor dem L\u00f6schen. Es muss also auch hier wieder ein neues Array erzeugt werden, welches nach dem L\u00f6schen dem \"Wert\" von <code>s</code> entspricht. </p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void print()</code>, die das Array <code>s</code> in der Form <code>[ 4, 5, 9 ]</code> (Beispielwerte) ausgibt. </p> </li> <li> <p>Tipp: </p> <ul> <li>Um zu \u00fcberpr\u00fcfen, ob ein <code>int element</code> in <code>s</code> enthalten ist, sollten Sie sich eine Methode <code>boolean contains(int element)</code> schreiben (diese kann <code>private</code> sein, wenn sie nur innerhalb der Klasse verwendet werden soll; sogenannte  Servicemethode). </li> <li>Angenommen, Sie haben zwei Arrays: <code>s = [ 4, 9 ]</code> und <code>copy = [ 4, 5, 9]</code>, dann gilt nach <code>s = copy;</code>, dass <code>s == [ 4, 5, 9 ]</code>. </li> </ul> </li> <li> <p>Geben Sie in die <code>main()</code>-Methode der <code>SortedArrayTest</code>-Klasse mindestens folgende Anweisungen ein:     <pre><code>System.out.printf(\"%n%n------------------------- Test a1 -----------------------------------%n%n\");\nSortedArray a1 = new SortedArray();\na1.print();\na1.delete(5);       a1.print();\na1.insert(5);       a1.print();\na1.insert(7);       a1.print();\na1.delete(5);       a1.print();\na1.insert(6);       a1.print();\na1.insert(4);       a1.print();\na1.insert(8);       a1.print();\na1.delete(8);       a1.print();\na1.delete(6);       a1.print();\n\nSystem.out.printf(\"%n%n------------------------- Test a2 -----------------------------------%n%n\");\nSortedArray a2 = new SortedArray(9);\na2.print();\na2.insert(5);       a2.print();\na2.insert(9);       a2.print();\na2.insert(5);       a2.print();\na2.insert(4);       a2.print();\na2.insert(4);       a2.print();\na2.delete(5);       a2.print();\na2.delete(9);       a2.print();\na2.delete(4);       a2.print();\na2.delete(4);       a2.print(); \n</code></pre>     und f\u00fchren Sie die <code>SortedArrayTest</code>-Klasse aus. Es sollten folgende Augaben entstehen:     <pre><code>------------------------- Test a1 -----------------------------------\n\n[\u00a0]\n[\u00a0]\n[ 5 ]\n[ 5, 7 ]\n[ 7 ]\n[ 6, 7 ]\n[ 4, 6, 7 ]\n[ 4, 6, 7, 8 ]\n[ 4, 6, 7 ]\n[ 4, 7 ]\n\n\n------------------------- Test a2 -----------------------------------\n\n[ 9 ]\n[ 5, 9 ]\n[ 5, 9 ]\n[ 5, 9 ]\n[ 4, 5, 9 ]\n[ 4, 5, 9 ]\n[ 4, 9 ]\n[ 4 ]\n[\u00a0]\n[\u00a0]\n</code></pre></p> </li> <li>Viel Spa\u00df und viel Erfolg!</li> </ul>"},{"location":"ausdruecke/","title":"Operatoren und Ausdr\u00fccke","text":"<p>Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen. </p>"},{"location":"ausdruecke/#arithmetische-operatoren","title":"Arithmetische Operatoren","text":"<p>Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition <code>+</code>, die Subtraktion <code>-</code>, die Multiplikation <code>*</code> und die Division <code>/</code>. Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt (<code>%</code>). </p> <p>Ganz wichtig ist, dass das Divisionssymbol <code>/</code> eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. <code>5 / 4</code> ergibt <code>1</code>), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. <code>5.0 / 4.0</code> ergibt <code>1.25</code>). </p> <p>Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. <code>7 % 4</code> ergibt <code>3</code> - der verbleibende Rest der ganzzahligen Divsion ist <code>3</code>). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt <code>7.0 % 4.0</code> auch <code>3.0</code> und/aber <code>7.5 % 4.0</code>  ergibt <code>3.5</code>.  </p>  Operatorsymbol(e)  Bedeutung    Beispiel    Un\u00e4re Operatoren <code>+</code>                  Wird als Vorzeichen vor ganzen Zahlen (z.B. <code>+5</code>) oder vor Gleikommazahlen (z.B. <code>+5.5</code>) verwendet. <code>+</code> \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich.               <code>int x = -5;</code> <code>x = +x; </code> Wert von <code>x</code> ist <code>-5</code> <code>-</code>                  Wird als Vorzeichen vor ganzen Zahlen (z.B. <code>-5</code>) oder vor Gleikommazahlen (z.B. <code>-5.5</code>) verwendet. <code>-x</code> dreht das Vorzeichen von <code>x</code> um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich.               <code>int x = -5;</code> <code>x = -x;</code> Wert von <code>x</code> ist <code>+5</code> <code>double y = -5.5;</code> <code>y = -y;</code> Wert von <code>y</code> ist <code>+5.5</code> Bin\u00e4re Operatoren <code>+</code>                  Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich.              <code>int x = -5 + 6;</code>  Wert von <code>x: +1</code> <code>double y = -5.5 + 6.5;</code>  Wert von <code>y: +1.0</code> <code>-</code>                  Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich.              <code>int x = -5 - 6;</code>  Wert von <code>x</code> ist <code>-11</code> <code>double y = -5.5 - 6.5;</code>  Wert von <code>y: -12.0</code> <code>*</code>                  Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich.              <code>int x = -5 * 6;</code>  Wert von <code>x: -30</code> <code>double y = -5.0 * 6.0;</code>  Wert von <code>y: -30.0</code> <code>/</code>                  Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division!               <code>int x = 5 / 4;</code>  Wert von <code>x: +1</code> <code>double y = 5.0 / 4.0;</code>  Wert von <code>y: +1.25</code> <code>%</code>                  Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen.              <code>int x = 7 % 4;</code>  Wert von <code>x</code> ist <code>3</code> <code>double y = 6.5 % 5.0;</code>  Wert von <code>y</code> ist <code>1.5</code>"},{"location":"ausdruecke/#pra-und-postfix-operatoren","title":"Pr\u00e4- und Postfix-Operatoren","text":"<p>Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. </p> <p>Angenommen, wir haben eine Variable <code>int x = 5;</code>. Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um <code>1</code> erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: <code>++</code>. Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden <code>1</code>. Er kann sowohl als Pr\u00e4fix-Operator (<code>++x</code>) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix-Inkrement-Operatoren.</p> <pre><code>int x = 5;\nSystem.out.println(x++);        // 5\nSystem.out.println(x);          // 6\nSystem.out.println(++x);        // 7\nSystem.out.println(x);          // 7\n</code></pre> <p>Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. <code>x</code> hat nach der Initialisierung den Wert <code>5</code>. In Zeile <code>2</code> geben wir den Wert aus und erh\u00f6hen <code>x</code> danach um <code>1</code>. Ausgegeben wird also der Wert <code>5</code>, aber nach der Ausgabe ist der Wert um <code>1</code> erh\u00f6ht auf <code>6</code> (siehe Zeile <code>3</code>). Bei dem Prefix-Operator (Zeile <code>4</code>) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert <code>7</code> ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung <code>x = x + 1;</code>.</p> <p>Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus <code>1</code>. Dies wird mit dem Prefix-Operator <code>--x;</code> sowie mit dem Postfix-Operator <code>x--;</code> erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix-Dekrement-Operatoren.</p>"},{"location":"ausdruecke/#verkurzte-schreibweisen-fur-arithmetische-operatoren","title":"Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren","text":"<p>Aus dieser Verwendung haben sich weitere Schreibweisen etabliert:</p>  Operatoren (Beispiele)   Bedeutung   <code> x+=7; </code> <code> x = x + 7; </code> <code> x-=7; </code> <code> x = x - 7; </code> <code> x*=7; </code> <code> x = x * 7; </code> <code> x/=7; </code> <code> x = x / 7; </code> <code> x%=7; </code> <code> x = x % 7; </code>"},{"location":"ausdruecke/#vergleichsoperatoren","title":"Vergleichsoperatoren","text":"<p>Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp (<code>int</code> oder <code>double</code>). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein <code>boolean</code>, das hei\u00dft, der Vergleich resultiert in einem Wert <code>true</code> oder in einem Wert <code>false</code>. </p>  Vergleichsoperator   Beispiel     Bedeutung   <code> == </code> <code> x == y </code>  Vergleich auf Gleichheit. Ergibt <code>true</code>, wenn <code>x</code> den gleichen Wert hat wie <code>y</code>, sonst <code>false</code> <code> &lt; </code> <code> x &lt; y </code>  Kleiner als. Ergibt <code>true</code>, wenn <code>x</code> einen echt kleineren Wert hat als <code>y</code>, sonst <code>false</code> <code> &gt; </code> <code> x &gt; y </code>  Gr\u00f6\u00dfer als. Ergibt <code>true</code>, wenn <code>x</code> einen echt gr\u00f6\u00dferen Wert hat als <code>y</code>, sonst <code>false</code> <code> &lt;= </code> <code> x &lt;= y </code>  Kleiner gleich. Ergibt <code>true</code>, wenn <code>x</code> einen kleineren als oder den gleichen Wert wie <code>y</code> hat, sonst <code>false</code> <code> &gt;= </code> <code> x &gt;= y </code>  Gr\u00f6\u00dfer gleich. Ergibt <code>true</code>, wenn <code>x</code> einen gr\u00f6\u00dferen als oder den gleichen Wert wie <code>y</code> hat, sonst <code>false</code> <code> != </code> <code> x != y </code>  Ungleich. Ergibt <code>true</code>, wenn <code>x</code> einen anderen  Wert hat als <code>y</code>, sonst <code>false</code>"},{"location":"ausdruecke/#wertzuweisungsoperator","title":"Wertzuweisungsoperator","text":"<p>Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator <code>=</code>. Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. <code>int x = 5 + 6;</code>. Dann wird <code>x</code>der Wert <code>11</code>zugeweisen. </p> <p>Beachte</p> <p>Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form <code>x = x+1;</code> sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol <code>=</code> f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung <code>x = x+1;</code> wird also erst der Wert <code>x+1</code> berechnet und dieser Wert dann der Variablen <code>x</code> zugeordnet (die dann einen um <code>1</code> h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens <code>==</code>, wie wir gleich sehen werden.</p>"},{"location":"ausdruecke/#logische-operatoren","title":"Logische Operatoren","text":"<p>Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ <code>boolean</code> angewendet werden.</p> <p>Nehmen wir in der folgenden Tabelle an, dass die Variablen <code>a</code> und <code>b</code> jeweils vom Typ <code>boolean</code> sind. Sie wurden also wie folgt deklariert: <code>boolean a;</code> und <code>boolean b;</code>.</p>  Logischer Operator   Beispiel     Bedeutung   <code> &amp;&amp; </code> <code> a &amp;&amp; b </code>  UND-Operator. Ergibt <code>true</code>, wenn <code>a</code> den Wert <code>true</code> hat UND <code>b</code> auch den Wert <code>true</code>, sonst <code>false</code> <code> || </code> <code> a || b </code>  ODER-Operator. Ergibt <code>true</code>, wenn <code>a</code> den Wert <code>true</code> hat ODER <code>b</code> den Wert <code>true</code> (oder beide), sonst <code>false</code> <code> ^ </code> <code> a ^ b </code>  EXCLUSIVES ODER. Ergibt <code>true</code>, wenn ENTWEDER <code>a</code> den Wert <code>true</code> hat ODER <code>b</code> den Wert <code>true</code> (aber NICHT beide), sonst <code>false</code> <code> ! </code> <code> !a </code>  NEGATION (un\u00e4rer Operator). Ergibt <code>true</code>, wenn <code>a</code> den Wert <code>false</code> hat, ergibt <code>false</code>, wenn <code>a</code> den Wert <code>true</code> hat <p>Es sein angemerkt, dass es f\u00fcr die Operatoren <code>&amp;&amp;</code> und <code>||</code> jeweils auch die Operatoren <code>&amp;</code> und <code>|</code> gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt:</p> <pre><code>false &amp;&amp; a      // a wird nicht mehr gepr\u00fcft, Ausdruck ist false\nfalse &amp; a       // a wird gepr\u00fcft, Ausdruck ist false\ntrue ||\u00a0b       // b wird nicht mehr gepr\u00fcft, Ausdruck ist true\ntrue |\u00a0b        // b wird gepr\u00fcft, Ausdruck ist true\n</code></pre> <p>Ist beim logischen UND bereits der erste Operand <code>false</code>, dann kann das Ergebnis nicht mehr <code>true</code> sein, sondern ist <code>false</code>. Egal, welchen Wert der zweite Operand hat. Bei dem Operator <code>&amp;&amp;</code> wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator <code>&amp;</code> aber doch. <code>&amp;&amp;</code> ist somit effizienter.</p> <p>Ist beim logischen ODER bereits der erste Operand <code>true</code>, dann ist das Ergebnis bereits <code>true</code>, egal, welchen Wert der zweite Operand hat. Bei dem Operator <code>||</code> wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator <code>|</code> aber doch. <code>||</code> ist somit effizienter. Wir verwenden deshalb immer <code>&amp;&amp;</code> und <code>||</code> anstatt <code>&amp;</code> und <code>|</code>.</p>"},{"location":"ausdruecke/#wahrheitstabellen","title":"Wahrheitstabellen","text":"<p>Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen <code>a</code> und <code>b</code> jeweils vom Typ <code>boolean</code> sind.</p> <code>a</code> <code>b</code> <code>a &amp;&amp; b</code> <code>a || b</code> <code>a ^ b</code> <code>!a</code> <code>true</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <code>true</code> \u00dcbung Exclusives Oder <p>Angenommen, es g\u00e4be den Operator <code>^</code> f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren <code>&amp;&amp;</code>, <code>||</code> und <code>!</code>. Wie k\u00f6nnen Sie mit <code>&amp;&amp;</code>, <code>||</code> und <code>!</code> das exclusive Oder \"nachbauen\"?</p>"},{"location":"ausdruecke/#ausdrucke-und-anweisungen","title":"Ausdr\u00fccke und Anweisungen","text":"<p>Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke. Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale. </p>"},{"location":"ausdruecke/#literale","title":"Literale","text":"<p>Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. </p> <ul> <li>ganze Zahlen (z.B. <code>123</code> oder <code>-123</code>),</li> <li>Gleikommazahlen (z.B <code>5.5</code> oder <code>-6.0</code>),</li> <li>Wahrheitswerte (<code>true</code> oder <code>false</code>),</li> <li>ein Character (z.B. <code>'a'</code> oder <code>'A'</code>)</li> </ul> <p>Wir werden sp\u00e4ter noch andere Literale kennenlernen:</p> <ul> <li>Zeichenketten (Datentyp <code>String</code>), z.B. <code>\"Hallo FIW!\"</code></li> <li>die leere Referenz <code>null</code></li> </ul> <p>Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler):</p> <pre><code>int x = 123;    // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; \n                // der Wert des Ausdrucks wird der Wert der Variablen x\nx++;            // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung\n\nx++             // der Ausdruck selbst kann so nicht stehen (Compilerfehler)\n                // da steht nur ein Wert mit dem nichts gemacht wird\n\n5 + 6           // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen\n\n5 + 6;          // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung)\n                // keine g\u00fcltige Ausdrucksanweisung\n</code></pre> <p>Ausdr\u00fccke sind</p> <ul> <li>Literale</li> <li>Literale, die mit (passenden) Operatoren verkn\u00fcpft sind</li> <li>Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind</li> </ul>"},{"location":"ausdruecke/#ausdrucke-mit-operatoren","title":"Ausdr\u00fccke mit Operatoren","text":"<p>Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke</p> <ul> <li>immer einen Wert haben,</li> <li>der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge:<ul> <li>wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, </li> <li>un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet,</li> <li>bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\",</li> <li>bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) <code>==</code>, <code>!=</code> -&gt; <code>&amp;</code> \u2192 <code>^</code> \u2192 <code>|</code> \u2192 <code>&amp;&amp;</code> \u2192 <code>||</code> (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!)</li> <li>der Zuweisungsoperator (<code>=</code>) sowie <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code>, <code>%=</code> binden am schw\u00e4chsten</li> <li>dann erfolgt die Aufl\u00f6sung von links nach rechts</li> </ul> </li> </ul> <p>Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. <code>3 == 4</code> ist vom Typ <code>boolean</code>, aber <code>3</code> und <code>4</code> sind jeweils vom Typ <code>int</code>.</p> <p>Beispiele f\u00fcr Ausdr\u00fccke sind:</p> <pre><code>5 + 6 - 8           // Ergebnis (Wert) ist ein int\ntrue &amp;&amp; false       // Ergebnis (Wert) ist ein boolean\n5 &lt; 6               // Ergebnis (Wert) ist ein boolean\n7 &gt;= 7              // Ergebnis (Wert) ist ein boolean\n6 == 6              // Ergebnis (Wert) ist ein boolean\n6 != 6              // Ergebnis (Wert) ist ein boolean\n5.5 * 2.0           // Ergebnis (Wert) ist ein double\n7.0 / 4.0           // Ergebnis (Wert) ist ein double\n(7.0 / 4.0 ) &gt; 1.0  // Ergebnis (Wert) ist ein boolean\n</code></pre> \u00dcbung Ausdruck <p>Angenommen, <code>a</code>, <code>b</code> und <code>c</code> seien vom Typ <code>int</code>. Was ist an diesem Ausdruck falsch: <code>a &lt; b &lt; c</code>? Wie w\u00e4re es richtig?</p> \u00dcbung Durchschnitt berechnen <p>Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: <code>1</code>, <code>1</code>, <code>1</code>, <code>1</code>, <code>2</code>, <code>2</code>, <code>3</code>, <code>4</code>. Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: <pre><code>int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4;\nint anzahl = 8;\nSystem.out.println(summe/anzahl);\n</code></pre> Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser?</p> <p>Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele:</p> <pre><code>int x = 0;              // Wert von x ist 0\nx = 7 + 4 / 2;          // Wert von x ist 9\nint y = 7 % 4;          // Wert von y ist 3\nx = y++;                // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4\nx = y;                  // Wert von x ist 4\n\nboolean a = (7 &gt; 4);    // Wert von a ist true\na = !a;                 // Wert von a ist false\na = (a ||\u00a0true);        // Wert von a ist true\na = !!a &amp;&amp; true;        // Wert von a ist true\n</code></pre> <p>Beachte</p> <p>Generell gilt bei der Zuweisung immer, dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme. Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: <pre><code>int x = 3;      // x hat den Wert 3\nint y = x++;    // y hat den Wert 3 und x den Wert 4\nint a = 3;      // a hat den Wert 3\nint b = a--;    // b hat den Wert 3 und a den Wert 2\n</code></pre> Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: <pre><code>int x = 3;      // x hat den Wert 3\nint y = ++x;    // y hat den Wert 4 und x den Wert 4\nint a = 3;      // a hat den Wert 3\nint b = --a;    // b hat den Wert 2 und a den Wert 2\n</code></pre></p>"},{"location":"cleancode/","title":"Clean Code","text":""},{"location":"cleancode/#sinnvoller-umgang-mit-kommentaren","title":"Sinnvoller Umgang mit Kommentaren","text":"<p>Wirklich sinnvoll sind nur JavaDoc-Kommentare. Andere Kommentare sollten, wenn \u00fcberhaupt, sehr sparsam verwendet werden. </p> <p>Erl\u00e4utern Sie nicht  </p> <ul> <li>die Bedeutung einer Variablen bei der Deklaration. Das sollte durch den Namen klar sein. </li> <li>die Bedeutung einer Bedingung. Spendieren Sie besser eine eigene Methode f\u00fcr diese Bedingung und geben Sie dieser Methode einen entsprechenden Namen. </li> <li>die Bedeutung einer <code>for</code>-Schleife. Geben Sie stattdessen der Laufvariablen einen entsprechenden Namen. </li> <li>die Bedeutung von magic numbers. Deklarieren Sie stattdessen Konstanten mit sprechenden Namen. </li> <li>die Bedeutung verschachtelter Schleifen. Lagern Sie innere Schleifen besser in eigene Methoden aus und geben Sie den Methoden sprechende Namen. </li> </ul> <p>Generell wird h\u00e4ufig versucht, \"schlechte\" Programmierung durch Kommentare zu \"verbessern\". Ein Problem bei Kommentaren besteht darin, dass sie ebenfalls ge\u00e4ndert werden m\u00fcssen, wenn der Code ge\u00e4ndert wird. Au\u00dferdem k\u00f6nnen Kommentare einfach falsche Informationen enthalten, n\u00e4mlich dann, wenn darin Gedanken formuliert sind, die gar nicht bis zu Ende gedacht wurden. </p>"},{"location":"cleancode/#bezeichner","title":"Bezeichner","text":"<ul> <li>Variablennamen sollten nicht den Typ der Variable enthalten. Das ist unn\u00f6tig. </li> <li>Klassennamen sollten Substantive sein.</li> <li>Methodennamen sollten Verben enthalten.</li> <li>Ein typischer Fehler bei Bezeichnern ist, sie zu kurz zu w\u00e4hlen. Daf\u00fcr gibt es keinen Grund! <code>calculateMeanValueOfAges()</code> ist besser als <code>calc</code>. Typisch ist es auch, Laufvariablen in <code>for</code>-Schleifen die Bezeichner <code>i</code> und <code>j</code> usw. geben. Besser sind sprechende Namen, wie z.B. <code>row</code> und <code>column</code>. </li> </ul>"},{"location":"cleancode/#methoden","title":"Methoden","text":"<ul> <li>Methoden sollten genau eine Funktion ausf\u00fchren. </li> <li>Komplexere Bedingungen (mit logischen Operatoren verkn\u00fcpfte Ausdr\u00fccke) sollten in eigene Methoden ausgelagert werden, um ihnen einen sprechenden Namen zu geben.</li> <li>Die Parameter sollten zu den Methoden passen, z.B. ist <code>write(String)</code> verst\u00e4ndlich, aber <code>write(boolean</code> nicht. </li> <li>Methoden sollten so (kurz und knapp) geschrieben werden, dass sie wiederverwendet werden k\u00f6nnen. </li> <li>Daten sollten m\u00f6glichst nicht \"hartcodiert\" sein, z.B.: </li> </ul> schlechtbesser <pre><code>String getCapital(String country) {\n    String capital = switch(country) {\n        case \"Italien\" -&gt; \"Rom\"; \n        case \"Portugal\" -&gt; \"Lissabon\";\n        case \"Spanien\" -&gt; \"Madrid\";\n        default -&gt; \"\";\n    };\n    return capital;\n}\n</code></pre> <pre><code>Map&lt;String, String&gt; capitals = Map.ofEntries(\n    entry(\"Italien\",\"Rom\"),\n    entry(\"Portugal\",\"Lissabon\"),\n    entry(\"Spanien\", \"Madrid\")\n);\n\nString getCapital(String country) {\n    String capital = \"\";\n    capital = this.capitals.get(country);\n    return capital;\n}\n</code></pre>"},{"location":"cleancode/#solid-design-prinzipien","title":"SOLID Design Prinzipien","text":"<p>Nachdem Robert C. Martin Design-Prinzipien f\u00fcr die Softwareentwicklung zusammengetragen hatte (Clean Code Literatur), wurden diese unter dem Akronym SOLID zusammengefasst. SOLID steht f\u00fcr die Prinzipien:</p> <ul> <li>Single Responsibility Principle (RSP)</li> <li>Open Closed Principle</li> <li>Liskov Substitution Principle (LSP)</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion Principle</li> </ul>"},{"location":"cleancode/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Diese Prinzip wird heute auch h\u00e4ufiger f\u00fcr Methoden verwendet, es bezieht sich aber auf Klassen. Im Original hat Robert C. Marting dieses Prinzip so erkl\u00e4rt: </p> <p>A class should have only one reason to change</p> <p>Man kann es sich auch so merken, dass man in einer Klasse alle die Eigenschaften definieren soll, die aus einem Grund ge\u00e4ndert werden k\u00f6nnen. Eigenschaften, die aus anderen Gr\u00fcnden ge\u00e4ndert werden k\u00f6nnen, sollten in anderen Klassen definiert werden. </p> <p>Ein typischer Fall f\u00fcr die Missachtung des SRP besteht z.B. darin, wenn ein Spiel programmiert wird und in derselben Klasse auch die GUI f\u00fcr dieses Spiel. Generell sollte stets die Datenverwaltung (Model) von den Interaktionen (Controller) und der Darstellung (View) getrennt werden. Daf\u00fcr hat sich z.B. das Design-Pattern Model-View-Controller etabliert. </p>"},{"location":"functional/","title":"Funktionale Programmierung","text":"<p>Angenommen, wir haben eine Liste aus Zahlen (<code>Integer</code>) und wollen jede einzelne Zahl aus dieser Liste auf die Konsole ausgeben. Unser bisheriger Ansatz sieht ungef\u00e4hr so aus:</p> bisher <pre><code>static void printAllNumbersInList(List&lt;Integer&gt; numbers)\n{\n    for(int number : numbers) {\n        System.out.println(number);\n    }\n}\n</code></pre> <p>Nun betrachten wir eine andere Methode und nutzen dazu das Interface Stream:</p> funktional mit Streams <pre><code>static void printAllNumbersInListFunctional(List&lt;Integer&gt; numbers)\n{\n    numbers.stream().forEach(System.out::println);\n}\n</code></pre> <p>Mehrere Sachen sind neu:</p> <ol> <li> Aufruf der Methode <code>stream()</code> f\u00fcr die <code>Collection</code>. <code>numbers</code> ist vom Typ <code>List</code>. <code>List</code> ist ein Interface, das vom Interface <code>Collection</code> erbt. Die Methode <code>stream()</code> gibt einen <code>Stream</code> zur\u00fcck. </li> <li> Ein <code>Stream</code> ist ein sogenannter Spliterator und vereinigt zwei Konzepte:      <ol> <li> Ein <code>Spliterator</code> ist einerseits ein <code>Iterator</code> und erm\u00f6glicht elementweisen Zugriff (<code>hasNext()</code> und <code>next</code> --&gt; siehe <code>forEach()</code>) </li> <li> 2.b und es kann den Stream in verschiedene Teile splitten (siehe z.B. <code>filter()</code>). </li> </ol></li> <li> Die Methode <code>println</code> wird anders aufgerufen.      <ol> <li> Es fehlen einerseits die Klammern <code>(</code> und <code>)</code> beim Aufruf.</li> <li> Anderseits wird die Methode nicht \u00fcber die Punktschreibweise, sondern mit der neuen Syntax <code>::</code> aufgerufen. Dabei handelt es sich um eine sogenannte Methodenreferenz. Tats\u00e4chlich handelt es sich gar nicht um den Aufruf der Methode, aber dazu kommen wir sp\u00e4ter genauer. </li> </ol></li> </ol> <p>Sie k\u00f6nnen sich den obigen Code wie folgt erkl\u00e4ren: Die Liste wird in einen Stream umgewandelt. Mithilfe von <code>forEach()</code> wird jedes einzelne Element aus der Liste betrachtet und an die <code>println()</code>-Methode gesendet. Diese gibt jedes einzelne Element auf die Konsole aus. </p>"},{"location":"functional/#lambda-ausdrucke","title":"Lambda-Ausdr\u00fccke","text":"<p>Im obigen Beispiel haben wir <code>println</code> \u00fcber die Methodenreferenz \"aufgerufen\". Diese Methode erwartet keinen Parameter. Wir erweitern unser Beispiel zun\u00e4chst und wollen nur die geraden Zahlen aus der <code>numbers</code>-Liste ausgeben lassen. Dazu schreiben wir uns zun\u00e4chst folgende Methode:</p> gerade Zahl <pre><code>static boolean isEven(int number)\n{\n    return number%2 == 0;\n}\n</code></pre> <p>Mithilfe dieser Methode filtern wir nun zun\u00e4chst den Stream (wir splitten den Stream in gerade und ungerade Zahlen und lassen nur die geraden Zahlen \"durch\"). Dazu nutzen wir die Methode <code>filter()</code> (siehe Klasse Stream):</p> Stream filtern <pre><code>static void printAllEvenNumbersInListFunctional(List&lt;Integer&gt; numbers)\n{\n    numbers.stream()\n        .filter(Functional01::isEven)\n        .forEach(System.out::println);\n}\n</code></pre> <p>Als Parameter \u00fcbergeben wir der <code>filter()</code>-Methode die Methodenreferenz <code>isEven</code> (siehe oben) - diese haben wir in der Klasse <code>Functional01</code> implementiert. Diese Methode erwartet einen Parameter und \"irgendwie\" werden jetzt die einzelnen Zahlen aus dem Stream an die <code>isEven()</code>-Methode \u00fcbergeben. Das darumterliegende Prinzip schauen wir uns nun genauer an und verwenden daf\u00fcr einen sogannten Lambda-Ausdruck. </p> <p>Ein Lambda-Ausdruck mit einem Parameter hat die Form: <code>parameter -&gt; expression</code> Ein Lambda-Ausdruck mit mehreren Parametern hat die Form: <code>(parameter1, parameter2) -&gt; expression</code></p> <p>In obiger Form gibt die <code>expression</code> implizit einen Wert zur\u00fcck (typischer Weise ein <code>boolean</code>, je nach Ausdruck). F\u00fcr komplexere Ausf\u00fchrungen kann auch ein Anweisungsblock definiert werden. Wenn aus diesem Anweisungsblock ein Wert zur\u00fcckgegeben werden soll, muss darin explizit ein <code>return</code> angegeben werden:</p> <p>Ein Lambda-Ausdruck mit komplexerem Code: <code>(parameter1, parameter2) -&gt; { code }</code> </p> <p>Wir ersetzen nun die Methodenreferenz auf <code>isEven</code> in <code>filter()</code> und geben stattdessen direkt einen Lambda-Ausdruck an:</p> Lambda-Ausdruck in filter() <pre><code>static void printAllEvenNumbersInListFunctional(List&lt;Integer&gt; numbers)\n{\n    numbers.stream()\n        .filter( number -&gt; number%2 == 0 ) // Lambda-Ausdruck\n        .forEach(System.out::println);\n}\n</code></pre> <p>Den Parameter haben wir hier <code>number</code> genannt. Wir k\u00f6nnen ihn im Ausdruck frei w\u00e4hlen und m\u00fcssen ihn nicht deklarieren. H\u00e4tten wir ihn z.B. <code>n</code> genannt, s\u00e4he der Lambda-Ausdruck so aus: <code>n -&gt; n%2 == 0</code> und w\u00fcrde genauso funktionieren. </p>"},{"location":"functional/#map","title":"<code>map()</code>","text":"<p>Wir kennen bereits 2 Methoden \u00fcber Stream: <code>forEch()</code> und <code>filter()</code>. Nun betrachten wir eine weitere Methode: <code>map()</code>. Mithilfe von <code>map()</code> k\u00f6nnen wir jedes Element eines Streams manipulieren, z.B. jedes Element quadrieren:</p> map() <pre><code>static void printSquaresOfAllEvenNumbersInListFunctional(List&lt;Integer&gt; numbers)\n{\n    numbers.stream()\n        .filter( number -&gt; number%2 == 0 )\n        .map(number -&gt; number * number)\n        .forEach(System.out::println);\n}\n</code></pre> <p><code>map()</code> gibt, genau wie <code>filter()</code>, einen <code>Stream</code> zur\u00fcck. <code>forEch()</code> hat als R\u00fcckgabetyp jedoch <code>void</code>! <code>map()</code> erwartet als Parameter eine Function, d.h. entweder ein Lambda-Audruck oder eine Methodenreferenz. <code>filter()</code> erwartet als Parameter ein Predicate. Ein <code>Predicate</code> ist eine <code>Function</code>, die ein <code>boolean</code> zur\u00fcckgibt. <code>forEach()</code> erwartet als Parameter einen Consumer. Das ist eine <code>Function</code> deren R\u00fcckgabetyp <code>void</code> ist. </p>"},{"location":"hilfsklassen/","title":"N\u00fctzliche Klassen","text":"<p>In Java gibt es eine Vielzahl bereits existierender Klassen, auf die wir zugreifen k\u00f6nnen. Wir werden nach und nach einige davon kennenlernen - aber l\u00e4ngst nicht alle. Bis jetzt haben wir nur zwei Klassen direkt verwendet:</p> <ul> <li>die Klasse <code>System</code>, die uns eine Schnittstelle zu unserer Konsole (dem Standardausgabeger\u00e4t zur Verf\u00fcgung stellt - z.B. <code>System.out.println()</code>) und </li> <li>die Klasse <code>String</code>, die einen Datentyp f\u00fcr Zeichenketten darstellt und daf\u00fcr auch n\u00fctzliche Methoden mitbringt, die wir uns hier mal genauer anschauen wollen.</li> </ul> <p>Beide Klassen geh\u00f6ren zum Paket <code>java.lang</code>. Dieses Paket muss nicht importiert werden, umn die Klassen daraus zu nutzen. Bei anderen Klassen, die wir im Folgenden betrachten, ist das teilweise anders.</p>"},{"location":"hilfsklassen/#die-klasse-scanner","title":"Die Klasse <code>Scanner</code>","text":"<p>Wir k\u00f6nnen derzeit Ausgaben auf die Konsole schreiben. Wir k\u00f6nnen jedoch noch keine Eingaben t\u00e4tigen. Das wird sich mit der Verwendung der Klasse <code>Scanner</code> nun \u00e4ndern. </p> <p>Die Verwendung dieser Klasse durch uns erfolgt durch </p> <ol> <li>die Erzeugung eines <code>Scanner</code>-Objektes </li> <li>den Aufruf einer passenden Objektmethode, je nachdem, was wir einlesen wollen, ein <code>int</code>, ein <code>double</code> oder einen <code>String</code>.</li> </ol>"},{"location":"hilfsklassen/#erzeugen-eines-scanner-objektes","title":"Erzeugen eines <code>Scanner</code>-Objektes","text":"<p>Wir haben oben zwei begriffe verwendet, deren Bedeutung wir erst sp\u00e4ter kennenlernen: Objekt und Objektmethode. Das soll uns aber nicht aufhalten, einfach einmal ein <code>Scanner</code>-Objekt zu erzeugen:</p> <pre><code>Scanner sc = new Scanner(System.in);\n</code></pre> <p>Hierbei passiert folgendes:</p> <ul> <li>wir deklarieren uns eine Variable <code>sc</code> vom Datentyp <code>Scanner</code>,</li> <li>wir erzeugen mithilfe von <code>new Scanner()</code> ein neues Objekt vom Datentyp <code>Scanner</code>,  </li> <li>wir \u00fcbergeben der Methode, die ein <code>Scanner</code>-Objekt erzeugt unser Standardeingabeger\u00e4t (<code>System.in</code>) - das ist die Konsole, d.h. wir wollen unsere Daten \u00fcber die Konsole einlesen</li> <li>wir weisen unser neues Objekt (genauer gesagt: eine Referenz auf unser neues Objekt) der Variablen <code>sc</code> zu</li> </ul> <p>Wenn Sie obige Anweisung z.B. in Ihre <code>main()</code>-Methode einf\u00fcgen, dann stellen Sie fest, dass beide <code>Scanner</code> rot unterstrichen sind. Die Fehlerausgabe ist <code>Scanner cannot be resolved to a type</code>. Das liegt daran, dass die Klasse <code>Scanner</code> nicht zum Standardpaket <code>java.lang</code> geh\u00f6rt, sondern wir sie erst importieren m\u00fcssen. Das lassen wir aber von unserer IDE erledigen. Wir w\u00e4hlen eines der vorgeschlagenen <code>quick fixes</code> aus, und zwar <code>import Scanner (java.util)</code>. Achten Sie darauf, dass dies nicht der erste Vorschlag f\u00fcr ein <code>quick fix</code> ist! Nachdem die entsprechende <code>import</code>-Anweisung (<code>import java.util.Scanner;</code>) eingef\u00fcgt wurde, ist die Fehlermeldung behoben. Das Programm k\u00f6nnte also so aussehen:</p> <pre><code>package themen.hilfsklassen;\n\nimport java.util.Scanner;\n\npublic class Hilfsklassen\n{\n\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n    }\n\n}\n</code></pre> <p>Die <code>import</code>-Anweisung (Zeile <code>3</code>) erfolgt au\u00dferhalb und vor der Klassendeklaration. </p>"},{"location":"hilfsklassen/#aufrufen-der-passenden-objektmethoden","title":"Aufrufen der passenden Objektmethoden","text":"<p>F\u00fcr ein solches Objekt vom Typ <code>Scanner</code> stehen eine Vielzahl von Methoden zur Verf\u00fcgung, von denen wir uns nur die folgenden anschauen wollen:</p> <ul> <li><code>next()</code>: liest einen <code>String</code> ein</li> <li><code>nextInt()</code>: liest ein <code>int</code> ein</li> <li><code>nextDouble()</code>: liest ein <code>double</code> ein</li> <li><code>nextBoolean()</code>: liest ein <code>boolean</code> ein</li> </ul> <p>Es sei erw\u00e4hnt, dass es auch noch <code>nextLong()</code>, <code>nextFloat()</code>, <code>nextShort()</code> usw. gibt. </p> <p>Der Aufruf einer solchen Objektmethode erfolgt stets nach dem Prinzip:</p> <pre><code>referenzVariable.objektMethode()\n</code></pre> <p>Das hei\u00dft die Variable, die eine Referenz auf das Objekt h\u00e4lt (bei uns <code>sc</code>), ruft \u00fcber Punktnotation  (mit einem <code>.</code> verbinden) die entsprechende Objektmethode auf. Wir betrachten Beispiele:</p> <p><pre><code>public static void main(String[] args)\n{\n    Scanner sc = new Scanner(System.in);\n\n    System.out.print(\"Geben Sie eine ganze Zahl ein: \");\n    int ganzeZahl = sc.nextInt();\n    System.out.println(ganzeZahl); \n}\n</code></pre> In Zeile <code>6</code> sehen Sie den Aufruf der Methode <code>nextInt()</code> f\u00fcr das <code>sc</code>-Objekt, also <code>sc.nextInt()</code>. Die Methode <code>nextInt()</code> gibt die eingegebene Zahl zur\u00fcck, d.h. der Aufruf der Methode entspricht einer Zahl vom Datentyp <code>int</code>. Diese speichern wir in obigem Beispiel in der Variablen <code>ganzeZahl</code> vom Typ <code>int</code>.</p> <p>Wenn Sie auf der Konsole dann eine Zahl eingeben, sieht das so aus: </p> <p>Was passiert, wenn Sie keine Zahl eingeben? Dann wird eine sogenannte * Exception* geworfen. Eine Exception ist ein Fehler, der zur Laufzeit passiert. Wir werden bald lernen, wie man soclhe Exceptions abf\u00e4ngt, damit es nicht einen solchen \"Systemabsturz\" gibt. Derzeit m\u00fcssen wir damit noch leben. Eine solche fehlerhafte Eingabe w\u00fcrde so aussehenen: </p> <p>F\u00fcr diejenigen, die es interessiert, ist hier eine Methode, die einen solchen Fehlerfall abf\u00e4ngt. Das m\u00fcssen sie jetzt aber noch nicht verstehen - es ist, wie gesagt, nur f\u00fcr eventuelles Interesse:</p> <pre><code>package themen.hilfsklassen;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Hilfsklassen\n{\n    public static int ganzeZahlEinlesen(String message)\n    {\n        Scanner sc = new Scanner(System.in);\n        int number = 0;\n        boolean inputOk = false;\n\n        do\n        {\n            System.out.print(message + \": \");\n            try {\n                number = sc.nextInt();\n                inputOk = true;\n            }\n            catch(InputMismatchException e)\n            {\n                message = \"Sie m\u00fcssen eine Zahl eingeben\";\n                sc.next();\n            }\n        }while(!inputOk);\n        return number;\n    }\n\n    public static void main(String[] args)\n    {\n        int ganzeZahl = ganzeZahlEinlesen(\"Geben Sie eine Zahl ein\");\n        System.out.println(ganzeZahl); \n    }\n}\n</code></pre> <p>Ein m\u00f6glicher Ablauf w\u00e4re dann wie folgt:  </p> <p>Wir gehen erstmal davon aus, dass die Eingaben korrekt erfolgen und schauen uns noch weitere Beispiele an:</p> <pre><code>public static void weitereBeispiele()\n{\n    Scanner sc = new Scanner(System.in);\n\n    System.out.print(\"int Zahl : \");\n    int intNumber = sc.nextInt();\n    System.out.println(intNumber);\n\n    System.out.print(\"double Zahl : \");\n    double doubleNumber = sc.nextDouble();\n    System.out.println(doubleNumber);\n\n    System.out.print(\"boolean : \");\n    boolean wahrheitswert = sc.nextBoolean();\n    System.out.println(wahrheitswert);\n\n    System.out.print(\"String : \");\n    String zeichenkette = sc.next();\n    System.out.println(zeichenkette);\n}\n</code></pre> <p>Ein Aufruf der Methode <code>weitereBeispiele();</code> (z.B. in <code>main()</code>) k\u00f6nnte dann so aussehen: </p> <p>Beachten Sie:</p> <ol> <li>Bei der Eingabe einer <code>double</code>-Zahl m\u00fcssen Sie anstelle des Punktes ein Komma eingeben. Das h\u00e4ngt mit den l\u00e4ndertypischen Einstellungen von Eclipse zusammen. (Bei manchen ist es vielleicht ein Punkt.)</li> <li>Wenn Sie ein <code>String</code> eingeben, dann wird bei der Methode <code>next()</code> nur der String bis zum ersten Leerzeichen eingelesen. (Das l\u00e4sst sich \u00e4ndern, aber darauf gehen wir hier nicht n\u00e4her ein.) </li> </ol> <p>Success</p> <p>Wir k\u00f6nnen jetzt Eingaben \u00fcber unsere Konsole t\u00e4tigen!</p>"},{"location":"hilfsklassen/#die-klasse-math","title":"Die Klasse <code>Math</code>","text":"<p>Die Klasse <code>Math</code> enth\u00e4lt viele mathematische Funktionen als Methoden. Au\u00dferdem ist in ihr z.B. die Konstante <code>PI</code> definiert. Um die Klasse <code>Math</code> zu verwenden, m\u00fcssen wir sie nicht importieren, denn sie befindet sich im Paket <code>java.lang</code>. Wir m\u00fcssen auch kein Objekt der Klasse erzeugen, da alle Methoden dieser Klasse Klassenmethoden (also <code>static</code> sind). Um eine Methode dieser Klasse aufzurufen, setzen wir vor die Methode einfach <code>Math.</code>. Wir schauen uns Beispiele an:</p> <pre><code>        double nr1 = 16.0;\n        double nr2 = Math.sqrt(nr1);        // Quadratwurzel\n        double nr3 = Math.PI * 3.0;\n        double nr4 = Math.abs(-12.0);       // absoluter Betrag\n        double nr5 = Math.floor(12.3456);   // abgeschnitten -&gt; 12\n        double nr6 = Math.floor(12.9876);   // abgeschnitten -&gt; 12\n        double nr7 = Math.floor(-12.3456);  // abgeschnitten -&gt; -13\n        double nr8 = Math.floor(-12.9876);  // abgeschnitten -&gt; -13\n        double nr9 = Math.pow(2,5);         // 2 hoch 5 = 32\n</code></pre> <p>Beachten Sie, dass <code>floor()</code> nicht rundet, sondern die n\u00e4chste ganze Zahl angibt, die kleiner als der Parameterwert ist. </p> <p>Mithilfe der <code>Math.random()</code>-Methode k\u00f6nnen Sie sich au\u00dferdem <code>double</code>-Zufallszahlen aus dem Bereich <code>0.0 &lt;= zufallszahl &lt;1.0</code> erzeugen lassen. Wir werden das aber meistens mithilfe der folgenden Klasse <code>Random</code> erledigen. </p> <p>Alle Methoden der Klasse <code>Math</code> finden Sie hier. </p>"},{"location":"hilfsklassen/#die-klasse-random","title":"Die Klasse <code>Random</code>","text":"<p>Mithilfe der Klasse <code>Random</code> k\u00f6nnen wir Zufallszahlen erzeugen. Bei der Klasse <code>Random</code> ist es \u00e4hnlich wie bei <code>Scanner</code>:</p> <ol> <li>wir erzeugen uns ein <code>Random</code>-Objekt,</li> <li>die Klasse befindet sich im Paket <code>java.util</code>, d.h. wir m\u00fcssen sie importieren, </li> <li>wir w\u00e4hlen die passende Methode aus, je nachdem, von welchem Datentyp unsere Zufallszahl sein soll</li> </ol>"},{"location":"hilfsklassen/#ein-random-objekt-erzeugen","title":"Ein <code>Random</code>-Objekt erzeugen","text":"<p>Wir erzwugen uns ein <code>Random</code>-Objekt wie folgt <pre><code>Random r = new Random();\n</code></pre></p> <p>Um die Klasse <code>Random</code> verwenden zu k\u00f6nnen, muss sie importiert werden. Hier ein Ausschnitt aus der Klasse, in der wir neben <code>Random</code> auch <code>Scanner</code> verwenden: <pre><code>package themen.hilfsklassen;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Hilfsklassen\n{\n</code></pre></p> <p>In Zeile <code>3</code> wird die Klasse <code>Random</code> importiert. </p>"},{"location":"hilfsklassen/#objektemethoden-der-klasse-random","title":"Objektemethoden der Klasse <code>Random</code>","text":"<p>Die Klasse <code>Random</code> bietet verschiedene Methoden, um Zufallswerte der einzelnen Datentypen zu generieren:</p> <ul> <li><code>nextDouble()</code>: erzeugt eine <code>double</code>-Zahl (aus dem Bereich <code>0.0</code> inklusive bis <code>1.0</code> exclusive)</li> <li><code>nextFloat()</code>: erzeugt eine <code>float</code>-Zahl (aus dem Bereich <code>0.0</code> inklusive bis <code>1.0</code> exclusive)</li> <li><code>nextLong()</code>: erzeugt eine <code>long</code>-Zahl (aus (fast) dem Bereich gesamten Bereich von <code>long</code>)</li> <li><code>nextBoolean()</code>: erzeugt einen <code>boolean</code>-Wert zuf\u00e4llig (<code>true</code> oder <code>false</code>)</li> </ul> <p>Wir betrachten jedoch haupts\u00e4chlich die Methoden, die uns zuf\u00e4llig einen <code>int</code>-Wert liefern:</p> <ul> <li><code>nextInt()</code>: erzeugt eine <code>int</code>-Zahl aus dem gesamten Wertebereich von <code>int</code> - also auch negative Zahlen,</li> <li><code>nextInt(int bound)</code>: erzeugt eine <code>int</code>-Zahl aus dem Bereich <code>0</code> inklusive bis <code>bound</code> exclusive)</li> </ul>"},{"location":"hilfsklassen/#nextint","title":"<code>nextInt()</code>","text":"<p>Schauen wir uns zun\u00e4chst <code>nextInt()</code> an. Wir implementieren eine Methode, die uns 10 Zufallszahlen mithilfe der Methode <code>nextInt()</code>erzeugt und auf die Konsole ausgibt: <pre><code>public static void printIntRandomNumbers()\n{\n    Random r = new Random();\n    for(int i=0; i&lt;10; i++)\n    {\n        int randomNumber = r.nextInt();\n        System.out.println(randomNumber);\n    }\n}\n</code></pre></p> <p>In Zeile <code>6</code> sehen wir den Aufruf der Methode <code>nextInt()</code>. Die Referenzvariable <code>r</code> zeigt auf unser <code>Random</code>-Objekt. F\u00fcr die Referenzvariable wird mithilfe der Punktnotation die Methode <code>nextInt()</code> aufgerufen, also <code>r.nextInt();</code>. Diese Methode gibt eine Zufallszahl zur\u00fcck, die wir in der Variablen <code>randomNumber</code> speichern.</p> <p>Ein Aufruf der Methode <code>printIntRandomNumbers();</code> z.B. in <code>main()</code> kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): <pre><code>1362288576\n1801089219\n-1573362027\n56087730\n1015233281\n1341464232\n2112804572\n841838154\n1460116224\n-910734474\n</code></pre></p>"},{"location":"hilfsklassen/#nextintint-bound","title":"<code>nextInt(int bound)</code>","text":"<p>Die Methode <code>nextInt()</code> existiert auch parametrisiert, d.h. wir k\u00f6nnen ihr einen Parameterwert (vom Datentyp <code>int</code>) \u00fcbergeben. Dieser Wert muss positiv sein! Wenn nicht, dann wird eine <code>IllegalArgumentException</code> geworfen. Die Idee dieses Parameters ist zun\u00e4chst die, dass wir den Wertebereich einschr\u00e4nken, aus dem die Zufallszahlen erzeugt werden. Angenommen, wir \u00fcbergeben eine <code>6</code>, dann werden die Zufallszahlen aus dem Bereich <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> erzeugt. F\u00fcr <code>nextInt(bound)</code> gilt also, dass eine Zufallszahl aus dem Bereich <code>0</code> (inklusive)  bis <code>bound</code>(exklusive) (<code>0 &lt;= zufZahl &lt; bound</code>) erzeugt wird. </p> <p>Wir betrachten folgendes Beispiel:</p> <pre><code>public static void printIntRandomNumbers()\n{\n    Random r = new Random();\n    int bound = 10;\n    for(int i=0; i&lt;10; i++)\n    {\n        int randomNumber = r.nextInt(bound);\n        System.out.println(randomNumber);\n    }\n}\n</code></pre> <p>Wir haben die gleiche Methode wie oben, nur dass wir jetzt nicht <code>nextInt()</code>, sondern <code>nextInt(bound)</code> aufrufen (Zeile <code>7</code>). <code>bound</code> ist vom Typ <code>int</code> und hat den Wert <code>10</code> (Zeile <code>4</code>).</p> <p>Ein Aufruf der Methode <code>printIntRandomNumbers();</code> z.B. in <code>main()</code> kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): <pre><code>2\n8\n8\n6\n8\n2\n5\n9\n8\n3\n</code></pre></p> <p>Angenommen, wir wollen einen W\u00fcrfel implementieren. Mit dem Aufruf <code>nextInt(6)</code> w\u00fcrden wir Zahlen zuf\u00e4llig aus dem Bereich <code>[0, ..., 5]</code> erzeugen. Das w\u00e4re es noch nicht ganz. Erst, wenn wir zu der erzeugten Zufallszahl jeweils eine <code>1</code> hinzuaddieren, \"w\u00fcrfeln\" wir Zahlen aus dem Bereich <code>[1, ..., 6]</code>. Ein W\u00fcrfel w\u00fcrde also so implementiert werden:</p> <pre><code>Random r = new Random();\nint wurf = r.nextInt(6) + 1;    // zufaellig Zahlen 1 bis 6\n</code></pre> <p>Eine generelle Methode, um mithilfe der Methode <code>nextInt(bound)</code> einen beliebigen Bereich aus dem <code>int</code>-Wertebereich zuf\u00e4llig abzudecken, sehe z.B. wie folgt aus:</p> <pre><code>public static int getRandomNumber(int fromInclusive, int toInclusive)\n{\n    Random r = new Random();\n    int bound = (toInclusive - fromInclusive) + 1;  // +1 wegen toInclusive soll auch\n    int randomNumber = r.nextInt(bound) + fromInclusive;\n    return randomNumber;\n}\n</code></pre> <p>Die Methode ist nicht besonders stabil. Wir m\u00fcssten eigentlich \u00fcberpr\u00fcfen, ob <code>toInclusive</code> gr\u00f6\u00dfer ist als <code>fromInclusive</code>, aber wir wollen hier zun\u00e4chst nur das Prinzip erl\u00e4utern.</p> <p>Wir \"testen\" unsere Methode und schauen mal, ob wir Zufallszahlen aus dem Bereich <code>[90, ... , 99]</code> erzeugen:</p> <pre><code>for(int i=0; i&lt;50; i++)\n{\n    System.out.print(getRandomNumber(90, 99)+\" \");\n}\n</code></pre> <p>Eine m\u00f6gliche Ausgabe: <pre><code>96 99 92 98 95 91 95 96 97 93 97 90 94 92 92 94 95 93 99 91 92 95 99 90 91 97 99 93 92 98 91 92 99 90 90 97 95 90 92 97 93 92 94 93 94 90 92 96 96 94 \n</code></pre></p> <p>Noch ein \"Test\", diesmal Zahlen aus dem Bereich <code>[-33 , ... , -10]</code>:</p> <pre><code>for(int i=0; i&lt;50; i++)\n{\n    System.out.print(getRandomNumber(-33, -10)+\" \");\n}\n</code></pre> <p>Eine m\u00f6gliche Ausgabe: <pre><code>-10 -31 -29 -29 -33 -11 -19 -15 -33 -22 -13 -15 -14 -10 -28 -27 -24 -19 -13 -26 -21 -10 -25 -16 -29 -28 -16 -18 -29 -15 -23 -26 -18 -25 -29 -19 -12 -23 -26 -22 -15 -26 -11 -16 -18 -22 -20 -12 -21 -25\n</code></pre></p> <p>Von <code>[-10, ... , 10]</code> geht auch:</p> <pre><code>for(int i=0; i&lt;50; i++)\n{\n    System.out.print(getRandomNumber(-10, -10)+\" \");\n}\n</code></pre> <p>und unser W\u00fcrfel klappt auch:</p> <pre><code>for(int i=0; i&lt;50; i++)\n{\n    System.out.print(getRandomNumber(1, 6)+\" \");\n}\n</code></pre>"},{"location":"hilfsklassen/#die-klasse-string","title":"Die Klasse <code>String</code>","text":"<p>Wir haben die Klasse <code>String</code> bereits bei den Datentypen betrachtet. Dort haben wir gesagt, dass <code>String</code> ein anderer Datentyp ist, als die Wertetypen <code>int</code>, <code>boolean</code>, <code>double</code> usw. Bei <code>String</code> handelt es sich um einen Referenztypen. Ein <code>String</code> ist eine Referenz auf ein Objekt. Wenn wir also so etwas haben: <pre><code>String str = \"Hallo FIW!\"; \n</code></pre> dann ist <code>str</code> eine Referenzvariable, so wie z.B. <code>r</code> bei <code>Random</code> und <code>sc</code> bei <code>Scanner</code>. Wie bei <code>Random</code> und <code>Scanner</code> gibt es auch f\u00fcr String Methoden, die wir auf die Objekte anwenden k\u00f6nnen. Einige davon schauen wir uns im Folgenden an. Zun\u00e4chst untersuchen wir jedoch, was so ein String eigentlich intern ist. Bei einer Zeichenkette handelt es sich um ein Array aus einzelnen Zeichen, also <code>char</code>. Wir wissen noch nicht, was ein Array ist, aber wir bekommen hier eine Vorstellung davon. Angenommen, wir haben den obigen String (<code>\"Hallo FIW!\"</code>). Intern sieht der so aus:  </p> <p>Ein String besteht also aus einzelnen Zeichen (vom Typ <code>char</code>) und diese sind sogar automatisch \"nummeriert\". Wir haben einen sogenannten Index. Dieser Index ist eine ganze Zahl (<code>int</code>) und beginnt beim ersten Zeichen mit <code>0</code> und l\u00e4uft dann fortlaufend mit jedem Zeichen eins h\u00f6her. </p> <p>Betrachten wir unsere erste Methode f\u00fcr String: die Methode <code>length()</code>. Diese Methode gibt die L\u00e4nge eines Strings zur\u00fcck - in unserem Beispiel <code>10</code>.</p> <pre><code>String str = \"Hallo FIW!\";\nSystem.out.println(str.length());       // 10\n</code></pre> <p>Sie k\u00f6nnen die Methode \u00fcber Punktnotation \u00fcbrigens auch direkt an das Literal anh\u00e4ngen, also so:</p> <pre><code>System.out.println(\"Hallo FIW!\".length());      // 10\n</code></pre> <p>das gilt f\u00fcr alle der folgenden Objektmethoden. Beachten Sie, dass L\u00e4nge (<code>length()</code>) eines Strings um 1 gr\u00f6\u00dfer ist als der gr\u00f6\u00dfte Indexwert. In der obigen Abbildung sehen wir, dass das Ausrufezeichen (<code>!</code>) mit dem Index <code>9</code> nummeriert ist. Das liegt daran, dass der erste Index die <code>0</code> ist.  </p> <p>Nun wollen wir den Index verwenden, also die \"Nummer\" jedes einzelnen Zeichens in einem String. Die Methode <code>charAt(int index)</code> liefrt das Zeichen eines Strings an dem Index <code>index</code> zur\u00fcck. Also z.B.:</p> <pre><code>char c = \"Hallo FIW!\".charAt(6);        // 'F'\nSystem.out.println(c);                  // F\n</code></pre> <p>Wir lassen uns einmal alle Zeichen einzeln eines Strings ausgeben. Dazu verwenden wir eine <code>for</code>-Schleife. Die Laufvariable nimmt alle Werte aus dem Index an, d.h. <code>0</code> bis kleiner als <code>length()</code>:</p> <pre><code>String str = \"Hallo FIW!\";\n\nfor(int i=0; i&lt;str.length(); i++)\n{\n    char c = str.charAt(i);\n    System.out.println(c);\n}\n</code></pre> <p>Das erzeugt folgende Ausgabe:</p> <pre><code>H\na\nl\nl\no\n\nF\nI\nW\n!\n</code></pre> Verschl\u00fcsseln <p>Wir wissen ja, dass <code>char</code> ein ganzzahliger Datentyp ist. Wir k\u00f6nnten unsere Zeichenkette jetzt verschl\u00fcsseln, indem wir einfach zu dem ASCII-Code des jeweiligen Zeichens eine <code>1</code> hinzuaddieren. Das machen wir mal:</p> <pre><code>String str = \"Hallo FIW!\";\nSystem.out.println(str);            // Hallo FIW!\n\nfor(int i=0; i&lt;str.length(); i++)\n{\n    char c = str.charAt(i);\n    c++;                            // naechstgroesserer ASCII-Code (um 1 addiert)\n    System.out.print(c);            // Ibmmp!GJX\"\n}\n</code></pre> <p>Erzeugt folgende Ausgabe: <pre><code>Hallo FIW!\nIbmmp!GJX\"\n</code></pre></p> <p>Wir k\u00f6nnen auch einen bestimmten Index erfragen. Die Methode <code>indexOf(char c)</code> gibt den Index zur\u00fcck, an dem das Zeichen zum ersten Mal im String autaucht. Die Methode <code>lastIndexOf(char c)</code> gibt den Index zur\u00fcck, an dem das Zeichen zum letzten Mal im String autaucht. </p> <pre><code>int first = \"Hallo FIW!\".indexOf('l');                  // 2\nint last = \"Hallo FIW!\".lastIndexOf('l');               // 3\nSystem.out.println(\"l zum ersten Mal  : \" + first);\nSystem.out.println(\"l zum letzten Mal : \" + last);\n</code></pre> <p>Mithilfe des Index k\u00f6nnen wir auch Teile eines Strings extrahieren. Die Methode <code>substring(int beginIndex)</code> liefert den Teilstring beginnend mit dem Index <code>beginIndex</code> bis zum Ende des Strings zur\u00fcck. Die Methode <code>substring(int beginIndex, int endIndex)</code> liefert den Teilstring beginnend mit dem Index <code>beginIndex</code> (inklusive) bis zum Index <code>endIndex</code> (exklusive) zur\u00fcck.</p> <pre><code>String substr1 = \"Hallo FIW!\".substring(3);         // lo FIW!\nString substr2 = \"Hallo FIW!\".substring(3,7);       // lo F\nSystem.out.println(substr1);\nSystem.out.println(substr2);\n</code></pre> <p>Mithilfe der Methode <code>toLowerCase()</code> werden alle Buchstaben eines Strings in Kleinbuchstaben umgewandelt. Mithilfe der Methode <code>toUpperCase()</code> werden alle Buchstaben eines Strings in Gro\u00dfbuchstaben umgewandelt. </p> <pre><code>String lower = \"Hallo FIW!\".toLowerCase();          // hallo fiw!\nString upper = \"Hallo FIW!\".toUpperCase();          // HALLO FIW!\nSystem.out.println(lower);\nSystem.out.println(upper);\n</code></pre> <p>Um zwei Strings lexikographisch miteinander zu vergleichen, kann die Methode <code>compareTo(String)</code> verwendet werden. Diese gibt ein <code>int</code> zur\u00fcck. Wir betrachten dazu ein Beispiel:</p> <pre><code>int result1 = \"abc\".compareTo(\"abd\");           // -1 \nint result2 = \"abd\".compareTo(\"abc\");           // 1\nint result3 = \"abc\".compareTo(\"abc\");           // 0\n</code></pre> <ul> <li>In Zeile <code>1</code> ruft der String <code>\"abc\"</code> die <code>compareTo()</code>-Methode auf und vergleicht sich mit dem String <code>\"abd\"</code>. Da <code>\"abc\"</code> \"kleiner\" ist als <code>\"abd\"</code>, ist der R\u00fcckgabewert negativ <code>-1</code>. </li> <li>In Zeile <code>2</code> ruft der String <code>\"abd\"</code> die <code>compareTo()</code>-Methode auf und vergleicht sich mit dem String <code>\"abc\"</code>. Da <code>\"abd\"</code> \"gr\u00f6\u00dfer\" ist als <code>\"abc\"</code>, ist der R\u00fcckgabewert positiv <code>1</code>. </li> <li>In Zeile <code>3</code> ruft der String <code>\"abc\"</code> die <code>compareTo()</code>-Methode auf und vergleicht sich mit dem String <code>\"abc\"</code>. Da beide Strings gleich sind, ist der R\u00fcckgabewert <code>0</code>. </li> </ul> <p>Um einen Wert von einem Wertetypen (also die primitiven Datentypen <code>int</code>, <code>boolean</code>, <code>double</code> usw.) in einen String umzuwandeln, stehen die Klassenmethoden <code>valueOf()</code> zur Verf\u00fcgung. Der Zugriff auf eine solche Methode erfolgt mittels Punktschreibweise und dem Namen der Klasse, also <code>String.valueOf()</code> (es handelt sich um <code>static</code> Methoden). Die Umwandlung erfolgt also wie folgt:</p> <pre><code>String si9 = String.valueOf(9);         // int --&gt; String\nString si123 = String.valueOf(123);     // int --&gt; String\nString sb = String.valueOf(true);       // boolean --&gt; String\nString sd = String.valueOf(5.5);        // double --&gt; String\n</code></pre>"},{"location":"hilfsklassen/#format-methode-und-printf","title":"<code>format()</code>-Methode und <code>printf()</code>","text":"<p>In der \u00dcbung 2 sollte das kleine 1x1 einaml als Liste und einmal als Matrix ausgegeben werden. Bei beiden war die Formatierung der Ausgabe nicht besonders sch\u00f6n, da die Zahlen unterschiedliche L\u00e4ngen hatten. Sch\u00f6ner w\u00e4re es gewesen, die Ausgabe der Zahlen rechtsb\u00fcndig zu gestalten. Das geht mit der <code>System.out.printf()</code>-Methode. Die <code>printf()</code>-Methode verwendet die <code>format()</code>-Methode von Strings zur Formatierung der Ausgabe. Wir schauen uns zun\u00e4chst ein einf\u00fchrendes Beispiel an:</p> <pre><code>String output = String.format(\"in %s angemeldet : %d Studentinnen\", \"FIW\", 44);\nSystem.out.println(output);\n</code></pre> <p>Die <code>format()</code>-Methode in Zeile <code>1</code> hat drei Parameter:</p> <ul> <li>einen Ausgabestring, der Platzhalter enth\u00e4lt</li> <li>einen String <code>\"FIW\"</code> und</li> <li>eine <code>int</code>-Zahl <code>44</code></li> </ul> <p>Der Ausgabestring enth\u00e4lt sogenannte Platzhalter, n\u00e4mlich <code>%s</code> f\u00fcr einen <code>String</code> und <code>%d</code> f\u00fcr ein <code>int</code>. Anstelle dieser Platzhalter werden die nach dem Ausgabestring aufgelisteten Werte eingef\u00fcgt, also f\u00fcr <code>%s</code> wird <code>\"FIW\"</code> eingesetzt und f\u00fcr <code>%d</code> die <code>44</code>. Die Ausgabe sieht dann so aus:</p> <pre><code>in FIW angemeldet : 44 Studentinnen\n</code></pre> <p>Das ist zun\u00e4chst wenig spektakul\u00e4r. Hier zun\u00e4chst eine Tabelle mit den wichtigsten Platzhaltern:</p> Platzhalter Eingabetyp \u00a0Ausgabe (String) %d \u00a0int/long/... \u00a0ganze Zahl \u00a0%f \u00a0float/double \u00a0Gleitkommazahl, Standardnotation \u00a0%e \u00a0float/double \u00a0Gleitkommazahl, wiss. Notation \u00a0%s \u00a0String \u00a0Zeichenkette \u00a0%c \u00a0char \u00a0Buchstabe \u00a0%n \u00a0Zeilenumbruch <p>Ein Beispiel sieht also so aus: </p> <p>Die eigentliche Formatierung erfolgt durch die Angabe der vorgesehenen Breite f\u00fcr einen Ausgabewert und ob dieser Wert rechtsb\u00fcndig oder linksb\u00fcndig dargestellt werden soll. Die allgemeine Syntax f\u00fcr einen solchen Platzhalter ist wie folgt:</p> <pre><code>% [Schalter] [Breite] . [Genauigkeit] Typ\n</code></pre> <p>Dabei sind:</p> <ul> <li><code>%</code> :  Formatierungsausdruck beginnt</li> <li><code>Schalter</code> (optional): ver\u00e4ndert das Format der Ausgabe (Minuszeichen (-) = linksb\u00fcndige Ausgabe)</li> <li><code>Breite</code> : Anzahl der ausgegebenen Zeichen </li> <li><code>Genauigkeit</code> (optional): Nachkommastellen </li> <li><code>Typ</code> : Ausgabetyp (<code>s</code> (String): Zeichenkette kleingeschrieben, <code>S</code>: Zeichenkette gro\u00dfgeschrieben, <code>d</code> (decimal): Ganzzahl, <code>f</code> (floating-point): Nachkommazahl)</li> </ul> <p>Dazu ein Beispiel:</p> <pre><code>public static void createTable(int rows)\n{\n    Random r = new Random();\n    int number1 = 0;\n    int number2 = 0;\n\n    System.out.println(\"\u00a0 a \u00a0 | \u00a0 b \u00a0 |\u00a0 a + b \u00a0 |\u00a0 a - b\u00a0 |\u00a0 a * b\u00a0 |\u00a0 a / b\u00a0 |\u00a0 a % b \");\n    System.out.println(\"----------------------------------------------------------------\");\n\n    for(int i=0; i&lt;rows; i++)\n    {\n        number1 = r.nextInt(100)+1;\n        number2 = r.nextInt(100)+1;\n        System.out.printf(\"%4d\u00a0 | %4d\u00a0 |\u00a0 %5d \u00a0 | %5d \u00a0 |%7d\u00a0 |\u00a0 %5d\u00a0 | %4d %n\",\n            number1, number2, number1+number2, number1-number2, number1*number2,\n            number1/number2, number1%number2);\n    }\n}\n</code></pre> <p>Bei Aufruf von <code>createTable(8);</code> erreichen wir zum Beispiel folgende Ausgabe:</p> <pre><code>\u00a0 a \u00a0 | \u00a0 b \u00a0 |\u00a0 a + b \u00a0 |\u00a0 a - b\u00a0 |\u00a0 a * b\u00a0 |\u00a0 a / b\u00a0 |\u00a0 a % b \n----------------------------------------------------------------\n   4\u00a0 |   39\u00a0 |\u00a0    43 \u00a0 |   -35 \u00a0 |    156\u00a0 |\u00a0     0\u00a0 |    4 \n  60\u00a0 |    2\u00a0 |\u00a0    62 \u00a0 |    58 \u00a0 |    120\u00a0 |\u00a0    30\u00a0 |    0 \n  93\u00a0 |   60\u00a0 |\u00a0   153 \u00a0 |    33 \u00a0 |   5580\u00a0 |\u00a0     1\u00a0 |   33 \n   8\u00a0 |   68\u00a0 |\u00a0    76 \u00a0 |   -60 \u00a0 |    544\u00a0 |\u00a0     0\u00a0 |    8 \n  80\u00a0 |   82\u00a0 |\u00a0   162 \u00a0 |    -2 \u00a0 |   6560\u00a0 |\u00a0     0\u00a0 |   80 \n  31\u00a0 |   10\u00a0 |\u00a0    41 \u00a0 |    21 \u00a0 |    310\u00a0 |\u00a0     3\u00a0 |    1 \n   7\u00a0 |   30\u00a0 |\u00a0    37 \u00a0 |   -23 \u00a0 |    210\u00a0 |\u00a0     0\u00a0 |    7 \n  54\u00a0 |   12\u00a0 |\u00a0    66 \u00a0 |    42 \u00a0 |    648\u00a0 |\u00a0     4\u00a0 |    6 \n</code></pre> <p>Die Zahlen erscheinen also alle geordnet untereinander und rechtsb\u00fcndig. Wie gesagt, <code>System.out.printf()</code> und <code>String.format()</code> funktionieren exakt gleich, da <code>printf()</code> <code>format()</code> verwendet. Weitere Beispiele f\u00fcr Schalter und ihre Breitenangaben:</p> <pre><code>String output;\noutput = String.format(\"|%10d|\", 1234);             // |\u00a0 \u00a0 \u00a0 1234|\noutput = String.format(\"|%-10d|\", 1234);            // |1234\u00a0 \u00a0 \u00a0 |\noutput = String.format(\"|%010d|\", 1234);            // |0000001234|\noutput = String.format(\"|%+10d|\", 1234);            // | \u00a0 \u00a0 +1234|\noutput = String.format(\"|%,10d|\", 1234);            // | \u00a0 \u00a0 1.234|\noutput = String.format(\"|%10.2f|\", 1234.567);       // | \u00a0 1234,57|\noutput = String.format(\"|%-10.2f|\", 1234.567);      // |1234,57 \u00a0 |\noutput = String.format(\"|%5.2f|\", 1234.567);        // |1234,57|\noutput = String.format(\"|%15s|\", \"Hallo FIW!\");     // | \u00a0 \u00a0 Hallo FIW!|\noutput = String.format(\"|%-15s|\", \"Hallo FIW!\");    // |Hallo FIW! \u00a0 \u00a0 |\noutput = String.format(\"|%.7s|\", \"Hallo FIW!\");     // |Hallo F|\n</code></pre> <p>Unsere beiden Methoden des kleinen 1x1 aus \u00dcbung 2 h\u00e4tten dann auch eine sch\u00f6nere Ausgabe:</p> <pre><code>    public static void printTimesTables(int nr1, int nr2)\n    {\n        for(int faktor1 = 1; faktor1&lt;=nr1; faktor1++)\n        {\n            for(int faktor2 = 1; faktor2&lt;=nr2; faktor2++)\n            {\n                int produkt = faktor1 * faktor2;\n                System.out.printf(\"%2d  * %2d = %3d %n\", faktor1, faktor2, produkt);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void printTimesMatrix(int nr1, int nr2)\n    {\n        for(int faktor1 = 1; faktor1 &lt;= nr1; faktor1++)\n        {\n            for(int faktor2 = 1; faktor2 &lt;= nr2; faktor2++)\n            {\n                int produkt = faktor1 * faktor2;\n                System.out.printf(\"%4d\", produkt);\n            }\n            System.out.println();\n        }\n    }\n</code></pre> <p>N\u00e4mlich so:</p> <pre><code>----- Aufgabe 1 ------\n\n 1  *  1 =   1 \n 1  *  2 =   2 \n 1  *  3 =   3 \n 1  *  4 =   4 \n 1  *  5 =   5 \n 1  *  6 =   6 \n 1  *  7 =   7 \n 1  *  8 =   8 \n 1  *  9 =   9 \n 1  * 10 =  10 \n\n 2  *  1 =   2 \n 2  *  2 =   4 \n 2  *  3 =   6 \n 2  *  4 =   8 \n 2  *  5 =  10 \n 2  *  6 =  12 \n 2  *  7 =  14 \n 2  *  8 =  16 \n 2  *  9 =  18 \n 2  * 10 =  20 \n\n 3  *  1 =   3 \n 3  *  2 =   6 \n 3  *  3 =   9 \n 3  *  4 =  12 \n 3  *  5 =  15 \n 3  *  6 =  18 \n 3  *  7 =  21 \n 3  *  8 =  24 \n 3  *  9 =  27 \n 3  * 10 =  30 \n\n 4  *  1 =   4 \n 4  *  2 =   8 \n 4  *  3 =  12 \n 4  *  4 =  16 \n 4  *  5 =  20 \n 4  *  6 =  24 \n 4  *  7 =  28 \n 4  *  8 =  32 \n 4  *  9 =  36 \n 4  * 10 =  40 \n\n 5  *  1 =   5 \n 5  *  2 =  10 \n 5  *  3 =  15 \n 5  *  4 =  20 \n 5  *  5 =  25 \n 5  *  6 =  30 \n 5  *  7 =  35 \n 5  *  8 =  40 \n 5  *  9 =  45 \n 5  * 10 =  50 \n\n 6  *  1 =   6 \n 6  *  2 =  12 \n 6  *  3 =  18 \n 6  *  4 =  24 \n 6  *  5 =  30 \n 6  *  6 =  36 \n 6  *  7 =  42 \n 6  *  8 =  48 \n 6  *  9 =  54 \n 6  * 10 =  60 \n\n 7  *  1 =   7 \n 7  *  2 =  14 \n 7  *  3 =  21 \n 7  *  4 =  28 \n 7  *  5 =  35 \n 7  *  6 =  42 \n 7  *  7 =  49 \n 7  *  8 =  56 \n 7  *  9 =  63 \n 7  * 10 =  70 \n\n 8  *  1 =   8 \n 8  *  2 =  16 \n 8  *  3 =  24 \n 8  *  4 =  32 \n 8  *  5 =  40 \n 8  *  6 =  48 \n 8  *  7 =  56 \n 8  *  8 =  64 \n 8  *  9 =  72 \n 8  * 10 =  80 \n\n 9  *  1 =   9 \n 9  *  2 =  18 \n 9  *  3 =  27 \n 9  *  4 =  36 \n 9  *  5 =  45 \n 9  *  6 =  54 \n 9  *  7 =  63 \n 9  *  8 =  72 \n 9  *  9 =  81 \n 9  * 10 =  90 \n\n10  *  1 =  10 \n10  *  2 =  20 \n10  *  3 =  30 \n10  *  4 =  40 \n10  *  5 =  50 \n10  *  6 =  60 \n10  *  7 =  70 \n10  *  8 =  80 \n10  *  9 =  90 \n10  * 10 = 100 \n\n\n----- Aufgabe 2 ------\n\n   1   2   3   4   5   6   7   8   9  10\n   2   4   6   8  10  12  14  16  18  20\n   3   6   9  12  15  18  21  24  27  30\n   4   8  12  16  20  24  28  32  36  40\n   5  10  15  20  25  30  35  40  45  50\n   6  12  18  24  30  36  42  48  54  60\n   7  14  21  28  35  42  49  56  63  70\n   8  16  24  32  40  48  56  64  72  80\n   9  18  27  36  45  54  63  72  81  90\n  10  20  30  40  50  60  70  80  90 100\n</code></pre>"},{"location":"hilfsklassen/#formatierung-von-gleikommazahlen","title":"Formatierung von Gleikommazahlen","text":"<p>Um Gleitkommazahlen in der Standardnotation (nicht wissenschaftliche Notation) formatiert auszugeben, wird der Platzhalter <code>%f</code> verwendet. Die allgemeine Syntax ist also</p> <pre><code>% [Schalter] [Breite] . [Genauigkeit] f\n</code></pre> <p>Der <code>Schalter</code> kann <code>-</code> sein, dann wird die Zahl linksb\u00fcndig dargestellt. Ist kein <code>Schalter</code> angegeben, erfolgt die Ausgabe rechtsb\u00fcndig. Die <code>Breite</code> beschreibt die gesamte Anzahl der Stellen f\u00fcr die Zahl. Die <code>Breite</code> enth\u00e4lt insbesondere auch eine Stelle f\u00fcr das Komma und die Anzahl der Stellen f\u00fcr die <code>Genauigkeit</code>. Die <code>Genauigkeit</code> gibt die Anzahl der Nachkommastellen an.  </p> <p>Angenommen, der Plathalter lautet <code>%7.2f</code>. Dann werden insgesamt sieben Stellen f\u00fcr die gesamte Zahl reserviert, inklusive dem Komma und den <code>2</code> Nachkommastellen, also</p> <pre><code>_ _ _ _ , _ _ \n</code></pre> <p>Wenn die Gesamtl\u00e4nge beliebig ist, Sie aber nur genau 2 Nachkommastellen haben m\u00f6chten, dann k\u00f6nnen Sie auch <code>%.2f</code> als Platzhalter angeben. F\u00fcr eine Nachkommastelle <code>%.1f</code>. Die Nachkommastellen werden sogar gerundet. </p> <p>Hier nochmal einige Beispiele von oben nur f\u00fcr Gleikommazahlen:</p> <pre><code>System.out.printf(\"|%10.2f|\", 1234.567);        // | \u00a0 1234,57|\nSystem.out.printf(\"|%-10.2f|\", 1234.567);       // |1234,57 \u00a0 |\nSystem.out.printf(\"|%7.2f|\", 1234.567);         // |1234,57|\nSystem.out.printf(\"|%5.2f|\", 1234.567);         // |1234,57|\n</code></pre> <p>Beachten Sie auch das letzte Beispiel (Zeile <code>4</code>). Es wurden nur insgesamt <code>5</code> Stellen f\u00fcr die gesamte Zahl reserviert. Davon ben\u00f6tigen wir alleine <code>2</code> Stellen f\u00fcr die Nachkommastellen und <code>1</code> Stelle f\u00fcr das Komma. Die Vorkommastellen h\u00e4tten also nur <code>2</code>Stellen Platz. Vorne wird die Zahl aber nie abgeschnitten. Sollte der reservierte Platz f\u00fcr die Vorkommastellen nicht ausreichen, wird der Vorkommabereich trotzdem vollst\u00e4ndig dargestellt. Es kann also trotz der Formatierung zu Verzerrungen in der Ausgabe kommen!</p>"},{"location":"iteration/","title":"Iteration","text":"<p>Die Iteration ist eine der drei Programmablaufstrukturen, die es gibt. Die Nacheinanderausf\u00fchrung von Anweisungen, die Sequenz ist einfach und wir benutzen es st\u00e4ndig. Die Selektion haben wir uns hier genauer angeschaut. Nun geht es um die letzte Programmstruktur, die wir kennenlernen, die Iteration. </p> <p>Unter einer Iteration verstehen wir die wiederholte Ausf\u00fchrung eines Anweisungsblocks. Die Programmkonstrukte, mit denen wir eine Iteration umsetzen, werden Schleifen genannt. Wir werden drei Schleifen kennenlernen:</p> <ul> <li>die <code>for</code>-Schleife und </li> <li>die <code>while</code>-Schleife.</li> <li>die <code>do...while</code>-Schleife</li> </ul>"},{"location":"iteration/#die-for-schleife","title":"Die <code>for</code>-Schleife","text":"<p>Die <code>for</code>-Schleife verwenden wir, wenn wir eine oder mehrere Anweisungen abz\u00e4hlbar oft wiederholen wollen, wenn wir also die Anzahl der Ausf\u00fchrungen kennen. Die Idee bei der <code>for</code>-Schleife ist die, dass wir uns</p> <ol> <li>eine Laufvariable (typischerweise vom Datentyp <code>int</code>) deklarieren und initialisieren (<code>INITIALISIERUNG</code>),</li> <li>eine Bedingung angeben, f\u00fcr welche Werte der Laufvariablen die Schleife wiederholt werden soll (<code>BEDINGUNG</code>) und</li> <li>wie sich der Wert der Laufvariablen nach jedem Schleifendurchlauf \u00e4ndern soll (<code>\u00c4NDERUNG</code>). </li> </ol> <p>Die allgemeine Syntax f\u00fcr eine solche Vorschleife sieht so aus:</p> <pre><code>for(INITIALISIERUNG ; BEDINGUNG ; \u00c4NDERUNG)\n{\n    /*\n     * Anweisungsblock, der wiederholt\n     * werden soll\n     */\n}\n</code></pre> <p>Wir betrachten ein einfaches Beispiel:</p> <pre><code>for(int i=0; i&lt;5; i++)\n{\n    System.out.println(i);\n}\n</code></pre> <p>Der Ablauf dieser Schleife sieht wie folgt aus:</p> <ul> <li>Zuerst wird die Laufvariable <code>i</code> deklariert und mit dem Wert <code>0</code> initialisiert. Das passiert genau ein Mal. </li> <li>Dann wird gepr\u00fcft, ob die Bedingung <code>i&lt;5</code> den Wert <code>true</code> ergibt. Das passiert vor jedem Schleifendurchlauf. Wenn der Wert <code>true</code> ist, wird der Schleifenk\u00f6rper, also der Anweisungsblock ausgef\u00fchrt. <code>i&lt;5</code> ist <code>true</code>, also wird <code>System.out.println(i);</code> ausgef\u00fchrt. Der Wert von <code>i</code>ist <code>0</code>, also wird eine <code>0</code> auf die Konsole ausgegeben. Mehr Anweisungen gibt es nicht im Anweisungsblock, somit sind wir am Ende der Schleife.</li> <li>Nun wird der Wert von <code>i</code> ge\u00e4ndert. Dazu wird <code>i++</code> ausgef\u00fchrt. Der Wert von <code>i</code> ist nun <code>1</code>.</li> <li>Nun wird erneut gepr\u00fcft, ob die Bedingung <code>i&lt;5</code> den Wert <code>true</code> ergibt. <code>i&lt;5</code> ist <code>true</code>, also wird <code>System.out.println(i);</code> ausgef\u00fchrt. Der Wert von <code>i</code>ist <code>1</code>, also wird eine <code>1</code> auf die Konsole ausgegeben. </li> <li>Nun wird wieder der Wert von <code>i</code> ge\u00e4ndert. Dazu wird <code>i++</code> ausgef\u00fchrt. Der Wert von <code>i</code> ist nun <code>2</code>.</li> <li>Es wird erneut gepr\u00fcft, ob die Bedingung <code>i&lt;5</code> den Wert <code>true</code> ergibt. <code>i&lt;5</code> ist <code>true</code>, also wird <code>System.out.println(i);</code> ausgef\u00fchrt. Der Wert von <code>i</code>ist <code>2</code>, also wird eine <code>2</code> auf die Konsole ausgegeben. </li> <li><code>i++</code> \u2192 Wert von <code>i</code>ist <code>3</code></li> <li><code>i&lt;5</code> ist <code>true</code> \u2192 Anweisungsblock</li> <li><code>System.out.println(i);</code> der Wert von <code>i</code> ist <code>3</code> \u2192 Ausgabe <code>3</code></li> <li><code>i++</code> \u2192 Wert von <code>i</code>ist <code>4</code></li> <li><code>i&lt;5</code> ist <code>true</code> \u2192 Anweisungsblock</li> <li><code>System.out.println(i);</code> der Wert von <code>i</code> ist <code>4</code> \u2192 Ausgabe <code>4</code></li> <li><code>i++</code> \u2192 Wert von <code>i</code>ist <code>5</code></li> <li><code>i&lt;5</code> ist nun <code>false</code> \u2192 Deshalb wird der Anweisungsblock nicht mehr ausgef\u00fchrt! Wir verlassen die Schleife und f\u00fchren die n\u00e4chste Anweisung aus, die nach der Schleife kommt.</li> </ul> <p>Oberes Beispiel erzeugt also folgende Ausgabe auf der Konsole:</p> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>In den meisten <code>for</code>-Schleifen wird die Initialisierung wie oben aussehen, also eine Laufvariable (hier <code>i</code>) wird auf <code>0</code> am Anfang gesetzt und die \u00c4nderung des Wertes erfolgt dann durch die Erh\u00f6hung des Wertes um <code>1</code> (hier <code>i++</code>). Das kann aber auch anders sein, z.B.:</p> <pre><code>for(int i=5; i&gt;0; i--)\n{\n    System.out.println(i);\n}\n</code></pre> <p>Hier ist der initiale Wert der Laufvariablen <code>5</code>. Die Bedingung pr\u00fcft, ob <code>i</code> gr\u00f6\u00dfer ist als <code>0</code>. nach jedem Schleifendurchlauf wird der Wert der Laufvriablen <code>i</code> um <code>1</code> rediziert. Es entsteht folgende Ausgabe:</p> <pre><code>5\n4\n3\n2\n1\n</code></pre> <p>F\u00fcr die \u00c4nderung des Wertes der Laufvariablen k\u00f6nnen Sie auch jeden der in verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren eingef\u00fchrten Operatoren verenden, z.B. </p> <pre><code>for(int i=1; i&lt;10; i+=2)\n{\n    System.out.println(i);      // 1 3 5 7 9\n}\n\nfor(int i=1; i&lt;10; i*=2)\n{\n    System.out.println(i);      // 1 2 4 8\n}\n</code></pre> <p>Deklaration von Variablen in der <code>for</code>-Schleife</p> <p>In dem oberen Beispiel ist die Laufvariable <code>i</code> zwei Mal deklariert, einmal f\u00fcr die erste <code>for</code>-Schleife und ein weiteres Mal f\u00fcr die zweite <code>for</code>-Schleife. Eigentlich hatten wir ja gesagt, dass eine Variable immer nur genau ein Mal deklariert wird. Korrekt ist es, dass eine Variable immer nur in dem Anweisungsblock existiert, in dem sie deklariert wird. Au\u00dferhalb dieses Anweisungsblockes existiert sie nicht. Wir hatten das auch schon bei Methoden erw\u00e4hnt. Dort hatten wir gesagt, dass die Variablen, die in zwei verschiedenen Methoden deklariert werden, miteinander nichts zu tun haben, sondern dass es sich dabei um verschiedene Variablen handelt. Wenn wir eine Variable innerhalb der <code>for</code>-Schleife deklarieren, dann exitiert sie f\u00fcr die <code>for</code>-Schleife. Davor und danch existiert die Variable nicht (mehr). Deshalb m\u00fcssen wir <code>i</code> in der zweiten <code>for</code>-Schleife auch erneut deklarieren. Wir kommen darauf nochmal ausf\u00fchrlicher zu sprechen, wenn es um die Lebensdauer und Sichtbarkeit von Variablen geht. </p>"},{"location":"iteration/#weitere-beispiele-fur-einfache-for-schleifen","title":"Weitere Beispiele f\u00fcr einfache <code>for</code>-Schleifen","text":"<p>Wir betrachten noch einige Beispiele f\u00fcr einfache <code>for</code>-Schleifen, um uns mit dem Konzept weiter vertraut zu machen. </p>"},{"location":"iteration/#summe-1-bis-n","title":"Summe 1 bis n","text":"Ausgabe der Summe von 1 bis n <pre><code>public static void computeSumFrom1ToN(int n)\n{\n    int sum = 0;\n    String s = \"1\";\n    for(int i=1; i&lt;=n; i++)\n    {\n        if(i&gt;1)\n        {\n            s += \" + \" + i;\n        }\n        sum = sum + i;\n        System.out.println(s + \" = \" + sum);\n    }\n}\n</code></pre> <p>In der Methode <code>computeSumFrom1ToN(int n)</code> wird die Summe von <code>1 + 2 + ... + n</code> berechnet, wobai <code>n</code> als Parameterwert der Methode \u00fcbergeben wird. Jeder einzelne Schritt wird ausgegeben. Dazu wird ein <code>String s</code> erzeugt, der initial den Wert <code>\"1\"</code> hat. F\u00fcr jede Weitere Addition kommt <code>\" + 2\"</code>, <code>\" + 3\"</code> usw. zu diesem String hinzu. </p> <ul> <li>Beachten Sie, dass wir die Variable <code>s</code> au\u00dferhalb der <code>for</code>-Schleife deklariert haben. W\u00e4re sie innerhalb der <code>for</code>-Schleife deklariert, dann w\u00fcrde sie bei jedem Schleifendurchlauf neu erzeugt werden. So wird ihr Wert bei jedem Schleifendurchlauf aktualisiert. </li> <li>Die Selektion wurde eingef\u00fcgt, damit beim ersten Schleifendurchlauf (f\u00fcr <code>i==1</code>) nichts an den String <code>s</code> angeh\u00e4ngt wird, sondern nur f\u00fcr alle weiteren Schleifendurchl\u00e4ufe. </li> <li>Beachten Sie auch, dass die Laufvariable <code>i</code> von <code>1</code> bis einschlie\u00dflich <code>n</code> la\u00e4uft und wir dadurch die Summe von <code>1 + 2 + ... + n</code> erzeugen. Wird als Parameterwert eine Zahl kleiner als <code>1</code> \u00fcbergeben, erfolgt keine Ausgabe, denn dann ist die Bedingung <code>1&lt;=n</code> bereits vor dem ersten Schleifendurchlauf <code>false</code>. </li> </ul> Ausgabe f\u00fcr den Aufruf <code>computeSumFrom1ToN(10)</code> <pre><code>1 = 1\n1 + 2 = 3\n1 + 2 + 3 = 6\n1 + 2 + 3 + 4 = 10\n1 + 2 + 3 + 4 + 5 = 15\n1 + 2 + 3 + 4 + 5 + 6 = 21\n1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55\n</code></pre>"},{"location":"iteration/#fakultat-von-n","title":"Fakult\u00e4t von n","text":"<p>Die Fakult\u00e4t von n ist definiert als <code>n! = 1 * 2 * ... * n</code> f\u00fcr alle Nat\u00fcrlichen Zahlen <code>n&gt;=1</code>. Wir schreiben uns daf\u00fcr eine Methode und \u00fcbergeben ein <code>n</code>:</p> Fakult\u00e4t von n <pre><code>public static void fakultaetVonN(int n)\n{\n    int product = 1;\n    String s = \"!\";\n    for(int i=1; i&lt;=n; i++)\n    {\n        if(i==2)\n        {\n            s += \" = 1 * 2\";\n        }\n        else if(i&gt;2)\n        {\n            s += \" * \" + i;\n        }\n        product *= i;\n        System.out.println(i + s + \" = \" + product);\n    }\n}\n</code></pre> <p>In der Variablen <code>product</code> speichern wir das Produkt aus den Faktoren <code>1 * 2 * ... * n</code>. beachten Sie, dass <code>product</code> am Anfang den Wert <code>1</code> haben muss, um nicht immer mit <code>0</code> zu multiplizieren und somit w\u00e4re das Produkt immer <code>0</code>. Anstelle von <code>product *= i;</code> h\u00e4tten wir auch <code>product = product * i;</code> schreiben k\u00f6nnen. Weil wir unseren Ausgabestring <code>s</code> noch ein wenig komplizierter gestalttet haben, ist hier sogar eine Fallunterscheidung zwischen <code>i==2</code> und <code>i&gt;2)</code> notwendig. </p> Ausgabe f\u00fcr den Aufruf <code>fakultaetVonN(8)</code> <pre><code>1! = 1\n2! = 1 * 2 = 2\n3! = 1 * 2 * 3 = 6\n4! = 1 * 2 * 3 * 4 = 24\n5! = 1 * 2 * 3 * 4 * 5 = 120\n6! = 1 * 2 * 3 * 4 * 5 * 6 = 720\n7! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040\n8! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320\n</code></pre>"},{"location":"iteration/#fibonacci-folge","title":"Fibonacci-Folge","text":"\u00dcbung Fibonacci-Folge <p>Schreiben Sie ein Programm, das die Fibonacci-Folge auf der Konsole ausgibt. Die ersten beiden Werte der Fibonacci-Folge sind <code>0</code> und <code>1</code>. Die Berechnung der Folgezahlen soll in einer Schleife gemacht werden. Eine Fibonacci-Folge sieht wie folgt aus: <code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026</code>. Es gilt: eine Zahl <code>n</code> ist immer die Summe ihrer beiden Vorg\u00e4nger <code>n-1</code> und <code>n-2</code>. </p>"},{"location":"iteration/#verschachtelte-for-schleifen","title":"Verschachtelte <code>for</code>-Schleifen","text":"<p>In den bisherigen Beispielen haben wir immer genau eine <code>for</code>-Schleife ben\u00f6tigt, da wir \"nur\" etwas aufaddiert oder aufmultipliziert haben, um eine eindimensionale Folge zu berechnen oder auszugeben. Wir wissen aber bereits, dass in dem Anweisungsblock des Schleifenk\u00f6rpers jede beliebige Kontrollstruktur vorkommen kann, also eine Sequenz und/oder eine Iteration und/oder eine Selektion. Selektion und Sequenz haben wir in unseren Beispielen bereits verwendet. Nun wollen wir auch noch eine Schleife innerhalb der Schleife untersuchen. </p>"},{"location":"iteration/#rechteck","title":"Rechteck","text":"<p>Angenommen, wir sollen ein Rechteck aus lauter <code>*</code>-zeichen auf die Konsole ausgeben und sowohl die Breite des Rechtecks als auch dessen H\u00f6he sind variabel. Am Ende soll also so ein Bild herauskommen:</p> <pre><code>***********************\n***********************\n***********************\n***********************\n***********************\n</code></pre> <p>In diesem Beispiel ist die Breite <code>23</code> und die H\u00f6he <code>5</code>. Unsere \u00dcberlegungen sind zun\u00e4chst wie folgt:</p> <ol> <li>wir k\u00f6nnen nur zeilenweise ausgeben (spaltenweise geht nicht auf der Konsole)</li> <li>wir ben\u00f6tigen eine Schleife, um die <code>23</code> Sterne in einer Zeile auszugeben</li> <li>wir ben\u00f6tigen eine Schleife, um die <code>5</code> Zeilen auszugeben</li> </ol> <p>D.h. wir \u00fcberlegen uns zun\u00e4chst, wie wir eine Zeile ausgeben. Wir nehmen dazu an, wir haben eine <code>int</code>-Variable <code>width</code>, die uns die Breite des Rechtecks vorgibt (z.B. <code>23</code>):</p> <pre><code>for(int col = 0; col &lt; width; col++)\n{\n    System.out.print(\"*\");\n}\n</code></pre> <p>Wir geben also in einer Schleife eine Anzahl <code>width</code> von Sternen aus. Beachten Sie,</p> <ul> <li>dass die Laufvariable <code>col</code> (f\u00fcr column) mit <code>0</code> initialisert wird. Deshalb ist die Schleifenbedingung <code>col &lt; width</code>. H\u00e4tten wir <code>col &lt;= width</code> geschrieben, w\u00fcrde ein Stern zu viel ausgegeben (au\u00dfer, wir h\u00e4tten <code>col</code> mit <code>1</code>initialisiert). Sie m\u00fcssen die Initialisierung und die Bedingung immer gut aufeinander abstimmen!</li> <li>dass wir zur Ausgabe <code>print(\"*\")</code> statt <code>println(\"*\")</code>verwenden, weil sonst nach jedem Stern ein Zeilenumbruch erfolgen w\u00fcrde, die Sterne also nicht nebeneinander sondern untereinander ausgegeben w\u00fcrden. </li> </ul> <p>Nun \u00fcberlegen wir uns, wie wir die Zeilen ausgeben. Dazu nehmen wir an, wir haben eine <code>int</code>-Variable <code>height</code>, die uns die H\u00f6he des Rechtecks vorgibt (z.B. <code>5</code>):</p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    // Hier soll jetzt eine Zeile ausgegeben werden\n}\n</code></pre> <p>Wir geben also in einer Schleife eine Anzahl <code>height</code> von Zeilen aus aus. In jeder Zeile soll die Anzahl <code>width</code> von Sternen ausgegeben werden. Wir m\u00fcssen also die Schleife f\u00fcr die Sterne in die Schleife f\u00fcr die Zeilen einsetzen: </p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    for(int col = 0; col &lt; width; col++)\n    {\n        System.out.print(\"*\");\n    }\n}\n</code></pre> <p>Jetzt heben wir nur noch ein kleines Problem. Nachdem wir unsere Zeile mit Sternen ausgegeben haben, steht der Kursor noch hinter dem zuletzt ausgegebenen Stern. Er sollte danach aber an den Anfang der neuen Zeile wandern. Wir m\u00fcssen also noch f\u00fcr einen Zeilenumbruch sorgen. das erledigen wir mit <code>System.out.println();</code>. Diese Anweisung kommt nach der inneren Schleife in die \u00e4u\u00dfere Schleife. Die gesamte Methode sieht dann so aus:</p> <pre><code>public static void printRectangle(int width, int height)\n{\n    for(int row = 0; row &lt; height; row++)\n    {\n        for(int col = 0; col &lt; width; col++)\n        {\n            System.out.print(\"*\");\n        }\n        System.out.println();\n    }\n}\n</code></pre> <p>Die Zeilen <code>3-10</code> beschreiben die \u00e4u\u00dfere <code>for</code>-Schleife und die Zeilen <code>5-8</code> die innere <code>for</code>-Schleife. Wir \"laufen\" einmal durch den Beginn unseres Programms durch. Angenommen, unsere Methode wird mit der Anweisung <code>printRectangle(23,5);</code> aufgerufen, d.h. die Variable <code>width</code> bekommt den Wert <code>23</code> und die Variable <code>height</code> den Wert <code>5</code> zugewiesen. </p> <ul> <li>Die Laufvariable <code>row</code> bekommt initial den Wert <code>0</code>. <code>0</code>ist kleiner als <code>5</code> und somit ist die Bedingung <code>row &lt; height</code> <code>true</code>. Wir betreten also den Anweisungsblock der \u00e4u\u00dferen Schleife.</li> <li>Die erste Anweisung in diesem Anweisungsblock ist die innere <code>for</code>-Schleife. Diese wird nun vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable <code>col</code> nimmt alle Werte von <code>0</code> bis <code>22</code> an und gibt jedes Mal (also <code>23</code> Mal) einen <code>*</code> aus. Wenn der Wert von <code>col</code> auf <code>23</code> gesetzt wurde, ist die Bedingung <code>col &lt; width</code> nicht mehr <code>true</code> sondern <code>false</code> und die Abarbeitung der Schleife ist beendet. </li> <li>Es wird Zeile <code>9</code> und somit ein Zeilenumbruch ausgef\u00fchrt.</li> <li>Dann wird der Wert von <code>row</code> um <code>1</code> erh\u00f6ht (<code>row++</code>) und hat somit den Wert <code>1</code>. Die Bedingung <code>row &lt; height</code> ist <code>true</code> und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. </li> <li>Wieder ist die erste Anweisung in diesem Anweisungsblock die innere <code>for</code>-Schleife. Diese wird nun wieder vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable <code>col</code> nimmt alle Werte von <code>0</code> bis <code>22</code> an und gibt jedes Mal (also <code>23</code> Mal) einen <code>*</code> aus. Wenn der Wert von <code>col</code> auf <code>23</code> gesetzt wurde, ist die Bedingung <code>col &lt; width</code> nicht mehr <code>true</code> sondern <code>false</code> und die Abarbeitung der Schleife ist beendet. </li> <li>Es wird Zeile <code>9</code> und somit ein Zeilenumbruch ausgef\u00fchrt.</li> <li>Dann wird der Wert von <code>row</code> um <code>1</code> erh\u00f6ht (<code>row++</code>) und hat somit den Wert <code>2</code>. Die Bedingung <code>row &lt; height</code> ist <code>true</code> und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. </li> <li>usw. bis der Wert von <code>row</code> <code>5</code> ist. Dann wird die \u00e4u\u00dfere <code>for</code>-Schleife verlassen und die Abarbeitung der Methode ist beendet. </li> </ul> <p>Wichtig ist, dass die innere Schleife jedes Mal vollst\u00e4ndig abgearbeitet wird, ehe der Zeilenumbruch erfolgt und dann der Wert von <code>row</code> erh\u00f6ht wird. Wir \u00e4ndern die Ausgabe unserer Methode mal ein wenig, um das Prinzip besser zu erkennen:</p> <pre><code>public static void printRectangle(int width, int height)\n{\n    for(int row=0; row&lt;height; row++)\n    {\n        System.out.print(\"(row = \" + row + \"): \");\n        for(int col = 0; col &lt; width; col++)\n        {\n            System.out.print(\"[col = \" + col + \"]\");\n        }\n        System.out.println();\n    }\n}\n</code></pre> <p>F\u00fcr den Aufruf der Methode <code>printRectangle(10,5);</code> erhalten wir dann folgende Ausgabe: </p> <pre><code>(row = 0): [col = 0][col = 1][col = 2][col = 3][col = 4][col = 5][col = 6][col = 7][col = 8][col = 9]\n(row = 1): [col = 0][col = 1][col = 2][col = 3][col = 4][col = 5][col = 6][col = 7][col = 8][col = 9]\n(row = 2): [col = 0][col = 1][col = 2][col = 3][col = 4][col = 5][col = 6][col = 7][col = 8][col = 9]\n(row = 3): [col = 0][col = 1][col = 2][col = 3][col = 4][col = 5][col = 6][col = 7][col = 8][col = 9]\n(row = 4): [col = 0][col = 1][col = 2][col = 3][col = 4][col = 5][col = 6][col = 7][col = 8][col = 9]\n</code></pre> <p>Durch die Verschachtelung der <code>for</code>-Schleife erzeugen wir somit eine 2-dimensionale Ausgabe. Die innere Schleife entwickelt die horizontale Dimension (eine Zeile mit <code>width</code> Sternen) und die \u00e4u\u00dfere <code>for</code>-Schleife entwickelt entwickelt die vertikale Dimension (<code>height</code> viele Zeilen). </p> <p>Wir schauen uns noch ein Beispiel an. Nun ist die Bedingung der inneren Schleife vom Wert der Alufvariablen der \u00e4u\u00dferen Schleife abh\u00e4ngig. </p>"},{"location":"iteration/#dreieck","title":"Dreieck","text":"<p>Angenommen, wir wollen ein gleichschenkliges rechteckiges Dreieck erzeugen. Dazu \u00fcbergeben wir die H\u00f6he des Dreiecks als Wert. Angenommen, wir wollen ein Dreieck der H\u00f6he <code>7</code>, dann soll folgende Ausgabe erscheinen:</p> <pre><code>*\n**\n***\n****\n*****\n******\n*******\n</code></pre> <p>Unsere \u00e4u\u00dfere Schleife wird sicherlich so aussehen, wie unsere \u00e4u\u00dfere Schleife beim Rechteck. Angenommen, unsere H\u00f6he ist in der Variablen <code>height</code> gespeichert, dann m\u00fcssen wir <code>height</code> viele Zeilen ausgeben:</p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    // Hier soll jetzt eine Zeile ausgegeben werden\n}\n</code></pre> <p>Daran hat sich also nichts ge\u00e4ndert, aber die innere Schleife sieht sicherlich anders aus, denn wir haben keine <code>width</code>-Variable mehr. Die Anzahl der Sterne in einer Zeile ist nicht konstant, sondern h\u00e4ngt davon ab, in welcher Zeile wir uns befinden:</p> <pre><code>Zeile 1:  row == 0:  1 Stern  ausgeben\nZeile 2:  row == 1:  2 Sterne ausgeben\nZeile 3:  row == 2:  3 Sterne ausgeben\nZeile 4:  row == 3:  4 Sterne ausgeben\nZeile 5:  row == 4:  5 Sterne ausgeben\nZeile 6:  row == 5:  6 Sterne ausgeben\nZeile 7:  row == 6:  7 Sterne ausgeben\n</code></pre> <p>Das bedeutet, die Bedingung der inneren Schleife muss sich \u00e4ndern. Sie muss abh\u00e4ngig sein vom Wert von <code>row</code>:</p> <pre><code>for(int col = 0; col &lt;= row; col++)\n{\n    System.out.print(\"*\");\n}\n</code></pre> <p>Wenn <code>row</code> den </p> <ul> <li>Wert <code>0</code> hat, wird die Schleife <code>1</code> Mal durchlaufen, </li> <li>Wert <code>1</code> hat, wird die Schleife <code>2</code> Mal durchlaufen, </li> <li>Wert <code>2</code> hat, wird die Schleife <code>3</code> Mal durchlaufen, </li> <li>usw. </li> </ul> <p>Die gesamte Methode sieht dann so aus:</p> <pre><code>public static void printTriangle(int height)\n{\n    for(int row=0; row&lt;height; row++)\n    {\n        for(int col = 0; col &lt;= row; col++)\n        {\n            System.out.print(\"*\");\n        }\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"iteration/#2-schleifen-in-einer-schleife","title":"2 Schleifen in einer Schleife","text":"<p>Wir betrachten noch ein letztes Beispiel. Wir k\u00f6nnten Schleifen nat\u00fcrlich noch weiter verschachteln, also noch eine weitere Schleife in der inneren Schleife implementieren. Das ist m\u00f6glich, wird aber schnell un\u00fcbersichtlich. Prinzipiell ist die Verschachtelungstiefe aber unbegrenzt endlich. Stattdessen wollen wir uns in unserem letzten Beispiel aber einmal \u00fcberlegen, wie wir erneut ein gleichschenkliges rechtwinkliges Dreieck erzeugen k\u00f6nnten. Dieses Mal soll es aber nicht \"linksb\u00fcndig\", sondern \"rechtsb\u00fcndig\" sein, also so:</p> <pre><code>      *\n     **\n    ***\n   ****\n  *****\n ******\n*******\n</code></pre> <p>Der Unterschied zum oberen Beispiel ist der, dass wir nun immer erst eine bestimmte Anzahl an Leerzeichen ausgeben m\u00fcssen, ehe wir den ersten Stern ausgeben. Dazu \u00fcberlegen wir uns wieder die Abh\u00e4ngigkeiten f\u00fcr ein Dreieck der H\u00f6he <code>7</code>:</p> <pre><code>Zeile 1:  row == 0:  6 Leerzeichen ausgeben + 1 Stern  ausgeben     (height == 7)\nZeile 2:  row == 1:  5 Leerzeichen ausgeben + 2 Sterne ausgeben     (height == 7)\nZeile 3:  row == 2:  4 Leerzeichen ausgeben + 3 Sterne ausgeben     (height == 7)\nZeile 4:  row == 3:  3 Leerzeichen ausgeben + 4 Sterne ausgeben     (height == 7)\nZeile 5:  row == 4:  2 Leerzeichen ausgeben + 5 Sterne ausgeben     (height == 7)\nZeile 6:  row == 5:  1 Leerzeichen ausgeben + 6 Sterne ausgeben     (height == 7)\nZeile 7:  row == 6:  0 Leerzeichen ausgeben + 7 Sterne ausgeben     (height == 7)\n</code></pre> <p>Die \u00e4u\u00dfere Schleife bleibt wieder so wie vorher:</p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    // Hier soll jetzt eine Zeile ausgegeben werden\n}\n</code></pre> <p>Allerdings ist die Ausgabe einer Zeile nun in 2 Aufgaben zerlegt. Zuerst eine bestimmte Anzahl von Leerzeichen ausgeben und dann eine bestimmte Anzahl von Sternen:</p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden\n\n    // dann wird eine bestimmte Anzahl von Sternen ausgegeben\n}\n</code></pre> <p>F\u00fcr die Anzahl von Sternen haben wir bereits eine L\u00f6sung, die wir verwenden k\u00f6nnen:</p> <pre><code>for(int col = 0; col &lt;= row; col++)\n{\n    System.out.print(\"*\");\n}\n</code></pre> <p>Diese Schleife k\u00f6nnen wir schonmal in unsere \u00e4u\u00dfere Schleife einsetzen:</p> <pre><code>for(int row = 0; row &lt; height; row++)\n{\n    // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden\n\n    for(int col = 0; col &lt;= row; col++)\n    {\n        System.out.print(\"*\");\n    }\n}\n</code></pre> <p>So wie die Anzahl von Sternen abh\u00e4ngig von der Zeile ist, in der wir die Sterne ausgeben, so ist auch die Anzahl der Leerzeichen davon abh\u00e4ngig. Allerdings beginnen wir mit einem gr\u00f6\u00dferen Wert und werden dann immer kleiner (von <code>6</code> bis <code>0</code> bei der H\u00f6he <code>height==7</code>). Die Anzahl der auszugebenden Leerzeichen ist also einerseits abh\u00e4ngig von der Gesamth\u00f6he (<code>height</code>) und andererseits von der aktuellen Zeile <code>row</code>. Wir \u00fcberlegen uns, mit welchem Startwert wir beginnen: am Anfang wollen wir <code>6</code> leerzeichen ausgeben, das sind <code>height-1</code> viele. Danach ziehen wir von diesem Wert immer so viele ab, wie <code>row</code> gro\u00df ist, also erst <code>-0</code>, dann <code>-1</code>, dann <code>-2</code> usw. Der Startwert ist also <code>height -1 - row</code>. In der letzten Zeile hat <code>row</code> den Wert <code>6</code>. Dann w\u00e4re unser Startwert <code>height -1 - 6 == 7 - 1 - 6 == 0</code>. In der letzten Zeile wollen wir aber gar kein Leerzeichen mehr ausgeben, also muss dort schon unsere Bedingung <code>false</code> sein. Also setzen wir die Bedingung auf <code>&gt;0</code>. Die Schleife f\u00fcr die Ausgabe der Leerzeichen ist dann wie folgt:</p> <pre><code>for(int spaces = height -1 -row; spaces &gt; 0; spaces--)\n{\n    System.out.print(\" \");\n}\n</code></pre> <p>F\u00fcr viele ist eine solche Schleife schwer zu lesen, da sich der Wert der ALufvariablen reduziert und die Ermittlung des Initialwertes gleich 2 Subtraktionen enth\u00e4lt. Wir haben ja bereits eingangs gesagt, dass eine solche Schleife auch \u00e4quivalent in anderer Form geschrieben werden kann. Das gleiche Ergebnis erhalten wir mit der folgenden Implementierung:</p> <pre><code>for(int spaces = 1; spaces &lt; height - row; spaces++)\n{\n    System.out.print(\" \");\n}\n</code></pre> \u00dcbung Schleife, initaile Werte und Bedingungen <p>Warum sind die beiden oberen Schleifen identisch?  Warum sind die beiden folgenden Schleifen nur fast identisch? Was ist der Unterschied in den Beispielen? <pre><code>for(int i=0; i&lt;5; i++)\n{\n    System.out.println(i);\n}\n</code></pre> <pre><code>for(int i=5; i&gt;0; i--)\n{\n    System.out.println(i);\n}\n</code></pre></p> <p>Die gesamte Methode sieht dann so aus:</p> <pre><code>public static void printTriangleR(int height)\n{\n    for(int row=0; row&lt;height; row++)\n    {\n        for(int spaces = 1; spaces &lt; height - row; spaces++)\n        {\n            System.out.print(\" \");\n        }\n        for(int col = 0; col &lt;= row; col++)\n        {\n            System.out.print(\"*\");\n        }\n        System.out.println();\n    }\n}\n</code></pre> \u00dcbung linksb\u00fcndiges Dreieck <p>Schreiben Sie die Methode <code>printTriangle(int height)</code> so um, dass bei z.B. <code>printTriangle(7);</code> nicht folgende Ausgabe ensteht: <pre><code>*\n**\n***\n****\n*****\n******\n*******\n</code></pre> sondern folgende: <pre><code>* \n* * \n* * * \n* * * * \n* * * * * \n* * * * * * \n* * * * * * * \n</code></pre></p> \u00dcbung rechtsb\u00fcndiges Dreieck <p>Schreiben Sie die Methode <code>printTriangleR(int height)</code> so um, dass bei z.B. <code>printTriangleR(7);</code> nicht folgende Ausgabe ensteht: <pre><code>      *\n     **\n    ***\n   ****\n  *****\n ******\n*******\n</code></pre> sondern folgende: <pre><code>            * \n          * * \n        * * * \n      * * * * \n    * * * * * \n  * * * * * * \n* * * * * * * \n</code></pre></p> <p>Success</p> <p>Wir haben <code>for</code>-Schleifen kennengelernt und k\u00f6nnen damit nun auch Iterationen implementieren. <code>for</code>-Schleifen verwenden wir, wenn wir einen Anweisungsblock eine bestimmte Anzahl oft wiederholt ausf\u00fchren m\u00f6chten. Wir haben auch <code>for</code>-Schleifen verschachtelt, um variabel in mehrere Dimensionen zu sein. und wir haben mehrere <code>for</code>-Schleifen innerhalb einer <code>for</code>-Schleife verwendet. Nun lernen wir noch zwei weitere Schleifen kennen.</p>"},{"location":"iteration/#die-while-schleife","title":"Die <code>while</code>-Schleife.","text":"<p>W\u00e4hrend die Anzahl der Ausf\u00fchrungen einer <code>for</code>-Schleife von einem numerischen Wert festgelegt wird, ist die Anzahl der Ausf\u00fchrungen einer <code>while</code>-Schleife von einem logischen Ausdruck abh\u00e4ngig. Prinzipiell muss man jedoch sagen, dass es auch v\u00f6llig gen\u00fcgen w\u00fcrde, wenn man nur <code>for</code>-Schleifen oder nur <code>while</code>-Schleifen in einer Programmiersprache zur Verf\u00fcgung h\u00e4tte. Man kann mit beiden Schleifenarten (und sp\u00e4ter auch mit der <code>do..while</code>-Schleife) alle Iterationen implemnetieren, die programmierbar sind. </p> <p>Schauen wir uns zun\u00e4chst die allgemeine Syntax einer <code>while</code>-Schleife an:</p> <pre><code>while(BEDINGUNG)\n{\n    /*\n     * Anweisungsblock, der wiederholt\n     * werden soll\n     */\n}\n</code></pre> <p>Eine <code>while</code>-Schleife ist also auf den ersten Blick weniger komplex als eine <code>for</code>-Schleife. Da wir aber gesagt haben, dass man mit beiden Schleifenarten die gleichen Programme umsetzen kann, schauen wir uns die ersten Beispiele der <code>for</code>-Schleife mal als <code>while</code>-Schleife an:</p> <pre><code>int i=0;\nwhile(i&lt;5)\n{\n    System.out.println(i);\n    i++;\n} \n</code></pre> <p>Diese <code>while</code>-Schleife macht genau das gleiche, wie unser erstes Beispiel f\u00fcr die <code>for</code>-Schleife. Es wird eine Variable <code>i</code> deklariert und mit <code>0</code> initialisiert. Als Bedingung unserer <code>while</code>-Schleife wird gepr\u00fcft, ob der Wert von <code>i</code> kleiner als <code>5</code> ist. Wenn ja, wird dieser Wert ausgegeben und der Wert von <code>i</code> um <code>1</code> erh\u00f6ht. Nun wird wieder gepr\u00fcft, ob der Wert von <code>i</code>immer noch kleiner als <code>5</code> ist. Wenn ja, wird der Wert ausgegeben und um <code>1</code>erh\u00f6ht usw. </p> <p>Es scheint zun\u00e4chst, als w\u00e4re diese beiden Schleifenarten v\u00f6llig redundant. Was bedeutet es nun, dass eine <code>for</code>-Schleife von einer bestimmten Anzahl und eine <code>while</code>-Schleife von einer Bedingung abh\u00e4ngig ist? Sehen wir uns dazu nochmal unsere beiden Beispielalgorithmen vom Anfang an:</p> <ul> <li>der Euklidische Algrorithmus und </li> <li>die (3n+1)-Vermutung (Collatz-Problem)</li> </ul> <p>Die Beschreibung der Iteration beim Eukidischen Algorithmus war <code>solange a ungleich b ist, wiederhole</code>. Das bedeutet, dass die Bedingung f\u00fcr die Schleifenwiederholung <code>a ungleich b</code> ist. Nach wieviel Wiederholungen (also nach welcher Anzahl) l\u00e4sst sich nicht sagen. Es l\u00e4sst sich aber leicht die Bedingung formulieren, die gelten soll, damit die Schleife erneut ausgef\u00fchrt wird, n\u00e4mlich <code>(a!=b)</code>. </p> <p>Das gleiche gilt f\u00fcr die (3n+1)-Vermutung. Dort lautet die Beschreibung der Iteration <code>solange n ungleich 1 ist, wiederhole</code>. Nach wieviel Wiederholungen (also nach welcher Anzahl) l\u00e4sst sich vorher nicht sagen, aber die Bedingung daf\u00fcr, dass die Schleife erneut wiederholt werden soll, l\u00e4sst sich leicht formulieren, n\u00e4mlich <code>(n!=1)</code>. </p>"},{"location":"iteration/#implementierung-des-euklidischen-algorithmus","title":"Implementierung des Euklidischen Algorithmus","text":"<p>Mithilfe der <code>while</code>-Schleife implementieren wir nun mal beide Allgorithmen. Zuerst den Euklidischen Algorithmus:</p> Berechnung des ggT nach Euklid <pre><code>public static void berechneGGT(int a, int b)\n{\n    while(a != b)\n    {\n        if(a &gt; b)\n        {\n            a = a -b;\n        }\n        else \n        {\n            b = b - a;\n        }\n    }\n    System.out.println(\"ggT: \" + a);\n}\n</code></pre> <p>Die Ausgabe f\u00fcr z.B. <code>berechneGGT(24, 40);</code> ist <code>8</code>. </p> <p>Ver\u00e4nderung der Werte von Parametern in Methoden</p> <p>In unserer Methode zur Berechnung des gr\u00f6\u00dften gemeinsamen Teilers nach Euklid haben wir die Werte der Parameter <code>a</code> und <code>b</code> innerhalb unserer Methode ge\u00e4ndert (siehe <code>a = a -b;</code> und <code>b = b - a;</code>). Das ist kein guter Stil! So haben wir z.B. nicht die M\u00f6glichkeit, am Ende der Methode eine Ausgabe der Form <code>Der ggT von 24 und 40 ist 8.</code> zu erstellen, da wir auf die Werte <code>24</code> (von <code>a</code>) und <code>40</code> (von <code>b</code>) keinen Zugriff mehr haben. Wir sollten uns angew\u00f6hnen, die Parameterwerte in Methoden nicht zu \u00e4ndern, sondern lieber mit Kopien der Werte zu rechnen. Sp\u00e4ter werden wir unsere Parameter als Konstanten definieren, dann ist eine \u00c4nderung gar nicht m\u00f6glich. Das folgende Beispiel zeigt eine bessere L\u00f6sung:</p> Berechnung des ggT nach Euklid (ohne \u00c4nderung der Parameterwerte) <pre><code>public static void berechneGGT(int a, int b)\n{   \n    int nr1 = a;\n    int nr2 = b;\n    while(nr1 != nr2)\n    {\n        if(nr1 &gt; nr2)\n        {\n            nr1 = nr1 - nr2;\n        }\n        else \n        {\n            nr2 = nr2 - nr1;\n        }\n    }\n    System.out.println(\"Der ggT von \" + a + \" und \" + b + \" ist \" + nr1);\n}\n</code></pre> <p>Die Ausgabe f\u00fcr z.B. <code>berechneGGT(24, 40);</code> ist nun <code>Der ggT von 24 und 40 ist 8</code>. </p>"},{"location":"iteration/#implementierung-der-3n1-vermutung","title":"Implementierung der (3n+1)-Vermutung","text":"<p>Mithilfe der <code>while</code>-Schleife k\u00f6nnen wir nun auch die (3n+1)-Vermutung (Collatz-Problem) geeignet implementieren:</p> <pre><code>public static void printCollatzFolge(int n)\n{\n    int number = n;\n    while(number != 1)\n    {\n        System.out.print(number + \" \");\n        if(number%2 == 0)\n        {\n            number = number/2;\n        }\n        else\n        {\n            number = 3*number+1;\n        }\n    }\n    System.out.println(number);\n}\n</code></pre> <p>Auch hier kopieren wir zun\u00e4chst den Wert des Parameters, um diesen nicht zu \u00e4ndern. Mithilfe von <code>number%2 == 0</code> pr\u00fcfen wir, ob <code>number</code> gerade oder ungerade ist. Ist <code>number</code> gerade, teilen wir den Wert durch <code>2</code>, ist <code>number</code> ungerade, multiplizieren wir den Wert mit <code>3</code> und addieren <code>1</code>, um jeweils den Nachfolger zu ermitteln. Solange dieser NAchfolger ungleich <code>1</code> ist, wird der n\u00e4chste Nachfolger berechnet usw. </p> <p>Die Ausf\u00fchrung der methode mit z.B. <code>printCollatzFolge(17);</code> erzeugt folgende Ausgabe: <code>17 52 26 13 40 20 10 5 16 8 4 2 1</code>. Wir beginnen mit <code>17</code>. Diese Zahl ist ungerade, also ist der Nachfolger <code>52</code>. Diese Zahl und auch der Nachfolger <code>26</code> sind gerade. Der n\u00e4chste Nachfolger <code>13</code> ist ungerade, dann kommen drei gerade Zahlen <code>40</code>, <code>20</code> und <code>10</code> und erst dann wieder eine ungerade Zahl <code>5</code>. <code>16</code> ist dann aber schon eine Potenz von <code>2</code> und somit endet die Folge mit der <code>1</code>. </p> \u00dcbungen <code>while</code>-Schleife <p>Nat\u00fcrlich kann eine <code>while</code>-Schleife genau wie die <code>for</code>-Schleife verschachtelt werden.  Implementieren Sie </p> <ul> <li>das Rechteck</li> <li>das linksb\u00fcndige Dreieck und</li> <li>das rechtsb\u00fcndige Dreieck </li> </ul> <p>mithilfe von verschachtelten <code>while</code>-Schleifen.</p>"},{"location":"iteration/#die-dowhile-schleife","title":"Die <code>do...while</code>-Schleife","text":"<p>Wir haben ja bereits bei den <code>for</code>- und <code>while</code>-Schleifen erw\u00e4hnt, dass eines der beiden Konzepte gen\u00fcgt h\u00e4tte, um alle Iterationen zu implementieren. Da man aber ganz gute Unterscheidungsm\u00f6glichkeiten hat, um sich entweder f\u00fcr die <code>for</code>-Schleife (bestimmte Anzahl) oder f\u00fcr die <code>while</code>-Schleife (bestimmte Bedingung) zu entscheiden, haben beide Schleifenarten ihre Berechtigungsexistenz. F\u00fcr die <code>do ... while</code> f\u00e4llt die Abgrenzung zur <code>while</code>-Schleife noch schwerer. Generell l\u00e4sst sich sagen, dass eine <code>while</code>-Schleife nicht unebdingt ausgef\u00fchrt werden muss (n\u00e4mlich dann, wenn die Bedingung bereits ganz zu Anfang schon <code>false</code> ist), eine <code>do ... while</code>-Schleife wird aber zumindest ein Mal ausgef\u00fchrt, da die Pr\u00fcfung der Bedingung erst nach dem Schleifendurchlauf erfolgt. Die allgemeine Syntax einer <code>do ... while</code>-Schleife ist wie folgt: </p> <p><pre><code>do\n{\n    /*\n     * Anweisungsblock, der wiederholt\n     * werden soll\n     */\n}\nwhile(BEDINGUNG);\n</code></pre> Beachten Sie das Semikolon hinter der Bedingung! Es gibt Beispiele f\u00fcr den sinnvollen Einsatz von <code>do ... while</code>-Schleifen, z.B. wenn innerhalb der Schleife eine Eingabe erfolgt und die Bedingung pr\u00fcft, ob es sich um eine korrekte Eingabe handelt. Wir werden uns aber zun\u00e4chst nicht weiter um diese Schleife k\u00fcmmern, da sie nicht wirklich notwendig ist und wir uns haupts\u00e4chlich mit <code>for</code>- und <code>while</code>-Schleifen besch\u00e4ftigen werden. </p>"},{"location":"iteration/#break-und-continue","title":"<code>break</code> und <code>continue</code>","text":"<p><code>break</code> und <code>continue</code></p> <p>In (fast) allen Java-B\u00fcchern liest man in dem Kapitel \u00fcber Schleifen auch davon, dass es die beiden Anweisungen <code>break;</code> und <code>continue;</code> gibt. Ich will hier gar nicht darauf eigehen, was diese beiden Anweisungen machen, nur so viel: sie springen aus Schleifen heraus. Solche Art von \"Spr\u00fcngen\" (go to statements) geh\u00f6ren nicht in moderne, gute Programme. Wir nutzen diese Anweisungen nicht!!! Stattdessen sei in diesem Zusammenhang ein ber\u00fchmtes Papier von Edsger W. Dijkstra empfohlen: Go To Statement Considered Harmful. Siehe dazu auch hier. </p>"},{"location":"javadoc/","title":"Javadoc","text":"<p>Javadoc ist ein Werkzeug, das Teil des Java Development Kit (JDK) ist. Es erzeugt aus Javadoc-Kommentaren HTML-Seiten, die im Browser aufgerufen werden k\u00f6nnen. Die Javadoc-Kommentare aller Klassen aus den Java-Standardpaketen finden Sie z.B. hier (Java Version 11).</p> <p>Ein Javadoc-Kommentar beginnt mit <code>/**</code> und endet mit <code>*/</code>. Ein solcher Kommentar kann sich \u00fcber mehrer Zeilen erstrecken. Hier nochmal die drei M\u00f6glichkeiten der Kommentierung in Java:</p> <pre><code>// einzeiliger Kommentar - Kommentar endet am Zeilenende\n\n/*\n\n    Blockkommentar\n    kann sich \u00fcber mehrer Zeilen erstrecken\n\n*/\n\n/**\n    Javadoc-Kommentar\n    wie Blockkommentar \u00fcber mehrere Zeilen\n    aus Javadoc-Kommentaren erzeugt javadoc \n    HTML-Seiten\n\n*/\n</code></pre> <p>Eine Anleitung dazu, wie Javadoc-Kommentare geschrieben werden sollten, findet sich hier. Diese Anleitung enth\u00e4lt auch n\u00fctzliche Beispiele. </p>"},{"location":"javadoc/#ein-einfaches-beispiel","title":"Ein einfaches Beispiel","text":"<p>Wir wollen die Dokumentation an einem (sehr) einfachen Beispiel erl\u00e4utern. Gegeben sei folgende Klasse <code>Akku.java</code>.</p> <pre><code>    package akku;\n\n    public class Akku {\n        private String typ;\n        private int kapazitaet;\n        private int anzahlLadungen;\n\n        public Akku(String typ, int kapazitaet)\n        {\n            this.typ = typ;\n            this.kapazitaet = kapazitaet;\n            this.anzahlLadungen = 0;\n        }\n\n        public void laden()\n        {\n            this.anzahlLadungen++;\n        }\n\n        public int getZustand()\n        {\n            int zustand = 100;\n            zustand = (zustand - (this.anzahlLadungen/100));\n            if(zustand &lt; 0) zustand = 0;\n            return zustand;\n        }\n\n        @Override\n        public String toString()\n        {\n            String s = String.format(\"%-4s: %5dmAh %5d Ladungen. Zustand %3d%% %n\", this.typ, this.kapazitaet, this.anzahlLadungen, this.getZustand());\n            return s;\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if(o == null) return false;\n            if(this == o) return true;\n            if(o.getClass() != this.getClass()) return false;\n\n            Akku a = (Akku)o;\n            return a.typ.equals(this.typ);\n        }\n\n        public void print()\n        {\n            System.out.print(this.toString());\n        }\n\n    }\n</code></pre>"},{"location":"javadoc/#javadoc-kommentierung-des-beispiels","title":"Javadoc-Kommentierung des Beispiels","text":"<p>Wir schauen uns zun\u00e4chst mal eine m\u00f6gliche (nicht wirklich gute, z.B. weil es nicht auf Englisch ist) Javadoc-Kommentierung an und betrachten dann Einzelheiten:</p> <pre><code>package akku;\n\n/**\n * Ein Objekt der Klasse &lt;code&gt;Akku&lt;/code&gt; beschreibt ein wiederaufladbares Geraet, \n * einen Akkumulator.\n * Objekte der Klasse sind spezifiziert durch den Typ, die Kapazitaet (wieviel Stunden \n * Entladzeit bei gegebenem Entladestrom) und der Anzahl der bisherigen Ladungen.\n * @author jornfreiheit\n * @version 1.0\n */\npublic class Akku {\n    /**\n     * Der Typ eines &lt;code&gt;Akku&lt;/code&gt;-Objektes.\n     */\n    private String typ;\n    /**\n     * Die Kapazitaet eines &lt;code&gt;Akku&lt;/code&gt;-Objektes in Ah.\n     */\n    private int kapazitaet;\n    /**\n     * Die Anzahl bisheriger Ladungen eines &lt;code&gt;Akku&lt;/code&gt;-Objektes.\n     */\n    private int anzahlLadungen;\n\n    /**\n     * Konstruktor; erzeugt ein &lt;code&gt;Akku&lt;/code&gt;-Objekt. Das erzeugte &lt;code&gt;Akku&lt;/code&gt;-Objekt\n     * ist bisher noch nicht geladen worden (&lt;code&gt;anzahlLadungen&lt;/code&gt; initial &lt;code&gt;0&lt;/code&gt;\n     * @param typ: initiiert den Wert von &lt;code&gt;typ&lt;/code&gt; des &lt;code&gt;Akku&lt;/code&gt;-Objektes\n     * @param kapazitaet: initiiert den Wert von &lt;code&gt;kapazitaet&lt;/code&gt; des &lt;code&gt;Akku&lt;/code&gt;-Objektes\n     */\n    public Akku(String typ, int kapazitaet)\n    {\n        this.typ = typ;\n        this.kapazitaet = kapazitaet;\n        this.anzahlLadungen = 0;\n    }\n\n    /**\n     * erhoeht die Anzahl bisheriger Ladungen um 1 \n     * der um 1 erhoehte Wert wird in &lt;code&gt;anzahlLadungen&lt;/code&gt; gespeichert\n     */\n    public void laden()\n    {\n        this.anzahlLadungen++;\n    }\n\n\n    /**\n     * berechnet den Zustand des &lt;code&gt;Akku&lt;/code&gt;-Objektes und\n     * gibt diesen zurueck.\n     * Der Zustand wird in Prozent ermittelt. Initial hat ein \n     * (bis dahin nie aufgeladenes) &lt;code&gt;Akku&lt;/code&gt;-Objekt den Zustand \n     * &lt;code&gt;100%%&lt;/code&gt;. Fuer alle &lt;code&gt;100&lt;/code&gt; Ladungen reduziert sich\n     * der Zustand um &lt;code&gt;1%%&lt;/code&gt;. Das bedeutet, fuer &lt;code&gt;1000&lt;/code&gt; Ladungen reduziert sich\n     * der Zustand um &lt;code&gt;10%%&lt;/code&gt;. Nach &lt;code&gt;10000&lt;/code&gt; Ladungen ist\n     * der Zustand bei &lt;code&gt;0%%&lt;/code&gt; und somit ist das &lt;code&gt;Akku&lt;/code&gt;-Objekt\n     * nicht mehr nutzbar.\n     * \n     * @return berechneten Zustand in Prozent\n     */\n    public int getZustand()\n    {\n        int zustand = 100;\n        zustand = (zustand - (this.anzahlLadungen/100));\n        if(zustand &lt; 0) zustand = 0;\n        return zustand;\n    }\n\n    /**\n     * Ueberschreibt die {@link Object#toString()}-Methode der Klasse &lt;code&gt;Object&lt;/code&gt;\n     * Gibt einen &lt;code&gt;String&lt;/code&gt; der Form\n     * &lt;code&gt;A1  : 10000mAh   984 Ladungen. Zustand  91%&lt;/code&gt;\n     * wobei \n     * &lt;ul&gt;\n     *  &lt;li&gt;&lt;code&gt;A1&lt;/code&gt; ein &lt;code&gt;typ&lt;/code&gt; ist, &lt;/li&gt; \n     *  &lt;li&gt;&lt;code&gt;10000&lt;/code&gt; ist die &lt;code&gt;kapazitaet&lt;/code&gt;, &lt;/li&gt;\n     *  &lt;li&gt;&lt;code&gt;984&lt;/code&gt; sind die &lt;code&gt;anzahlLadungen&lt;/code&gt; und &lt;/li&gt;\n     *  &lt;li&gt;&lt;code&gt;91%&lt;/code&gt; der berechnete Zustand &lt;code&gt;getZustand()&lt;/code&gt;.&lt;/li&gt;\n     * &lt;/ul&gt;\n     * @return String, der die Werte eines &lt;code&gt;Akku&lt;/code&gt;-Objektes enthaelt\n     */\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%-4s: %5dmAh %5d Ladungen. Zustand %3d%% %n\", this.typ, this.kapazitaet, this.anzahlLadungen, this.getZustand());\n        return s;\n    }\n\n    /**\n     * Ueberschreibt die {@link Object#equals(Object o)}-Methode der Klasse &lt;code&gt;Object&lt;/code&gt;\n     * Gibt &lt;code&gt;true&lt;/code&gt; zurueck, wenn das aufrufende &lt;code&gt;Akku&lt;/code&gt;-Objekt\n     * gleich dem als Parameter uebergebenden &lt;code&gt;Akku&lt;/code&gt;-Objektes ist.\n     * Gibt &lt;code&gt;false&lt;/code&gt; zurueck sonst.\n     * Zwei &lt;code&gt;Akku&lt;/code&gt;-Objekte sind gleich, wenn sie den gleichen &lt;code&gt;typ&lt;/code&gt;\n     * haben.\n     * @return &lt;code&gt;true&lt;/code&gt; wenn gleich, &lt;code&gt;false&lt;/code&gt; sonst.\n     */\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(o.getClass() != this.getClass()) return false;\n\n        Akku a = (Akku)o;\n        return a.typ.equals(this.typ);\n    }\n\n    /**\n     * gibt den von {@link toString()} erzeugten &lt;code&gt;String&lt;/code&gt; auf\n     * die Konsole aus\n     */\n    public void print()\n    {\n        System.out.print(this.toString());\n    }\n\n}\n</code></pre> <p>Wichtig ist auch, dass Sie auch das Modul (Ihr Java-Projekt) kommentieren k\u00f6nnen und auch jedes einzelne Package darin. Um das Package zu kommentieren, erstellen Sie in Ihrem Package eine <code>package-info.java</code> und f\u00fcgen darin Ihre Javadoc-Kommentare ein. Um Ihr Modul (Ihr Java-Projekt) zu kommentieren, f\u00fcgen Sie in die <code>module-info.java</code> den Javadoc-Kommentar ein, z.B. </p> module-info.java <pre><code>/**\n * Dieses Modul enthaelt die Klassen Akku und AkkuBestand. \n * AkkuBestand implementiert ein Array von Akkus.\n * \n * @author J. Freiheit\n * @version 1.0\n */\nmodule JavadocBeispiel\n{\n}\n</code></pre>"},{"location":"javadoc/#generate-javadoc","title":"Generate Javadoc...","text":"<p>Wenn Sie mit der Javadoc-Kommentierung fertig sind, dann w\u00e4hlen Sie in Eclipse im Men\u00fcpunkt <code>Project</code> den Men\u00fceintrag <code>Generate Javadoc...</code>. Es erscheint folgendes Fenster:</p> <p></p> <p>Hier k\u00f6nnen Sie insbesondere ausw\u00e4hlen, f\u00fcr welches Java-Projekt Sie die Javadoc-Dokumentation erzeugen lassen m\u00f6chten. Es ist auch die Auswahl von Paketen und Klassen m\u00f6glich. Au\u00dferdem werden in der Standardeinstellung nur die Dokumentationen f\u00fcr <code>public</code> Eigenschaften erzeugt, also f\u00fcr als <code>public</code> deklarierte Methoden und Objektvariablen. Auch das l\u00e4sst sich in dieser Eingabemaske \u00e4ndern. Nachdem Sie <code>Finish</code> geklickt haben, erscheint in der Konsole so etwas wie:</p> <pre><code>Loading source files for package akku...\nConstructing Javadoc information...\nStandard Doclet version 15.0.1+9-18\nBuilding tree for all the packages and classes...\n</code></pre> <p>gefolgt von einer Liste aller <code>.html</code>-Dateien, die erzeugt werden. Eventuell gibt es jedoch auch Fehlerausgaben, die Sie erst noch beheben m\u00fcssen. Nachdem alle <code>.html</code>-Dateien erzeugt wurden, gibt es in Ihrem Workspace in dem Projektordner, dessen Javadoc-Dokumentation Sie gerade erzeugt haben, einen neuen Ordner <code>doc</code>:</p> <p></p> <p>In diesem Ordner befinden sich mehrer <code>.html</code>-Dateien (und Ordner und <code>.js</code>- sowie <code>.css</code>-Datein). \u00d6ffnen Sie die <code>index.html</code> durch Doppelklick. Diese \u00f6ffnet sich im Browser und es erscheint folgende Ansicht:</p> <p></p> <p>Klicken Sie darin auf den Button <code>Package</code> und es erscheint:</p> <p></p> <p>Klicken Sie auf die Klasse <code>Akku</code> und es erscheint:</p> <p></p>"},{"location":"javadoc/#tags","title":"Tags","text":"<p>Wie Sie in den Kommentaren vielleicht erkannt haben, gibt es darin einige <code>@</code> gefolgt von Schl\u00fcsselw\u00f6rtern. Dabei handelt es sich um sogenannte Tags. Hier eine Liste der Tags, die wir verwendet haben:</p> <ul> <li>@author - f\u00fcr den/die Programmierer_innen des Codes; bei mehreren Autor_innen entweder je Autor_in mit <code>@author</code>-Tag oder Autor_innennamen durch Komma getrennt, siehe auch hier</li> <li>@version - gibt die Version des Codes an, siehe auch hier</li> <li>@param - beschreibt einen Parameter der Methode; f\u00fcr jeden Parameter wird ein eigener <code>@param</code>-Tag verwendet; siehe auch hier</li> <li>@return - beschreibt die R\u00fcckgabe einer Methode mit R\u00fcckgabetyp; auch den Wertebereich der R\u00fcckgabe erl\u00e4utern; siehe auch hier</li> </ul>"},{"location":"javadoc/#weitere-tags","title":"Weitere Tags","text":"<p>Mit den oben genannten Tags k\u00f6nnen Klassen bereits gut dokumentiert werden. Es gibt jedoch noch weitere Tags, die wir hier kurz auflisten wollen (Liste ist aber nicht vollst\u00e4ndig):</p> <ul> <li>@deprecated - kennzeichnet, dass diese Klasse oder Methode nicht weiter genutzt werden soll, siehe auch hier und hier</li> <li>@throws - synonym zu <code>@exception</code>; in Verbindung zu der Exception (den Exceptions), die durch eine Methode geworfen werden kann/k\u00f6nnen und f\u00fcr welche F\u00e4lle die jeweilige Exception geworfen wird, siehe auch hier</li> <li>@see - erstellt einen Link zu einer Klasse, Methode, etc. in der API-Dokumentation (Syntax: <code>@see  package.class#member  label</code>, wobei <code>label</code> sichtbar und <code>package.class#member</code> der Link), siehe auch hier; <code>@see</code> ist \u00e4hnlich zu {@ link}, aber ein <code>{@link}</code> beschreibt einen In-line-Link, w\u00e4hrend der <code>@see</code>-Link im <code>See also</code>-Bereich aufgef\u00fchrt wird.</li> </ul>"},{"location":"methoden/","title":"Methoden","text":"<p>Bis jetzt haben wir unseren Programmcode stets in die <code>main()</code>-Methode geschrieben. Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: </p> <ul> <li>dem Single Responsibility Principle (SRP) und</li> <li>Don't repeat yourself (DRY).</li> </ul> <p>Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin, der es als ein Prinzip der Objektorientierung einf\u00fchrte und es ein wenig anders meinte, als wir es hier verwenden. Dazu kommen wir, wenn wir uns mit Objektorientierung besch\u00e4ftigen. Wir k\u00f6nnen uns aber als wesentliche Prinzipien schonmal merken, dass</p> <ul> <li>eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen <code>==</code> zwei Variablen) und</li> <li>eine Methode genau eine Sache erledigen sollte.</li> </ul> <p>Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben ein Programm in der folgenden Form:</p> <pre><code>public class Methods\n{\n    public static void main(String[] args)\n    {\n        int summand1 = 3;\n        int summand2 = 4;\n        int summe = summand1 + summand2;\n        System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);    // 3 + 4 = 7\n\n        summand1 = 5;\n        summand2 = 9;\n        summe = summand1 + summand2;\n        System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);    // 5 + 9 = 14\n\n        summand1 = -115;\n        summand2 = 999;\n        summe = summand1 + summand2;\n        System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);    // -115 + 999 = 884\n    }\n}\n</code></pre> <p>In dieser <code>main()</code>-Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun. </p>"},{"location":"methoden/#methodendefinition","title":"Methodendefinition","text":"<p>Das wollen wir \u00e4ndern und laden den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir <code>add()</code>:</p> <pre><code>public static void add(int summand1, int summand2)\n{\n    int summe = summand1 + summand2;\n    System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);\n}\n</code></pre> <p>Betrachten wir diese Definition einer Methode genauer:</p> <ul> <li>In Zeile <code>1</code> sehen wir den Methodenkopf:<ul> <li>Das Schl\u00fcsselwort <code>public</code> besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. </li> <li>Das Schl\u00fcsselwort <code>static</code> besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse <code>Methods</code> erzeugen zu m\u00fcssen. Wir k\u00f6nnen derzeit eh noch keine Objekte erzeugen, also definieren wir zun\u00e4chst alle unsere Methoden als <code>static</code> (statisch, Klassenmethode).</li> <li>Das Schl\u00fcsselwort <code>void</code> steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel).</li> <li><code>add</code> ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. </li> <li>Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter. Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert.</li> </ul> </li> <li>In den Zeilen <code>2-5</code> steht der Methodenk\u00f6rper: <ul> <li>Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer <code>{</code> (Zeile <code>2</code>) und endet mit einer schlie\u00dfenden geschweiften Klammer <code>}</code> (Zeile <code>5</code>). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. </li> <li>In Zeile <code>3</code> wird unter Verwendung der Werte der Variablen (Parameter) <code>summand1</code> und <code>summand2</code> eine Summe gebildet und in der Variablen <code>summe</code> vom Typ <code>int</code> gespeichert. </li> <li>Die Werte der Parameter und der Summe werden in Zeile <code>4</code> geeignet auf die Konsole ausgegeben. </li> </ul> </li> </ul> <p>Die Definition einer Methode erfolgt immer</p> <ul> <li>innerhalb einer Klasse und</li> <li>au\u00dferhalb jeder anderen Methode.</li> </ul>"},{"location":"methoden/#methodenaufruf","title":"Methodenaufruf","text":"<p>In der <code>main()</code>-Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass</p> <ul> <li>wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und </li> <li>dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen<ul> <li>die Anzahl der Parameter und</li> <li>der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. </li> </ul> </li> </ul> <p>Hier nochmal die gesamte Klasse <code>Methods</code> mit den Aufrufen der <code>add()</code>-Methode in <code>main()</code>:</p> <pre><code>public class Methods\n{\n    public static void add(int summand1, int summand2)\n    {\n        int summe = summand1 + summand2;\n        System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);\n    }\n\n    public static void main(String[] args)\n    {\n        add(3,4);\n        add(5,9);\n        add(-115,999);\n    }\n}\n</code></pre> <p>In der <code>main()</code>-Methode wird nun drei Mal unsere neue <code>add()</code>-Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der <code>add()</code>-Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode <code>void</code> ist - also kein Wert, kein Typ. </p> <p>Beachten Sie, dass in der Klasse <code>Methods</code> nun zwei Methoden definiert sind, <code>main()</code> und <code>add()</code>. Die <code>main()</code>-Methode ist die Programmmethode, die automatisch ausgef\u00fchrt wird, sobald wir das Programm starten. Damit die <code>add()</code>-Methode ausgef\u00fchrt wird, muss sie aufgerufen werden.</p> <p>Beachte</p> <p>Es werden nur alle Anweisungen ausgef\u00fchrt, die in der <code>main()</code>-Methode enthalten sind! Wird <code>add()</code> nie in <code>main()</code> aufgerufen, wird <code>add()</code> auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung!</p>"},{"location":"methoden/#ausfuhrung-des-programms-im-detail","title":"Ausf\u00fchrung des Programms im Detail","text":"<p>Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren:</p> <ol> <li>durch das Starten des Programms wird die <code>main()</code>-Methode aufgerufen (Zeile <code>9</code>)</li> <li>die erste Anweisung in der <code>main()</code>-Methode ist <code>add(3,4);</code> (Zeile <code>11</code>)</li> <li>dadurch wird die <code>add()</code>-Methode aufgerufen (Zeile <code>3</code>) </li> <li>durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. <code>int summand1 = 3</code> und <code>int summand2 = 4</code> (Zeile <code>3</code>) </li> <li>die erste Anweisung in der Methode <code>add()</code> ist <code>int summe = summand1 + summand2;</code>. dadurch wird die Variable <code>summe</code> deklariert und bekommt den Wert des Ausdrucks <code>summand1 + summand2</code> initial zugewiesen. Dieser Wert ist <code>7</code>. (Zeile <code>5</code>) </li> <li>Es wird die Methode <code>System.out.println()</code> aufgerufen. Der auszugebene String ergibt sich aus <code>summand1 + \" + \" + summand2 + \" = \" + summe</code>. Der Wert (vom Typ <code>String</code>) dieses Ausdrucks ergibt sich aus:<ul> <li><code>summand1 + \" + \"</code> ist ein Konkatenation; das Ergebnis ist <code>\"3 + \"</code>.</li> <li><code>\"3 + \" + summand2</code> ist ebenfalls eine Konkatenation; das Ergebnis ist <code>\"3 + 4\"</code>.</li> <li><code>\"3 + 4\" + \" = \"</code>  ist ebenfalls eine Konkatenation; das Ergebnis ist <code>\"3 + 4 = \"</code>.</li> <li><code>\"3 + 4 = \" + summe</code>  ist ebenfalls eine Konkatenation; das Ergebnis ist <code>\"3 + 4 = 7\"</code>.</li> </ul> </li> <li>Nach Ausgabe des Strings in Zeile <code>6</code> ist die Abarbeitung der <code>add()</code>-Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur <code>main()</code>-Methode gegangen.</li> <li>die n\u00e4chste Anweisung in der <code>main()</code>-Methode ist <code>add(5,9);</code> (Zeile <code>12</code>)</li> <li>dadurch wird erneut die <code>add()</code>-Methode aufgerufen (Zeile <code>3</code>) </li> <li>durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. <code>int summand1 = 5</code> und <code>int summand2 = 9</code> (Zeile <code>3</code>) </li> <li>die erste Anweisung in der Methode <code>add()</code> ist <code>int summe = summand1 + summand2;</code>. dadurch wird die Variable <code>summe</code> deklariert und bekommt den Wert des Ausdrucks <code>summand1 + summand2</code> initial zugewiesen. Dieser Wert ist <code>14</code>. (Zeile <code>5</code>) </li> <li>Es wird die Methode <code>System.out.println()</code> aufgerufen. Der auszugebene String ergibt sich aus <code>summand1 + \" + \" + summand2 + \" = \" + summe</code>. Der Wert (vom Typ <code>String</code>) dieses Ausdrucks ist <code>\"5 + 9 = 14\"</code>.</li> <li>Nach Ausgabe des Strings in Zeile <code>6</code> ist die Abarbeitung der <code>add()</code>-Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur <code>main()</code>-Methode gegangen.</li> <li>die n\u00e4chste Anweisung in der <code>main()</code>-Methode ist <code>add(-115,999);</code> (Zeile <code>13</code>)</li> <li>dadurch wird erneut die <code>add()</code>-Methode aufgerufen (Zeile <code>3</code>) </li> <li>durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. <code>int summand1 = -115</code> und <code>int summand2 = 999</code> (Zeile <code>3</code>) </li> <li>die erste Anweisung in der Methode <code>add()</code> ist <code>int summe = summand1 + summand2;</code>. dadurch wird die Variable <code>summe</code> deklariert und bekommt den Wert des Ausdrucks <code>summand1 + summand2</code> initial zugewiesen. Dieser Wert ist <code>884</code>. (Zeile <code>5</code>) </li> <li>Es wird die Methode <code>System.out.println()</code> aufgerufen. Der auszugebene String ergibt sich aus <code>summand1 + \" + \" + summand2 + \" = \" + summe</code>. Der Wert (vom Typ <code>String</code>) dieses Ausdrucks ist <code>\"-115 + 999 = 884\"</code>.</li> <li>Nach Ausgabe des Strings in Zeile <code>6</code> ist die Abarbeitung der <code>add()</code>-Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur <code>main()</code>-Methode gegangen.</li> <li>in der <code>main()</code>-Methode gibt es keine weitere Anweisung mehr. Das Programm ist beendet.</li> </ol>"},{"location":"methoden/#methode-gibt-einen-wert-zuruck","title":"Methode gibt einen Wert zur\u00fcck","text":"<p>Unsere Methode <code>add()</code> hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit <code>void</code> definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp<sup>1</sup> <code>void</code>.</p> <p>Jetzt erstellen wir eine Methode <code>computeSum()</code>, die das gleiche macht wie <code>add()</code>, aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . </p> <p>Die Definition dieser Methode sieht dann so aus: <pre><code>public static int computeSum(int summand1, int summand2)\n{\n    int summe = summand1 + summand2;\n    return summe;\n}\n</code></pre></p> <p>Zwei ganz wesentliche Unterschiede zur Definition von <code>add()</code> fallen auf:</p> <ul> <li>Diese Methode hat einen R\u00fcckgabetyp (<code>int</code>). Dort, wo bei <code>add()</code> noch <code>void</code> stand, steht bei <code>computeSum()</code> im Methodenkopf <code>int</code>. Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ <code>int</code> ist. Der Aufruf dieser Methode ist somit ein Ausdruck!</li> <li>Die letzte Anweisung der Methode <code>computeSum()</code> ist eine Anweisung, die mit dem Schl\u00fcsselwort <code>return</code> beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht <code>void</code>), muss ein solches <code>return</code> enthalten. Dieses <code>return</code> muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von <code>summe</code>. <code>summe</code> ist vom Typ <code>int</code> und somit ist <code>return summe;</code> korrekt, da die Methode ja ein <code>int</code> zur\u00fcckgeben soll.</li> </ul>"},{"location":"methoden/#aufruf-einer-methode-die-einen-wert-zuruckgibt","title":"Aufruf einer Methode, die einen Wert zur\u00fcckgibt","text":"<p>Unsere Methode <code>computeSum()</code> k\u00f6nnte nun in der <code>main()</code>-Methode wie folgt aufgerufen werden:</p> <pre><code>computeSum(3,4);    // korrekt, aber sinnlos\n</code></pre> <p>Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.:</p> <pre><code>int sum = computeSum(3,4);              // sum wird mit dem Wert 7 initialisiert\nSystem.out.println(computeSum(5,9));    // es wird 14 ausgegeben\n</code></pre> <p>Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. </p> <p>Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ <code>boolean</code>):</p> <pre><code>public static boolean areEqual(int nr1, int nr2)\n{\n    return (nr1 == nr2);\n}\n\npublic static boolean isDivider(int nr1, int nr2)\n{\n    return (nr1%nr2 == 0);\n}\n</code></pre> <p>Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden <code>areEqual(int, int)</code> und <code>isDivider(int, int)</code> und angenommen, wir wollen f\u00fcr 2 <code>int</code>-Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben:</p> <pre><code>public static boolean isDividerButNotEqual(int nr1, int nr2)\n{\n    return (isDivider(nr1, nr2) &amp;&amp; !areEqual(nr1, nr2));\n}\n</code></pre> <p>Das schauen wir uns einmal genauer an:</p> <ul> <li>wir definieren wieder eine Methode wie gehabt: <ul> <li>wir vergeben einen Namen (<code>isDividerButNotEqual</code>) und </li> <li>wir legen fest, dass bei Aufruf der Methode zwei <code>int</code>-Werte \u00fcbergeben werden m\u00fcssen (<code>(int nr1, int nr2)</code>).</li> <li>als R\u00fcckgabetyp definieren wir <code>boolean</code>, denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind</li> </ul> </li> <li>innerhalb der Methode rufen wir die Methode <code>isDivider(nr1, nr2)</code> auf und \u00fcbergeben dabei unsere Werte f\u00fcr <code>nr1</code> und <code>nr2</code>. Der Aufruf dieser Methode entspricht einem boole<code>schen Ausdruck, da diese Methode ein</code>boolean<code>zur\u00fcckgibt (</code>true<code>, wenn</code>nr2<code>Teiler von</code>nr1<code>ist und</code>false` sonst - also, wenn nicht)</li> <li>au\u00dferdem rufen wir die Methode <code>areEqual(nr1, nr2)</code> auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr <code>nr1</code> und <code>nr2</code>. Der Aufruf dieser Methode entspricht ebenfalls einem boole<code>schen Ausdruck, da diese Methode ein</code>boolean<code>zur\u00fcckgibt (</code>true<code>, wenn</code>nr1<code>und</code>nr2<code>gleich sind und</code>false` sonst - also, wenn nicht)</li> <li>wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir <code>!areEqual(nr1, nr2)</code> - also die Negation dieses Ausdrucks</li> <li>wir wollen pr\u00fcfen, <ul> <li>ob <code>isDivider(nr1, nr2)</code> UND NICHT <code>areEqual(nr1, nr2)</code>, </li> <li>also <code>isDivider(nr1, nr2)</code> UND <code>!areEqual(nr1, nr2)</code>,</li> <li>also <code>isDivider(nr1, nr2) &amp;&amp; !areEqual(nr1, nr2)</code></li> </ul> </li> <li>diesen Wert geben wir zur\u00fcck</li> </ul> 1. \u00dcbung Methoden mit R\u00fcckgabe <p>Schreiben Sie eine Methode <code>isEven(int number)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn <code>number</code> gerade ist und sonst <code>false</code>.</p> 1. \u00dcbung Methoden mit R\u00fcckgabe <p>Schreiben Sie eine Methode <code>isOdd(int number)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn <code>number</code> ungerade ist und sonst <code>false</code>. Dieses Mal verwenden Sie aber die Methode <code>isEven()</code>, um den richtigen Wert zu ermitteln. </p> <p>Success</p> <p>Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\"<sup>1</sup> <code>void</code>. Eine solche <code>void</code>-Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch <code>return</code>. Die <code>return</code>-Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck.  Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen).</p> <ol> <li> <p><code>void</code> ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp <code>void</code> sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"methodenstack/","title":"Methodenstack","text":"<p>Programme und die dazugeh\u00f6rigen Variablen (und deren Werte) befinden sich zur Ausf\u00fchrung im Arbeitsspeicher. Der Speicher ist in Bl\u00f6cke (Bytes) unetrteilt, die jeweils adressierbar sind. So k\u00f6nnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung lie\u00dfen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der Stack (Stapelspeicher). </p> <p>Bei einem Stack gilt das Last in first out (LIFO) Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tats\u00e4chlich gibt es nur ganz wenige Funktionalit\u00e4ten, um einen solchen Stack zu verwalten: </p> <ul> <li><code>push</code>: Element oben auf den Stack hinzuf\u00fcgen </li> <li><code>pop</code>: Element von oben aus dem Stack entfernen</li> <li><code>top</code> (manchmal auch <code>peek</code> genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen)</li> </ul> <p>Folgende Abbildung stellt diese Methoden grafisch dar:</p> <p></p> <p>F\u00fcr einen solchen Stack gibt es jetzt nur drei M\u00f6glichkeiten:</p> <ul> <li>Element <code>E</code> kann gelesen werden (aber im Stack belassen) - <code>top</code></li> <li>Element <code>E</code>kann aus dem Stack entfernt werden - <code>pop</code></li> <li>ein neues Element (z.B. <code>F</code>) kann zum Stack hinzugef\u00fcgt werden - <code>push</code> (dann kann auch <code>E</code> nicht mehr gelesen werden; so wie bereits <code>A</code>-<code>D</code>)</li> </ul>"},{"location":"methodenstack/#abarbeitung-von-methoden","title":"Abarbeitung von Methoden","text":"<p>Wir betrachten das Speichermodell Stack, weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel:</p> Methodenstack.java <pre><code>public class Methodenstack\n{\n    public static void a(int vaa)\n    {\n        int vab = 1;\n        System.out.println(\"+--a()   --&gt; va  = \" + vaa + \" vb  = \" + vab);\n        b(vaa, vab);\n    }\n\n    public static void b(int vba, int vbb)\n    {\n        System.out.println(\"+----b() --&gt; vba = \" + vba + \" vbb = \" + vbb);\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        for(int va=0; va&lt;3; va++)\n        {\n            System.out.println(\"main()   --&gt; va  = \" + va);\n            a(va);\n        }\n    }\n}\n</code></pre> <p>In diesem Beispiel gibt es drei Methoden: </p> <ul> <li>die <code>main()</code>-Methode mit der Variablen <code>va</code>,</li> <li>die <code>a()</code>-Methode mit den Variablen <code>vaa</code> und <code>vab</code> und </li> <li>die <code>b()</code>-Methode mit den Variablen <code>vba</code> und <code>vbb</code>.</li> </ul> <p>Die <code>main()</code>-Methode ruft die Methode <code>a()</code> auf und die <code>a()</code>-Methode ruft die <code>b()</code>-Methode auf. </p> <p>Die Ausgabe des Programms ist wie folgt:</p> <pre><code>main()   --&gt; va  = 0\n+--a()   --&gt; va  = 0 vb  = 1\n+----b() --&gt; vba = 0 vbb = 1\n\nmain()   --&gt; va  = 1\n+--a()   --&gt; va  = 1 vb  = 1\n+----b() --&gt; vba = 1 vbb = 1\n\nmain()   --&gt; va  = 2\n+--a()   --&gt; va  = 2 vb  = 1\n+----b() --&gt; vba = 2 vbb = 1\n</code></pre> <p>Die <code>main()</code>-Methode ruft also drei Mal (innerhalb der Schleife) die <code>a()</code>-Methode auf, welche wiederum die <code>b()</code>-Methode aufruft. </p> <p>Bei dem Aufruf von Methoden passiert folgendes:</p> <ul> <li>bei jedem Methodenaufruf wird eine Methodeninstanz auf den Stack gelegt</li> <li>eine Methodeninstanz sind alle zur Laufzeit ver\u00e4nderlichen Daten, die zur Methode geh\u00f6ren (Parameter und lokale Variablen)</li> <li>nach Abarbeitung der Methode (oft durch <code>return</code> - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu geh\u00f6renden Daten (Parameter, lokale Variablen und deren Werte))</li> </ul> <p>In unserem Beispiel passiert also folgendes:</p> <p> </p> <ol> <li>Die <code>main()</code>-Methode wird ausgef\u00fchrt; die Variable <code>va</code> wird erzeugt und bekommt den Wert <code>0</code>. Die <code>main()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li> <li>Die <code>a()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vaa</code> und <code>vab</code> werden erzeugt und bekommen die Werte <code>0</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li> <li>Die <code>b()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vba</code> und <code>vbb</code> werden erzeugt und bekommen die Werte <code>0</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>a()</code>. Keine weitere Anweisung - die Ausf\u00fchrung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>main()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>1</code>. </li> <li>Die Variable <code>va</code> hat nun den Wert <code>1</code>. Die <code>main()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li> <li>Die <code>a()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vaa</code> und <code>vab</code> werden erzeugt und bekommen die Werte <code>1</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li> <li>Die <code>b()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vba</code> und <code>vbb</code> werden erzeugt und bekommen die Werte <code>1</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>a()</code>. Keine weitere Anweisung - die Ausf\u00fchrung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>main()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>2</code>. </li> <li>Die Variable <code>va</code> hat nun den Wert <code>2</code>. Die <code>main()</code>-Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode <code>a()</code> auf.</li> <li>Die <code>a()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vaa</code> und <code>vab</code> werden erzeugt und bekommen die Werte <code>2</code>und <code>1</code>. In der <code>a()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Die <code>a()</code>-Methode ruft die Methode <code>b()</code> auf. </li> <li>Die <code>b()</code>-Methode wird ausgef\u00fchrt; die Variablen <code>vba</code> und <code>vbb</code> werden erzeugt und bekommen die Werte <code>2</code>und <code>1</code>. In der <code>b()</code>-Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der <code>b()</code>-Methode zu Ende. Alles, was mit der <code>b()</code>-Methode zu tun hat, insb. die Variablen <code>vba</code> und <code>vbb</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>a()</code>. Keine weitere Anweisung - die Ausf\u00fchrung der <code>a()</code>-Methode zu Ende. Alles, was mit der <code>a()</code>-Methode zu tun hat, insb. die Variablen <code>vaa</code> und <code>vab</code> werden aus dem Speicher gel\u00f6scht.  </li> <li>Zur\u00fcck zur Ausf\u00fchrung von <code>main()</code>. Die Variable <code>va</code> bekommt innerhalb der Schleife den neuen Wert <code>3</code>. Die Bedingung der Schleife <code>va&lt;3</code> ist somit <code>false</code>. Die Schleife wird verlassen, keine weitere Anweisung in <code>main()</code>. Die Abarbeitung des Programms ist zu Ende. Alles, was mit der <code>main()</code>-Methode zu tun hat, insb. Variable <code>va</code> wird aus dem Speicher gel\u00f6scht. </li> </ol>"},{"location":"methodenstack/#lebensdauer-und-sichtbarkeit-von-lokalen-variablen","title":"Lebensdauer und Sichtbarkeit von lokalen Variablen","text":"<p>Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsbl\u00f6cken, die in Methoden liegen (z.B. in <code>for</code>-Schleifen). Bei solchen Variablen sprechen wir von lokalen Variablen. Wir werden sp\u00e4ter noch globale Variablen kennenlernen. Zun\u00e4chst interessieren uns aber nur die lokalen Variablen. Das obige Beispiel zeigt, dass lokale Variablen, also solche, die in Methoden deklariert werden, nur so lange existieren, wie diese Methode ausgef\u00fchrt wird. Generell gilt:</p> <p>Eine Variable existiert in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock ausgef\u00fchrt wird. </p> <p>Schauen wir uns dazu die Situationen in dem oberen Beispiel an:</p> <ul> <li>Die Variable <code>va</code> wird in der <code>main()</code>-Methode deklariert. Die <code>main()</code>-Methode wird die ganze Zeit ausgef\u00fchrt. Also existiert auch die Variable <code>va</code> die gesamte Zeit des Programmablaufs. </li> <li>Die Variablen <code>vaa</code> und <code>vab</code> werden in der <code>a()</code>-Methode deklariert. Sie existieren immer nur dann, wenn die <code>a()</code>-Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen <code>vaa</code> und <code>vab</code> also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Da die Methode <code>a()</code> die Methode <code>b()</code> aufruft, existieren die Variablen <code>vaa</code> und <code>vab</code> auch w\u00e4hrend der Ausf\u00fchrung von <code>b()</code>, da zur Zeit der Ausf\u00fchrung von <code>b()</code> ja auch <code>a()</code> ausgef\u00fchrt wird (und <code>main()</code>).</li> <li>Die Variablen <code>vba</code> und <code>vbb</code> werden in der <code>b()</code>-Methode deklariert. Sie existieren immer nur dann, wenn die <code>b()</code>-Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen <code>vba</code> und <code>vbb</code> also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). </li> </ul> <p>Die Lebensdauer eine Variable wird somit von der Ausf\u00fchrungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. </p> <p>Lebensdauer</p> <p>Es ist eine g\u00e4ngige Praxis, alle Variablen, die man in einer Methode verwenden m\u00f6chte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsbl\u00f6cken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der <code>for</code>-Schleifen dar. Diese werden h\u00e4ufig direkt in der <code>for</code>-Schleife deklariert (<code>for(int i=0, i&lt;10; i++){}</code>). Sie existieren dann aber auch nur in dieser <code>for</code>-Schleife! Au\u00dferhalb der <code>for</code>-Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen <code>for</code>-Schleife verwenden wollen, m\u00fcssen Sie sie dort erneut deklarieren. </p> <p>Unter Sichtbarkeit einer Variablen versteht man die M\u00f6glichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt:</p> <p>Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsbl\u00f6cken, die sich in diesem Anweisungsblock befinden. Au\u00dferhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. </p> <p>Das hei\u00dft f\u00fcr unser Beispiel, dass die Variable <code>va</code> nur in der <code>main()</code>-Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen <code>vaa</code> und <code>vab</code> nur in der <code>a()</code>-Methode verwendet werden k\u00f6nnen (sichtbar sind) und die Variablen <code>vba</code> und <code>vbb</code> nur in <code>b()</code>. </p> <p>Sichtbarkeit</p> <p>Der Vorteil dieser lokalen Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Au\u00dferdem ist es auch nicht m\u00f6glich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das w\u00fcrde ansonsten gro\u00dfe Sicherheitsprobleme mit sich bringen und man k\u00f6nnte Programme auch leicht zum Absturz bringen. </p> <p>&gt;&gt;&gt; ab hier erst relevant, wenn wir Objekte kennen</p>"},{"location":"methodenstack/#werte-vs-referenztypen","title":"Werte- vs. Referenztypen","text":"<p>Es ist ganz wichtig, zu verstehen, dass es ganz wesentliche Unterschiede zwischen Werte- und Referenztypen gibt. Einige der Unterschiede sind in der folgenden Tabelle aufgelistet:</p> \u00a0Wertetypen \u00a0Referenztypen Beispiele <code>int</code>, <code>double</code>, <code>boolean</code>, <code>char</code>, <code>long</code>, <code>float</code>, <code>byte</code>, <code>short</code> <code>String</code>, <code>Point</code>, <code>Triangle</code>, <code>Circle</code>, <code>Adresse</code>, <code>System</code>, ... \u00a0neue erzeugbar? \u00a0nein \u00a0ja - einfach eigene Klasse erstellen \u00a0Was ist der \"Wert\" einer Variablen? \u00a0ein Wert (<code>5</code>, <code>true</code>, <code>1.234</code>, <code>'a'</code>, ...) \u00a0die Referenz auf ein Objekt \u00a0Manipulation von Werten \u00a0mit Operatoren (<code>+</code>, <code>==</code>, <code>&amp;&amp;</code>, ...) \u00a0mit Methoden <code>variable1 = variable2;</code> \u00a0Kopie des Wertes (<code>variable1</code> hat den Wert und <code>variable2</code> hat den Wert) \u00a0Kopie der Referenz auf das Objekt (beide Variablen zeigen auf das gleiche Objekt) <p>Insbesondere den letzten Punkt wollen wir uns genauer anschauen. Zun\u00e4chst Wertetypen. Angenommen, wir haben folgende Anweisungen:</p> <pre><code>int a = 5;\nint b = a;\n</code></pre> <p>Nach Abarbeitung dieser Anweisungen hat sowohl die Variable <code>a</code> den Wert <code>5</code> als auch die Variable <code>b</code>. Wenn wir nun <code>a=6;</code> setzen, dann hat <code>a</code> den Wert <code>6</code> und <code>b</code> immer noch den Wert <code>5</code>. </p> <p>Der Wert einer Variablen von einem Wertetyp kann sich nur durch den Zuweisungsoperator <code>=</code> \u00e4ndern!</p> <p>Folgende Abbildung zeigt die Verwaltung der beiden <code>int</code>-Variablen <code>a</code> und <code>b</code> im Speicher:</p> <p></p> <p>Die Zahlen in den K\u00e4stchen unter <code>a</code> und <code>b</code> stehen f\u00fcr Speicheradressen. Das Gute an Java ist, dass wir uns um solche Adressen nicht k\u00fcmmern m\u00fcssen. Wir greifen auf die Werte von <code>a</code> und <code>b</code> einfach \u00fcber die Variablennamen <code>a</code> und <code>b</code> zu. Die Speicherdressen interessieren uns dabei (zum Gl\u00fcck) gar nicht. Wichtig ist, dass jede Variable ihren eigenen Wert hat. Wenn wir den Wert von <code>a</code> \u00e4ndern, \u00e4ndert sich nur der Wert von <code>a</code>, wenn wir den Wert von <code>b</code> \u00e4ndern, \u00e4ndert sich nur der Wert von <code>b</code>. Dabei ist ganz egal, ob <code>b</code> den Wert <code>5</code> durch die Wertzuweisung <code>b=5;</code> erhalten hat oder durch <code>b=a;</code>, wobei <code>a</code> den Wert <code>5</code> hatte. </p> <p>Anders ist es bei Referenzvariablen, also bei Variablen, die von einem Referenztyp sind. Nehmen wir z.B. unsere Klasse <code>Point</code> und f\u00fchren folgende Anweisungen aus:</p> <pre><code>Point p1 = new Point(3,4);\nPoint p2 = p1;\n</code></pre> <p>Hier gibt es genau ein Objekt, n\u00e4mlich das Objekt, in dem die Objektvariablen <code>x</code> und <code>y</code> den Wert <code>3</code> bzw. <code>4</code> haben. Die beiden Variablen <code>p1</code> und <code>p2</code> referenzieren das gleiche Objekt, d.h. sie zeigen darauf. Die folgende Abbildung verdeutlicht diesen Fall:</p> <p></p> <p>Beide Variablen <code>p1</code> und <code>p2</code> zeigen auf dasselbe Objekt. Es gibt ja auch nur ein Objekt. Ein Objekt kann nur durch <code>new</code> und die Angabe des Konstruktors erzeugt werden. Das passiert hier genau einmal. W\u00e4hrend also bei <code>int b = a;</code> eine Kopie des Wertes erfolgt, erfolgt bei <code>Point p2 = p1;</code> eine Kopie der Referenz (aber keine Kopie des Objektes!).</p> <p>Wichtig ist jetzt noch zu wissen, dass wir auf die Objekteigenschaften des <code>Point</code>-Objektes sowohl \u00fcber die Referenz <code>p1</code> als auch \u00fcber die Referenz <code>p2</code> zugreifen k\u00f6nnen, d.h. dass z.B. <code>p1.print()</code> und <code>p2.print()</code> exakt die gleiche <code>print()</code>-Methode aufrufen, n\u00e4mlich die des obigen <code>Point</code>-Objektes. Sowohl <code>p1.getX()</code> als auch <code>p2.getX()</code> geben <code>3</code> zur\u00fcck, da sie den Wert derselben Objektvariablen <code>x</code> abfragen.</p> <p>Wenn mehrere Referenzen auf dasselbe Objekt existieren, ist es egal, \u00fcber welche Referenz wir auf die Objekteigenschaften zugreifen; es handelt sich um genau ein Objekt (mit mehreren Referenzen darauf).</p> <p>Wir m\u00fcssen nun also wissen, dass bei den folgenden Anweisungen </p> <pre><code>int a = 5;\nint b = a;\nb = 4;\nSystem.out.println(a);\n</code></pre> <p>der Wert von <code>a</code> ausgegeben wird und der ist <code>5</code>, denn es gibt genau eine Wertzuweisung f\u00fcr <code>a</code> und das ist <code>a=5;</code>. Es spielt gar keine Rolle, ob <code>b</code> seinen Wert zwischendurch \u00e4ndert oder nicht - bei der Anweisung <code>b = a;</code> ist der Wert <code>5</code> kopiert worden und der Wert von <code>a</code> ist danach v\u00f6llig unabh\u00e4ngig von <code>b</code> und umgedreht. </p> <p>Wir m\u00fcssen nun auch wissen, dass bei den folgenden Anweisungen </p> <pre><code>Point p1 = new Point(3,4);\nPoint p2 = p1;\np2.translate(1,2);\nSystem.out.println(p1.getX());\n</code></pre> <p>der Wert der Objektvariablen <code>x</code> des einen Objektes ausgegeben wird, das existiert. Durch die <code>translate()</code>-Methode ist der <code>x</code>-Wert des Objektes nun <code>4</code> (und der <code>y</code>-Wert ist <code>6</code>). Das hei\u00dft, es wird eine <code>4</code> ausgegeben. Dabei ist v\u00f6llig egal, ob die <code>translate()</code>-Methode \u00fcber die Referenz <code>p1</code> oder \u00fcber die Referenz <code>p2</code> aufgerufen wird und es ist auch v\u00f6llig egal, ob die <code>print()</code>-Methode \u00fcber die Referenz <code>p1</code> oder \u00fcber die Referenz <code>p2</code> aufgerufen wird. Beide referenzieren dasselbe Objekt.</p>"},{"location":"methodenstack/#arrays-sind-auch-objekte","title":"Arrays sind (auch) Objekte!","text":"<p>Schauen wir uns folgenden Fall an:</p> <pre><code>int[] a1 = { 3, 4 };\nint[] a2 = a1;\na2[1] = 5;\nSystem.out.println(a1[1]);\n</code></pre> <p>Arrays sind (auch) Objekte. Also haben wir hier den gleichen Fall, wie bene bei <code>Point</code>. Auch referenzieren sowohl <code>a1</code> als auch <code>a2</code> dasselbe Array (es gibt ja nur eins). Wenn wir also \u00fcber die Referenz <code>a2</code> den zweiten Wert im Array auf <code>5</code> setzen und wir danach \u00fcber die Referenz <code>a1</code> den zweiten Wert dieses Array auslesen, dann ist er <code>5</code>.</p> <p>Sie werden sich jetzt sicherlich fragen, warum wir uns \u00fcberhaupt Kopien der Referenzen machen - das ist doch nur verwirrend. Die Antwort ist, dass dieser Fall sogar sehr oft vorkommt, n\u00e4mlich immer genau dann, wenn wir Referenzen von Objekten als Parameter \u00fcbergeben. Schauen wir uns folgendes Beispiel an:</p> <pre><code>public static void swap(int[] arr, int index1, int index2)\n{\n    if(index1 &gt;=0 &amp;&amp; index1&lt;arr.length &amp;&amp; index2 &gt;= 0 &amp;&amp; index2&lt;arr.length)\n    {\n        int tmp = arr[index1];\n        arr[index1] = arr[index2];\n        arr[index2] = tmp;\n    }\n}\n</code></pre> <p>Diese Methode implementiert das Vertauschen zweier Elemente in einem <code>int</code>-Array. So, wie wir es z.B. in vielen Sortieralgorithmen ben\u00f6tigen. Die Werte der Elemente an den Indizes <code>index1</code> und <code>index2</code> werden miteinander getauscht. Wir speichern den einen Wert zwischen, damit wir ihn nicht \u00fcberschreiben. Es wird vorab gepr\u00fcft, ob die beiden Indizes <code>index1</code> und <code>index2</code> \u00fcberhaupt im Array <code>arr</code> existieren. </p> <p>Angenommen, wir haben nun in der <code>main()</code>-Methode (oder einer anderen Methode) folgende Anweisungen</p> <p><pre><code>int[] a1 = { 1, 2, 3, 4, 5 };\nswap(a1, 0, 1);         // Uebergabe der Referenz auf das Array\nfor(int i=0; i&lt;a1.length; i++)\n{\n    System.out.println(a1[i] + \" \");\n}\n</code></pre> , dann ist die Ausgabe </p> <pre><code>2 1 3 4 5\n</code></pre> <p>Wir \u00fcbergeben bei Aufruf der Methode <code>swap(a1, 0, 1);</code> die Referenz auf das Array und in der Methode wird die lokale Variable <code>arr</code> mit genau dieser Referenz initialisiert, d.h. es existieren dann zwei Referenzen auf das Array! Die Referenz <code>arr</code> innnerhalb der <code>swap()</code>-Methode und die Referenz <code>a1</code> innerhalb der <code>main()</code>-Methode. Zwei Referenzen, aber nur ein Objekt!</p> <p>L\u00f6sen Sie die folgenden \u00dcbungsaufgaben durch \u00dcberlegen!</p> Was wird ausgegeben? <pre><code>public static void swap(int a, int b)\n{\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\n\n\npublic static void main(String[] args)\n{\n    int a = 3;\n    int b = 4;\n    swap(a, b);\n    System.out.println(a);\n}\n</code></pre> Was wird ausgegeben? I.javaTestI.java <pre><code>public class I\n{\n    private int o;\n\n    public I(int o)\n    {\n        this.o = o;\n    }\n\n    public int getO()\n    {\n        return this.o;\n    }\n\n    public void add1()\n    {\n        o++;\n    }\n}\n</code></pre> <pre><code>public static void doSomething(I i2)\n{\n    i2.add1();\n}\n\npublic static void main(String[] args)\n{\n    I i1 = new I(1);\n    I i2 = i1;\n    i2.add1();\n    I i3 = i1;\n    doSomething(i3);\n    System.out.println(i1.getO());\n    System.out.println(i2.getO());\n    System.out.println(i3.getO());\n}\n</code></pre>"},{"location":"methodenstack/#das-leben-der-objekte","title":"Das \"Leben\" der Objekte","text":"<p>Wir haben uns bereits eingehend mit der Lebensdauer und der Sichtbarkeit von lokalen Variablen besch\u00e4ftigt. Es ist dabei \u00fcbrigens gaz egal, ob es sich um Variablen von einem Werte- oder einem Referenztyp handelt. Auf die Lebensdauer und Sichtbarkeit hat das keinen Einfluss. </p> <p>Wir wissen auch bereits, dass Objektvariablen f\u00fcr jeweils ein Objekt existieren. Die Lebensdauer einer Objektvariablen entspricht also der Lebensdauer ihres Objektes. Wir wissen auch \u00fcber die Sichtbarkeit der Objektvariablen bescheid, denn sie sind in der gesamten Klasse sichtbar, in der sie deklariert werden, also auch in allen Methoden dieser Klasse. Ob sie dar\u00fcber hinaus auch \u00fcber eine Referenz auf ein Objekt in anderen Klassen sichtbar sind, h\u00e4ngt vom Sichtbarkeitsmodifizierer ab. Normalerweise nicht, denn wir deklarieren alle Objektvariablen als <code>private</code>.</p> <p>Wir wollen nun untersuchen, wie lange Objekte existieren. Wir wissen bereits, dass ihre Existenz mit der Anweisung <code>new</code> gefolgt vom Konstruktor beginnt. </p> <p>Wir haben gelernt, dass Methoden in einem sogenannten Stack abgearbeitet werden und dass in diesem Stack auch die lokalen Variablen existieren - und zwar so lange, so lange die Methode abgearbeitet wird, also im Stack existiert. Sichtbar sind jedoch nur die lokalen Variablen, die zur Methode geh\u00f6ren, die im Stack ganz oben liegt, also gerade abgearbeitet wird. Objekte werden nicht im Stack abgelegt. Der Speicherbereich f\u00fcr Objekte nennt sich Heap. Wir wollen auf die Speicherstruktur des Heap gar nicht weiter eingehen, wichtig ist nur, dass bei Erzeugung eines Objektes Speicherplatz im Heap f\u00fcr das Objekt reserviert wird. Die Gr\u00f6\u00dfe des reservierten Speicherplatzes bestimmt der Konstruktor und ist von den Objektvariablen des Objektes abh\u00e4ngig, also von der Gr\u00f6\u00dfe und der Anzahl der Objektvariablen<sup>1</sup>. Die Objektvariablen existieren auf dem Heap. Lebt das Objekt nicht mehr, wird der Speicherplatz auf dem Heap (automatisch) freigegeben.</p> <p>Wir wissen, wann Objekte anfangen, zu existieren (wenn sie erzeugt werden), aber wann h\u00f6ren Sie auf, zu existieren? Wir betrachten \"das Leben\" eines Objektes am Beispiel eines <code>Point</code>-Objektes:</p> <ol> <li> <p>Objekt-Referenz deklarieren</p> <pre><code>public static void main (String[] args)\n{\n    Point p1;\n}\n</code></pre> <p>Damit ist bereits eine Referenz mit dem Namen <code>p1</code> auf ein <code>Point</code>-Objekt definiert. Das Objekt existiert aber noch gar nicht! Aber es sind schonmal 64Bit im Heap reserviert. </p> <p>Die (Referenz-)Variable <code>p1</code> ist eine lokale Variable der Methode <code>main()</code>. <code>p1</code> ist nur in der <code>main()</code>-Methode sichtbar, sie existiert so lange, solange <code>main()</code> ausgef\u00fchrt wird und sie existiert im Stack. </p> </li> <li> <p>Objekt erzeugen</p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n}\n</code></pre> <p>Jetzt existiert ein <code>Point</code>-Objekt! Es wird im Heap abgelegt. Insbesondere werden die Objektvariablen <code>x</code> und <code>y</code> im Heap abgelegt und bekommen die Werte <code>3</code> und <code>4</code>. </p> <p>Jetzt gibt es eine Referenzvariable <code>p1</code> im Stack und ein Objekt mit Objektvariablen im Heap. Durch den Zuweisungsoperator <code>=</code> werden die beiden miteinander verbunden, d.h <code>p1</code> zeigt jetzt auf das <code>Point</code>-Objekt. </p> <p></p> <p>An dieser Stelle ist es schonmal sinnvoll zu betonen, dass die einzige M\u00f6glichkeit, auf das <code>Point</code>-Objekt zuzugreifen, derzeit \u00fcber die <code>p1</code>-Variable existiert. G\u00e4be es diese Variable nicht, h\u00e4tten wir keinen Zugriff auf das Objekt!</p> </li> <li> <p>Ein weiteres Objekt und eine Referenz darauf erzeugen</p> <p>Wir erzeugen zur Veranschaulichung ein weiteres Objekt und die Referenzvariable <code>p2</code>, die darauf zeigt.</p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n    Point p2 = new Point(3,4);\n}\n</code></pre> <p>Jetzt existieren zwei <code>Point</code>-Objekte im Heap und zwei Referenzvariablen <code>p1</code> und <code>p2</code>, die jeweils auf eines der beiden Objekte zeigen. <code>p1</code> und <code>p2</code> sind lokale Variablen der <code>main()</code>-Methode und existieren im Stack. </p> <p></p> <p>Beachten Sie, dass die beiden Objekte zwar Objektvariablen haben, die gleiche Werte aufweisen, aber es handelt sich um zwei (verschiedene) Objekte!</p> </li> <li> <p>Eine weitere Referenz erzeugen</p> <p>Jetzt erzeugen wir noch eine weitere Referenz auf das erste <code>Point</code>-Objekt. Wir nennen die Referenzvariable <code>p3</code>. </p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n    Point p2 = new Point(3,4);\n    Point p3 = p1;\n}\n</code></pre> <p>Diese Situation l\u00e4sst sich so veranschaulichen:</p> <p></p> <p>Auf das erste Objekt existieren also gleich zwei Referenzen. \u00dcber beide Referenzen kann mittels Punktnotation auf das Objekt (dessen Objekteigenschaften) zugegriffen werden. Es ist also egal, ob man <code>p1.</code> oder <code>p3.</code> schreibt, beide zeigen auf das gleiche Objekt. </p> </li> <li> <p>Eine Referenz \u00e4ndern</p> <p>Wir \u00e4ndern nun die soeben erstellte Referenz und lassen sie nun auf das zweite Objekt zeigen:</p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n    Point p2 = new Point(3,4);\n    Point p3 = p1;\n    p3 = p2;\n}\n</code></pre> <p><code>p3</code> darf nat\u00fcrlich nicht erneut deklariert werden. Wir kopieren die Referenz von <code>p2</code> nach <code>p3</code>. <code>p3</code> zeigt damit nun auf das zweite Objekt. </p> <p></p> <p>Nun zeigen <code>p2</code> und <code>p3</code> auf dasselbe Objekt. Nun ist es also egal, ob man <code>p2.</code> oder <code>p3.</code> schreibt, beide zeigen auf dasselbe - das \"zweite\" - Objekt. Auf das \"erste\" Objekt zeigt nur noch <code>p1</code>. </p> </li> <li> <p>Eine weitere Referenz \u00e4ndern</p> <p>Nun lassen wir auch noch <code>p1</code> auf das zweite Objekt zeigen. </p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n    Point p2 = new Point(3,4);\n    Point p3 = p1;\n    p3 = p2;\n    p1 = p2;        // exakt gleich zu p1 = p3;\n}\n</code></pre> <p>Die nun entstandene Situation l\u00e4sst sich wie folgt veranschaulichen:</p> <p></p> <p>Der entscheidende Punkt ist nun der, dass es auf das erste Objekt keine Referenz mehr gibt. Damit ist das Objekt f\u00fcr uns verloren - wir haben keinen Zugriff mehr darauf!</p> <p>Was passiert mit einem solchen Objekt? Es wird aus dem Speicher gel\u00f6scht. Dies erfolgt automatisch. Die Laufzeitumgebung erkennt solche Objekte, auf die keine Referenz mehr zeigt. Die sogenannte Garbage Collection gibt diesen Speicher wieder f\u00fcr die weitere Verwendung frei. In Java m\u00fcssen wir uns - im Gegensatz zu anderen Programmiersprachen - nicht um die Speicherfreigabe k\u00fcmmern. Das erfolgt im Hintergrund und ganz automatisch. </p> </li> </ol> <p>Neben der \u00c4nderung einer Referenz kann eine Referenzvariable auch aufh\u00f6ren, zu existieren und damit ist ein Objekt ohne Referenz. Das folgende Beispiel zeigt einen solchen Fall:</p> <pre><code>public static void createPoint()\n{\n    Point p = new Point(3,4);\n}\n\npublic static void main (String[] args)\n{\n    createPoint();\n}\n</code></pre> <p>In der <code>main()</code>-Methode wird die <code>createPoint()</code>-Methode aufgerufen. Darin wird eine Referenz <code>p</code> erzeugt und ein <code>Point</code>-Objekt. <code>p</code> zeigt auf dieses Objekt. Sobald die Methode abgearbeitet ist und verlassen wird, h\u00f6rt die lokale Variable <code>p</code> jedoch auf zu existieren. Sie wird aus dem Stack gel\u00f6scht. Somit ist das <code>Point</code>-Objekt im Heap ohne eine Referenz und muss von der Garbage Collection entsorgt werden. </p> Erweitern Sie obiges Programm so, dass eine Referenz auf das <code>Point</code>-Objekt nicht verloren geht"},{"location":"methodenstack/#der-null-wert","title":"Der <code>null</code>-Wert","text":"<p>Zeigt eine Referenzvariable auf kein Objekt, so ist ihr Wert <code>null</code>. Beispiel:</p> <pre><code>public static void main (String[] args)\n{\n    Point p1;   // p1 hat den Wert null\n}\n</code></pre> <p>Die Referenzvariable <code>p1</code> vom Typ <code>Point</code> existiert bereits, aber es existiert (noch) kein <code>Point</code>-Objekt, auf das sie zeigt. Somit ist der \"Wert\" der Referenzvariable <code>p1</code> <code>null</code>. Referenzvariablen k\u00f6nnen auch explizit auf <code>null</code> gesetzt werden:</p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);  // Point-Objekt existiert, p1 zeigt auf das Point-Objekt\n    p1 = null;                  // p1 zeigt auf kein Objekt (mehr) - das Point-Objekt wird von der GC entsorgt\n}\n</code></pre> <p>Im oberen Beispiel wurde die <code>p1</code>-referenzvariable vom Typ <code>Point</code> deklariert und ein <code>Point</code>-Objekt. Die <code>p1</code>-variable referenziert (zeigt auf) das <code>Point</code>-Objekt. Danach wird <code>p1</code> explizit der \"Wert\" <code>null</code> zugeordnet. Die <code>p1</code>-Variable zeigt auf kein <code>Point</code>-Objekt mehr. Da das <code>Point</code>-Objekt nun keine Referenz mehr auf sich hat (und somit nicht mehr verwendet werden kann), wird es durch die Garbage Collection entsorgt. </p>"},{"location":"methodenstack/#referenzvergleiche-mit","title":"Referenzvergleiche mit <code>==</code>","text":"<p>Wir kennen den Operator <code>==</code> als logischen Vergleichsoperator von Werten, z.B. k\u00f6nnen wir <code>int</code>-Werte damit vergleichen oder <code>char</code>-Werte oder <code>boolean</code>-Werte usw. Der Vergleichsoperator <code>==</code> kann auch f\u00fcr Referenzvergleiche verwendet werden, aber Achtung!, es handelt sich dann ausschlie\u00dflich um Referenzvergleiche und nicht um eine Gleichheit von Objekten (dazu verwenden wir sp\u00e4ter <code>equals()</code>). Beispiele:</p> <pre><code>public static void main (String[] args)\n{\n    Point p1 = new Point(3,4);\n    Point p2 = new Point(3,4);\n    Point p3 = p1;\n    System.out.println(p1 == p2);   // false - nicht die gleiche Referenz (zwei verschiedene Objekte)\n    System.out.println(p1 == p3);   // true - die gleiche Referenz (ein Objekt)\n    Point p4;\n    System.out.println(p4 == null); // true - keine Referenz auf ein Objekt\n    System.out.println(p1 != null); // true - Referenz auf ein Objekt, deshalb ungleich null\n\n}\n</code></pre> <p>Es ist eigentlich ung\u00fcnstig, den Gleichheitsoperator <code>==</code> von Werten auch f\u00fcr Referenzen zu verwenden, da dies am Anfang verwirrend sein kann. Wichtig ist, dass der \"Wert\" einer Referenz die Referenz(-adresse) auf ein Objekt ist. Haben zwei Referenzvariablen den gleichen \"Wert\", dann zeigen sie auf dasselbe Objekt (und somit ist <code>==</code> <code>true</code>). Der Gleichheitsoperator <code>==</code> pr\u00fcft nicht die Gleichheit von Objekten (z.B. beide <code>x</code>-variablen <code>3</code> und beide <code>y</code>-Variablen <code>4</code> - das erledigen wir sp\u00e4ter, indem wir die <code>equals()</code>-Methode \u00fcberschreiben)!</p> <p>Wird der Vergleichsoperator <code>==</code> f\u00fcr Referenztypen verwendet, so wird nur die Gleichheit von Referenzen verglichen, nicht aber die Gleichheit von Objekten!</p> <p>Success</p> <p>Wir haben zwei Aspekte diskutiert, die beide sehr wichtig f\u00fcr das Verst\u00e4ndnis der objektorientierten Programmierung sind. Einerseits den Unterschied zwischen Werte- und Referenztypen und andererseits, dass ein Objekt aufh\u00f6rt, zu existieren, sobald es keine Referenz mehr gibt, die auf dieses Objekt zeigt. Insbesondere das Verst\u00e4ndnis \u00fcber den Unterschied zwischen Werte- und Referenztypen ist wirklich wichtig, um die Konzepte der objektorientierten Programmierung gut verstehen zu k\u00f6nnen!</p> <ol> <li> <p>Ein <code>Point</code>-Objekt besteht z.B. aus zwei <code>int</code>-Variablen (<code>x</code> und <code>y</code>) und ben\u00f6tigt somit 2 x 32Bit, also 64Bit.\u00a0\u21a9</p> </li> </ol>"},{"location":"object/","title":"Die Klasse <code>Object</code>","text":"<p>Die Klasse <code>java.lang.Object</code> ist die Basisklasse (Elternklasse) aller in Java existierenden Klassen. <code>Object</code> wird h\u00e4ufig auch als die Mutter aller Klassen in Java bezeichnet.  Eine Klasse kann entweder explizit von einer anderen Klasse erben (mithilfe von <code>extends</code>) oder sie erbt implizit von der Klasse <code>Object</code>.  Das bedeutet, dass jede Klasse von der Klasse <code>Object</code> erbt. </p> <p>Betrachten wir nochmal zur Wiederholung unsere Vererbungshierarchie aus dem vorherigen Abschnitt Vererbung: </p> <ul> <li>Dort hatten wir zun\u00e4chst die Klasse <code>Viereck</code> erstellt, die explizit von keiner Klasse geerbt hat. <code>Viereck</code> erbt somit implizit  von <code>Object</code>.  </li> <li>Die Klasse <code>Rechteck</code> erbt von <code>Viereck</code> und somit auch von <code>Object</code>. </li> <li>Die Klasse <code>Quadrat</code> erbt von <code>Rechteck</code> und somit auch von <code>Viereck</code> und somit auch von <code>Object</code>. </li> </ul> <p>Wenn wir uns nun noch daran erinnern, dass wir beim Erstellen der Konstruktoren gesagt haben, dass bei der Objekterzeugung auch immer ein Objekt der Elternklasse erzeugt wird, dann bedeutet das, dass f\u00fcr jedes Objekt auch immer ein Objekt der Klasse <code>Object</code> erzeugt wird. </p> <p>Wenn wir uns nun auch noch daran erinnern, dass in einer Vererbungshierarchie immer die is-a-Relation (ist ein) gilt (jedes <code>Rechteck</code> ist ein <code>Viereck</code>, jedes <code>Quadrat</code> ist ein <code>Rechteck</code> ist ein <code>Viereck</code>), dann gilt dass jedes Objekt auch ein Objekt vom Typ <code>Object</code> ist. Das bedeutet insbesondere, dass jedes Objekt alle Objekteigenschaften (Objektmethoden) der Klasse <code>Object</code> geerbt hat. </p> <p>Jedes Objekt (egal von welchem Referenztyp) ist auch ein Objekt vom Typ <code>Object</code> und hat alle Objektmethoden von <code>Object</code> geerbt.</p>"},{"location":"object/#objektmethoden-von-object","title":"Objektmethoden von <code>Object</code>","text":"<p>Jedes Objekt in Java hat also automatisch die Methoden von <code>Object</code> geerbt. Einige davon betrachten wir nun etwas genauer:</p> Objektmethode von <code>Object</code> Bedeutung <code>getClass()</code> gibt den Laufzeittyp der Klasse zur\u00fcck <code>toString()</code> gibt einen <code>String</code> zur\u00fcck \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um eine geeignete textuelle Beschreibung der Objekte zu haben <code>equals(Object)</code> f\u00fcr den Vergleich zweier Objekte \u2192 sollte in jeder Klasse \u00fcberschrieben werden, um Gleichheit von Objekten zu beschreiben (default: Referenzvergleich) <code>hashCode()</code> gibt einen HashCode (ein <code>int</code>) f\u00fcr ein Objekt zur\u00fcck, wird ben\u00f6tigt zum Einsortieren in hashbasierten Containern \u2192 sp\u00e4ter in Collections <code>clone()</code> gibt eine Kopie (einen Clone) des Objektes zur\u00fcck <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> f\u00fcr Threads \u2192 machen wir viel sp\u00e4ter <code>finalize()</code> f\u00fcr die Garbage Collection \u2192 ist seit Java 9 deprecated <p>Die Objektmethoden aus den letzten beiden Zeilen der Tabelle betrachten wir hier nicht weiter. Die anderen Objektmethoden werden im Folgenden genauer untersucht. Wir beginnen mit <code>getClass()</code>. </p>"},{"location":"object/#die-objektmethode-getclass","title":"Die Objektmethode <code>getClass()</code>","text":"<p>Angenommen, wir haben die Klassen <code>Viereck</code>, <code>Rechteck</code> und <code>Quadrat</code> aus dem vorherigen Kapitel Vererbung gegeben:</p> Viereck.javaRechteck.javaQuadrat.java <pre><code>public class Viereck\n{\n    protected int a,b,c,d;          // Seiten\n\n    public Viereck(int a, int b, int c, int d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public int umfang()\n    {\n        return this.a + this.b + this.c + this.d;\n    }\n\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.println(\" Umfang des Vierecks : \" + this.umfang());\n    }\n}\n</code></pre> <pre><code>public class Rechteck extends Viereck\n{\n    public Rechteck(int laenge, int breite)\n    {\n        super(laenge, breite, laenge, breite);  // Aufruf des Konstruktors von Viereck\n    }\n\n    /*\n     *  neue Objektmethode\n     *  spezielle Eigenschaft fuer Rechteck \n     *  gilt nicht f\u00fcr Viereck\n     *  \n     */\n    public int flaecheninhalt()\n    {\n        return this.a * this.b;     // Zugriff moeglich wegen protected in Viereck\n    }\n\n    @Override\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.print(\" Umfang des Rechtecks : \" + this.umfang());\n        System.out.println(\" Flaecheninhalt des Rechtecks : \" + this.flaecheninhalt());\n    }\n}\n</code></pre> <pre><code>public class Quadrat extends Rechteck\n{\n    Quadrat(int seite)\n    {\n        super(seite, seite);    // Aufruf des Konstruktors von Rechteck\n    }\n\n    @Override\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.print(\" Umfang des Quadrats : \" + this.umfang());\n        System.out.println(\" Flaecheninhalt des Quadrats : \" + this.flaecheninhalt());\n    }\n}\n</code></pre> <p>Wenn wir nun in z.B. einer <code>main()</code>-Methode folgende Anweisungen haben:</p> <pre><code>Viereck v1 = new Viereck(10,20,30,40);\nRechteck r1 = new Rechteck(10, 20);\nQuadrat q1 = new Quadrat(30);\n</code></pre> <p>, dann wissen wir, dass <code>v1</code> vom Typ <code>Viereck</code> ist, <code>r1</code> vom Typ <code>Rechteck</code> und <code>q1</code> vom Typ <code>Quadrat</code>. Die Deklarationen dieser Variablen geben den sogenannten Compilertyp an. Und tats\u00e4chlich haben wir ja im obigen Fall auch die dazu passenden Objekte erzeugt, die genau dem jeweiligen Typ entsprechen. Wenn wir nun also jeweils die <code>getClass()</code>-Methode aufrufen, dann bekommen wir die jeweiligen Typen zur\u00fcckgegeben:</p> <p><pre><code>Viereck v1 = new Viereck(10,20,30,40);\nRechteck r1 = new Rechteck(10, 20);\nQuadrat q1 = new Quadrat(30);\nSystem.out.println(v1.getClass());  // von Object geerbt\nSystem.out.println(r1.getClass());  // von Viereck -&gt; Object geerbt\nSystem.out.println(q1.getClass());  // von Rechteck -&gt; Viereck -&gt; Object geerbt\n</code></pre> Die Ausgaben sind: <pre><code>class Viereck\nclass Rechteck\nclass Quadrat\n</code></pre> Wichtig: <code>getClass()</code> gibt jedoch nicht den Compilertyp, sondern den Laufzeittyp zur\u00fcck. </p>"},{"location":"object/#compilertyp-vs-laufzeittyp","title":"Compilertyp vs. Laufzeittyp","text":"<p>Was sind Compiler- und Laufzeittypen? Compilertyp wissen wir schon. Bei der Deklaration einer Variablen geben wir den Compilertypen der Variablen an. Was wir aber auch wissen, ist, dass jedes <code>Rechteck</code> ist auch ein <code>Viereck</code>. Das erlaubt uns, auch Folgendes zu schreiben:</p> <pre><code>Viereck v = new Rechteck(10, 20);\n</code></pre> <p>Jetzt ist <code>v</code> vom (Compiler-)Typ <code>Viereck</code>, aber vom Laufzeittyp <code>Rechteck</code>. Die Referenzvariable <code>v</code> zeigt auf ein <code>Rechteck</code>-Objekt. Mit <code>getClass()</code> erfragen wir den Laufzeittyp, d.h.</p> <p><pre><code>Viereck v = new Rechteck(10, 20);       // Compilertyp von v ist Viereck\nSystem.out.println(v.getClass());       // Laufzeittyp von v ist Rechteck\n</code></pre> erzeugt die Ausgabe <pre><code>class themen.vererbung.Rechteck\n</code></pre></p> <p>Wir k\u00f6nnen also auch soetwas machen: <pre><code>Viereck[] va = new Viereck[3];\nva[0] = new Viereck(10,20,30,40);       // Compilertyp von va[0] ist Viereck, Laufzeittyp ist Viereck\nva[1] = new Rechteck(10, 20);           // Compilertyp von va[1] ist Viereck, Laufzeittyp ist Rechteck\nva[2] = new Quadrat(15);                // Compilertyp von va[2] ist Viereck, Laufzeittyp ist Quadrat\n\nSystem.out.println(va[0].getClass());   // Viereck\nSystem.out.println(va[1].getClass());   // Rechteck\nSystem.out.println(va[2].getClass());   // Quadrat\n</code></pre></p> <p>Das bedeutet auch, dass sogar soetwas m\u00f6glich ist: <pre><code>Object o1 = new Viereck(10,20,30,40);   // Compilertyp von o1 ist Object, Laufzeittyp ist Viereck\nObject o2 = new Rechteck(10, 20);       // Compilertyp von o2 ist Object, Laufzeittyp ist Rechteck\nObject o3 = new Quadrat(15);            // Compilertyp von o3 ist Object, Laufzeittyp ist Quadrat\n\nSystem.out.println(o1.getClass());      // Viereck\nSystem.out.println(o2.getClass());      // Rechteck\nSystem.out.println(o3.getClass());      // Quadrat\n</code></pre></p> <p>Der Compilertyp einer (Referenz-)Variablen wird durch die Deklaration bestimmt. Der Laufzeittyp wird bestimmt durch das konkrete Objekt, auf das die Referenzvariable zeigt. </p>"},{"location":"object/#welche-objektmethoden-anwendbar-typecast","title":"Welche Objektmethoden anwendbar? - Typecast","text":"<p>Wenn wir schonmal bei der Unterscheidung zwischen Compilertyp und Laufzeittyp sind, dann k\u00f6nnen wir gleich der Frage nachgehen, welche Objektmethoden anwendbar sind. Erinnern wir uns dazu nochmal an die Erweiterung der Klasse <code>Rechteck</code>. Dort hatten wir eine Objektmethode <code>flaecheninhalt()</code> definiert, die in der Klasse <code>Viereck</code> nicht existiert. </p> <p>Wir hatten folgenden Fall: <pre><code>Viereck v1 = new Viereck(10,20,30,40);\n// System.out.println(v1.flaecheninhalt());     // flaecheninhalt() existiert f\u00fcr Viereck nicht\nRechteck r1 = new Rechteck(10, 20);\nSystem.out.println(r1.flaecheninhalt());        // flaecheninhalt() existiert f\u00fcr Rechteck (=200)\n</code></pre></p> <p>Wenn wir nun  <pre><code>Viereck v = new Rechteck(10, 20);\n</code></pre> haben, <code>v</code> also den Compilertyp <code>Viereck</code> hat und den Laufzeittyp <code>Rechteck</code>. K\u00f6nnen wir dann  <pre><code>System.out.println(v.flaecheninhalt());     // Fehler!\n</code></pre> aufrufen? Die Antwort ist nein! Das ist auch insofern logisch, als dass dieser Aufruf ja bereits zum Compilezeit m\u00f6glich sein muss. Dem Typ <code>Viereck</code> steht diese Methode aber nicht zur Verf\u00fcgung. Das geht also nicht. Was wir aber in diesem Fall machen k\u00f6nnen, ist eine explizite Typkonvertierung.  <pre><code>Viereck v = new Rechteck(10, 20);\nRechteck r = (Rechteck)v;           // geht, weil der Laufzeittyp Rechteck ist\nSystem.out.println(r.flaecheninhalt());     // geht, weil der Compilertyp von r Rechteck ist\n</code></pre></p> <p>Nochmal im Detail: </p> <ul> <li>In Zeile <code>1</code> definieren wir eine Referenzvariable <code>v</code> vom Compilertyp <code>Viereck</code>. </li> <li>In Zeile <code>2</code> definieren wir eine Referenzvariable <code>r</code> vom Compilertyp <code>Rechteck</code>. </li> <li>Weil <code>r</code> vom Compilertyp <code>Rechteck</code> ist, k\u00f6nnen wir f\u00fcr <code>r</code> die Objektmethode <code>flaecheninhalt()</code> aufrufen (f\u00fcr <code>v</code> nicht!). </li> <li>Dass die Typkonvertierung in Zeile <code>2</code> auch tats\u00e4chlich gelingt, liegt (zur Laufzeit) daran, dass der Laufzeittyp von <code>v</code> <code>Rechteck</code> ist. W\u00e4re das nicht der Fall, w\u00fcrde die Typkonvertierung scheitern - aber erst zur Laufzeit (mit einer <code>ClassCastException</code>). </li> </ul>"},{"location":"object/#instanceof-vs-getclass","title":"<code>instanceof</code> vs. <code>getClass()</code>","text":"<p>Wie gesagt, ermitteln wir mit <code>getClass()</code> den Laufzeittypen einer Referenzvariablen. Daf\u00fcr gibt es auch noch ein anderes Schl\u00fcsselwort in Java, n\u00e4mlich <code>instanceof</code>. Das ist ein Operator, mit dessen Hilfe wir einen Vergleich mit Typen anstellen k\u00f6nnen. Zun\u00e4chst ein Beispiel:</p> <pre><code>Viereck v = new Viereck(10,20,30,40);\nif(v instanceof Viereck)\n{\n    System.out.println(\"v ist vom Typ Viereck\");\n}\n</code></pre> <p>In Zeile <code>2</code> sehen wir die Anwendung des <code>instanceof</code>-Operators. Er gibt ein <code>boolean</code> zur\u00fcck, je nachdem die Variable vom angegebenen Typen ist oder nicht. Der obige Code erzeugt also die Ausgabe  <pre><code>v ist vom Typ Viereck\n</code></pre> auf der Konsole. Angenommen, wir haben nun folgendes Beispiel: <pre><code>Object o = new Quadrat(15); // Compilertyp Object, Laufzeittyp Quadrat\nif(o instanceof Object)     // true\n{\n    System.out.println(\"o ist vom Typ Object\");\n}\nif(o instanceof Viereck)    // true\n{\n    System.out.println(\"o ist vom Typ Viereck\");\n}\nif(o instanceof Rechteck)   // true\n{\n    System.out.println(\"o ist vom Typ Rechteck\");\n}\nif(o instanceof Quadrat)    // true\n{\n    System.out.println(\"o ist vom Typ Quadrat\");\n}\n</code></pre> , dann sind alle Bedingungen <code>true</code>, d.h. es wird folgende Ausgabe erzeugt: <pre><code>o ist vom Typ Object\no ist vom Typ Viereck\no ist vom Typ Rechteck\no ist vom Typ Quadrat\n</code></pre> <code>instanceof</code> pr\u00fcft also jeden m\u00f6glichen Laufzeittyp (wir wissen ja, dass ein Objekt vom Typ <code>Quadrat</code> ist ein Objekt vom Typ <code>Rechteck</code> ist ein Objekt vom Typ <code>Viereck</code> ist ein Objekt vom Typ <code>Object</code>). Das gleiche gilt auch f\u00fcr: <pre><code>Quadrat q = new Quadrat(15); // Compilertyp Quadrat, Laufzeittyp Quadrat\nif(q instanceof Object)     // true\n{\n    System.out.println(\"q ist vom Typ Object\");\n}\nif(q instanceof Viereck)    // true\n{\n    System.out.println(\"q ist vom Typ Viereck\");\n}\nif(q instanceof Rechteck)   // true\n{\n    System.out.println(\"q ist vom Typ Rechteck\");\n}\nif(q instanceof Quadrat)    // true\n{\n    System.out.println(\"q ist vom Typ Quadrat\");\n}\n</code></pre> , dann sind alle Bedingungen <code>true</code>, d.h. es wird folgende Ausgabe erzeugt: <pre><code>q ist vom Typ Object\nq ist vom Typ Viereck\nq ist vom Typ Rechteck\nq ist vom Typ Quadrat\n</code></pre></p> <p>Die Methode <code>getClass()</code> liefert also den konkretesten (speziellsten) Laufzeittypen zur\u00fcck. Mit <code>instanceof</code> k\u00f6nnen alle Laufzeittypen abgefragt werden. F\u00fcr eine beliebige Variable <code>var</code>, egal welchen Referenztyps, gilt immer, dass <code>var instanceof Object</code> <code>true</code> ergibt, d.h. jede Referenzvariable ist immer auch vom (Laufzeit-)Typ <code>Object</code>. </p>"},{"location":"object/#die-objektmethode-tostring","title":"Die Objektmethode <code>toString()</code>","text":"<p>In jeder Klasse, die wir erstellen, erben wir von <code>Object</code> die Objektmethode <code>toString()</code>. Wenden wir diese Methode also einmal f\u00fcr unsere Klasse <code>Viereck</code>an: <pre><code>Viereck v = new Viereck(10,20,30,40);\nSystem.out.println(v.toString());\n</code></pre> Dann erhalten wir eine etwas kryptische Ausgabe: <pre><code>Viereck@279f2327\n</code></pre> wobei <code>Viereck</code> f\u00fcr die Klasse steht und <code>@279f2327</code> scheint irgendeine Referenzadresse zu sein. Interessant an der <code>toString()</code>-Methode ist, dass wir die gleiche Ausgabe auch dann erzielen, wenn wir nur  <pre><code>Viereck v = new Viereck(10,20,30,40);\nSystem.out.println(v);\n</code></pre> aufrufen, also der Methode <code>System.out.println()</code> nur <code>v</code> und nicht <code>v.toString()</code> \u00fcbergeben. Das liegt daran, dass <code>System.out.println()</code> \u00fcberladen ist und - unter anderem - die beiden Implementierungen  <pre><code>System.out.println(String s) {}\nSystem.out.println(Object o) {}\n</code></pre> existieren. Wenn wir <code>System.out.println(v.toString());</code> aufrufen, wird die Implementierung von <code>System.out.println(String s) {}</code> verwendet (der <code>String s</code> wird ausgegeben). Wenn wir <code>System.out.println(v);</code> aufrufen, wird die Implementierung von <code>System.out.println(Object o) {}</code> verwendet und dabei wird n\u00e4mlich <code>System.out.println(o.toString());</code> aufgerufen. </p> <p>Wenn wir nun also die Methode <code>toString()</code> \u00fcberschreiben (ist ja von <code>Object</code> geerbt), dann gewinnen wir zwei Effekte:</p> <ol> <li>wir erstellen eine textuelle Repr\u00e4ssentation unserer Objekte und</li> <li>wir m\u00fcssen <code>System.out.println()</code> nur noch die Referenzvariable <code>ref</code> auf unser Obejkt \u00fcbergeben (und nicht <code>ref.toString()</code>)</li> </ol> <p>Erweitern wir also die Klasse <code>Viereck</code> um eine Implementierung der <code>toString()</code>-Methode: <pre><code>public class Viereck\n{\n    protected int a,b,c,d;          // Seiten\n\n    public Viereck(int a, int b, int c, int d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public int umfang()\n    {\n        return this.a + this.b + this.c + this.d;\n    }\n\n    public void print()\n    {\n        System.out.print(this.toString());      // siehe unten\n        System.out.println(\" Umfang des Vierecks : \" + this.umfang());\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"[ a=\" + this.a + \", b=\" + this.b + \", c=\" + this.c + \", d=\" + this.d + \" ] \";\n    }\n}\n</code></pre></p> <p>Wir verwenden auch hier die <code>@Override</code>-Annotation, um dem Compiler zu sagen, dass wir die <code>toString()</code>-Methode von <code>Object</code> \u00fcberschreiben wollen (nicht, dass wir z.B. ausversehen <code>tostring()</code> schreiben und somit eine neue Objektmethode erstellen). In der <code>toString()</code>-Methode implementieren wir eine geeignete Repr\u00e4sentation des Objektes (hier die Seitenl\u00e4ngen des Vierecks). Nun erzeugen die Anweisungen <pre><code>Viereck v = new Viereck(10,20,30,40);\nSystem.out.println(v);      // entspricht System.out.println(v.toString());\n</code></pre> eine deutlich bessere Ausgabe, n\u00e4mlich <pre><code>[ a=10, b=20, c=30, d=40 ]\n</code></pre></p> <p>Wir sollten uns angew\u00f6hnen, die <code>toString()</code>-Methode immer, d.h. in allen Klassen, die wir erstellen, zu \u00fcberschreiben!</p>"},{"location":"object/#die-objektmethode-equals","title":"Die Objektmethode <code>equals()</code>","text":"<p>Wir wiederholen zun\u00e4chst nochmal in K\u00fcrze den Abschnitt \u00fcber Referenzvergleiche von Objekten. Angenommen, wir haben folgende Vierecke: <pre><code>Viereck v3 = new Viereck(10,20,30,40);\nViereck v4 = new Viereck(10,20,30,40);\nSystem.out.println(v3==v4);     // Referenzvergleich!! false - zwei Objekte\n</code></pre> Wir k\u00f6nnten auf die Idee kommen, dass <code>v3==v4</code> <code>true</code> ergibt, weil f\u00fcr uns die beiden Objekte von <code>Viereck</code> gleich sind. Aber woher soll der Compiler oder die Laufzeitumgebung wissen, dass diese <code>Viereck</code>-Objekte gleich sind? </p> <p>Der Operator <code>==</code> vergleicht nur die Referenzen und ist <code>false</code>, wenn die Referenzen auf zwei verschiedene Objekte zeigen. </p> <p>Mithilfe der <code>equals()</code>-Methode k\u00f6nnen wir definieren, wann Objekte der Klasse gleich sein sollen. Wir k\u00f6nnen aber nicht den Operator <code>==</code> \u00fcberschreiben. Dieser bleibt f\u00fcr Referenztypen immer ein Referenzvergleich!</p> <p>Wir wollen unsere Klasse <code>Viereck</code> also um eine <code>equals()</code>-Methode erweitern und in dieser <code>equals()</code>-Methode festlegen, wann zwei <code>Viereck</code>-Objekte gleich sein sollen (wenn ihre Seitenl\u00e4ngen gleich sind). Wir versuchen folgendes:</p> <pre><code>public class Viereck\n{\n    protected int a,b,c,d;          // Seiten\n\n    public Viereck(int a, int b, int c, int d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public int umfang()\n    {\n        return this.a + this.b + this.c + this.d;\n    }\n\n    public void print()\n    {\n        System.out.print(this.toString());      // siehe unten\n        System.out.println(\" Umfang des Vierecks : \" + this.umfang());\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"[ a=\" + this.a + \", b=\" + this.b \n        + \", c=\" + this.c + \", d=\" + this.d + \" ] \";\n    }\n\n    @Override\n    public boolean equals(Viereck v)\n    {\n        // Implementierung von equals()\n    }\n}\n</code></pre> <p>Das f\u00fchrt leider zu einem Fehler. Der Compiler beschwert sich dar\u00fcber, dass wir die geerbte <code>equals()</code>-Methode so gar nicht \u00fcberschreiben. Tats\u00e4chlich erben wir nicht <code>equals(Viereck v)</code>, sondern <code>equals(Object o)</code> (woher sollte <code>Object</code> auch <code>Viereck</code> kennen?). Wir m\u00fcssen also folgende Methode \u00fcberschreiben: <pre><code>@Override\npublic boolean equals(Object o)\n{\n    // Implementierung von equals()\n}\n</code></pre></p> <p>Nat\u00fcrlich erwarten wir, dass sich das aufrufende Viereck mit einem anderen Viereck vergleicht. Die Methode ist aber so implementiert, dass jedes beliebige Objekt als Parameter \u00fcbergeben werden kann. Theoretisch w\u00e4re also z.B. folgender Aufruf m\u00f6glich: <pre><code>Viereck v = new Viereck(10,20,30,40);\nPoint p = new Point(3,4);\nSystems.out.println(v.equals(p));\n</code></pre></p> <p>Das soll nat\u00fcrlich <code>false</code> ergeben. Die Implementierung von <code>equals(Object o)</code> muss folgende Bedingungen erf\u00fcllen:</p> <ol> <li>Null-Akzeptanz: f\u00fcr jede Referenz <code>x</code> ungleich <code>null</code> liefert <code>x.equals(null)</code> den Wert <code>false</code></li> <li>Reflexivit\u00e4t: f\u00fcr jede Referenz <code>x</code> ungleich <code>null</code> liefert <code>x.equals(x)</code> den Wert <code>true</code></li> <li>Symmetrie: wenn <code>x.equals(y)</code> <code>true</code> ergibt, dann muss auch <code>y.equals(x)</code> <code>true</code> ergeben (und umgedreht)</li> <li>Transitivit\u00e4t: wenn <code>x.equals(y)</code> und <code>y.equals(z)</code> jeweils <code>true</code> ergeben, dann muss auch <code>x.equals(z)</code> <code>true</code> ergeben</li> <li>Konsistenz: der Aufruf <code>x.equals(y)</code> muss immer den gleichen Wert ergeben</li> </ol> <p>Das h\u00f6rt sich komplizierter an, als es ist. Wir werden sehen, dass wir bei der Implementierung von <code>equals(Object o)</code> immer gleich vorgehen. Wir f\u00fchren zun\u00e4chst ein paar Pr\u00fcfungen durch:</p> <ol> <li>pr\u00fcfen, ob <code>null</code>-Referenzen vorliegen \u2192 (wenn ja, dann <code>false</code>)</li> <li>pr\u00fcfen, ob keine identischen Objekte verglichen werden (dasselbe Objekt vergleicht sich mit sich selbst) \u2192 (wenn ja, dann <code>true</code>)</li> <li>pr\u00fcfen, ob Objekte des gew\u00fcnschten Typs verglichen werden \u2192 (wenn nein, dann <code>false</code>)</li> </ol> <pre><code>@Override\npublic boolean equals(Object other)\n{\n    if(other==null) return false;       // Null-Akzeptanz\n    if(this==other) return true;        // Reflexivit\u00e4t\n    if(this.getClass() != other.getClass())\u00a0return false;           // ungleiche Typen\n\n    // wenn wir hier die Methode noch nicht verlassen haben, dann\n    // wissen wir, dass other vom Typ Viereck ist und auf ein \n    // Viereck-Objekt zeigt\n\n}\n</code></pre> <ul> <li>in Zeile <code>4</code> pr\u00fcfen wir, ob das als Parameter \u00fcbergebene Objekt \u00fcberhaupt existiert. Wenn nicht (Referenz <code>null</code>), geben wir <code>false</code> zur\u00fcck. </li> <li>in Zeile <code>5</code> pr\u00fcfen wir, ob das aufrufende Objekt dasselbe ist, wie das als Parameter \u00fcbergebene Objekt (vergleich mit sich selbst). Wenn ja, geben wir <code>true</code> zur\u00fcck. </li> <li>in Zeile <code>6</code> pr\u00fcfen wir, ob das aufrufende Objekt und das als Parameter \u00fcbergebene Objekt den gleichen Typ haben (also hier <code>Viereck</code>). Wenn nicht, geben wir <code>false</code> zur\u00fcck. </li> </ul> <p>Wenn diese Pr\u00fcfungen alle <code>false</code> waren, dann wissen wir danach, dass <code>other</code> vom (Laufzeit-)Typ <code>Viereck</code> ist und auf ein <code>Viereck</code>-Objekt zeigt. Nun k\u00f6nnen wir den eigentlichen Objektvergleich durchf\u00fchren. Dazu m\u00fcssen wir jedoch <code>other</code> in den Typ <code>Viereck</code> konvertieren:</p> <ol> <li>da beide Objekte vom gleichen Typ sind (<code>Viereck</code>), kann das Objekt aus dem Parameter in den vergleichenden Typ umgewandelt werden (z.B. <code>Object</code> nach <code>Viereck</code>)</li> <li>dann k\u00f6nnen wir die Eigenschaften vergleichen, die f\u00fcr die \u201eGleichheit\u201c relevant sind (z.B. <code>radius</code> bei <code>Circle</code>, <code>kontonummer</code> bei <code>Konto</code>, <code>a</code> und <code>b</code> bei <code>Rectangle</code> usw. - hier: die vier Seiten des Vierecks <code>a</code>, <code>b</code>, <code>c</code> und <code>d</code>)</li> </ol> <pre><code>@Override\npublic boolean equals(Object other)\n{\n    if(other==null) return false;       // Null-Akzeptanz\n    if(this==other) return true;        // Reflexivit\u00e4t\n    if(this.getClass() != other.getClass())\u00a0return false;           // ungleiche Typen\n\n    // wenn wir hier die Methode noch nicht verlassen haben, dann\n    // wissen wir, dass other vom Typ Viereck ist und auf ein \n    // Viereck-Objekt zeigt\n\n    // jetzt kommt der eigentliche Objektvergleich auf Gleichheit\n    // damit wir ueberhaupt auf die Objektvariablen a, b, c, d von other\n    // zugreifen k\u00f6nnen, muessen wir es nach Viereck konvertieren\n    Viereck otherV = (Viereck)other;\n    return this.a==otherV.a &amp;&amp; this.b==otherV.b &amp;&amp; this.c==otherV.c  &amp;&amp; this.d==otherV.d;\n}\n</code></pre> <ul> <li>in Zeile <code>15</code> f\u00fchren wir eine explizite Typkonvertierung durch. Wir wissen an dieser Stelle ja bereits (aus Zeile <code>6</code>), dass es sich bei <code>other</code> um den Laufzeittyp <code>Viereck</code> handelt. Die Konvertierung klappt also. Weil <code>other</code> den Compilertyp <code>Object</code> hat, k\u00f6nnen wir f\u00fcr <code>other</code> nicht auf die Objektvariablen <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> zugreifen. Wir m\u00fcssen also konvertieren. </li> <li>in Zeile <code>16</code> f\u00fchren wir dann den eigentlichen Vergleich durch. Hier vergleichen wir die Seiten miteinander. Wir ber\u00fccksichtigen nicht, dass Vierecke auch gedreht gleich sein k\u00f6nnen. Das ist Auslegungssache und Ihre Entscheidung, wann Objekte tats\u00e4chlich gleich sein sollen. </li> </ul> <p>Jetzt k\u00f6nnen wir die Gleichheit von zwei <code>Viereck</code>-Objekten mithilfe von <code>equals()</code> ermitteln: <pre><code>Viereck v3 = new Viereck(10,20,30,40);\nViereck v4 = new Viereck(10,20,30,40);\nViereck v5 = new Viereck(11,22,33,44);\n\nSystem.out.println(v3.equals(v4));  // true\nSystem.out.println(v3.equals(v3));  // true\nSystem.out.println(v4.equals(v3));  // true\nSystem.out.println(v3.equals(v5));      // false\nSystem.out.println(v3.equals(null));    // false\n</code></pre></p> <p>Success</p> <p>Mithilfe der <code>equals()</code>-Methode haben wir eine einheitliche M\u00f6glichkeit, die Gleichheit von Objekten zu definieren. Die Implementierung der <code>equals()</code>-Methode folgt immer dem gleichen Schema. Wir f\u00fchren zun\u00e4chst die drei Pr\u00fcfungen auf Null-Akzeptanz, Reflexivit\u00e4t und ungleiche Typen aus, konvertieren <code>other</code> dann in unseren Klassentyp und f\u00fchren den eigentlichen Vergleich auf Gleichheit der Objekte durch. Wir sollten <code>equals()</code>, wie auch <code>toString()</code>, von nun an f\u00fcr alle unsere Klassen implmentieren. </p>"},{"location":"object/#die-objektmethode-hashcode","title":"Die Objektmethode <code>hashCode()</code>","text":"<p>Die Idee der <code>hashCode()</code>-Methode besteht darin, ein Objekt durch eine ganze Zahl zu rep\u00e4sentieren. Diese Zahl wird verwendet, um Objekte in sogenannte hashbasierte Container einzusortieren. Das sind Datenstrukturen, in denen viele Objekte gespeichert werden und die Speicherung \u00fcber einen Hashwert verteilt wird. Wir werden solche hashbasierten Container im 2. Semester kennenlernen, wenn wir uns mit Collections besch\u00e4ftigen. Zum jetzigen Stand k\u00fcmmern wir uns um diese Methode nicht weiter, wollen sie aber doch immer genau dann \u00fcberschreiben, wenn wir die <code>equals()</code>-Methode implementieren. Es soll folgendes gelten:</p> <p>Wenn zwei Objekte laut <code>equals()</code>-Methode gleich sind, dann erzeugen sie auch den gleichen Hashcode mit der <code>hashCode()</code>-Methode. </p> <p>Es soll also gelten: wenn <code>x.equals(y)==true</code>, dann <code>x.hashCode()==y.hashCode()</code>. Wenn wir also die <code>equals()</code>-Methode \u00fcberschreiben, dann \u00fcberschreiben wir auch die <code>hashCode()</code>-Methode, um die genannte Bedingung zu erf\u00fcllen. Da wir f\u00fcr das <code>Viereck</code> die Seitenl\u00e4ngen verwendet haben, um die Gleichheit von zwei Vierecken zu definieren, k\u00f6nnen wir diese Seitenl\u00e4ngen auch verwenden, um einen HashCode zu erzeugen:</p> <pre><code>@Override\npublic int hashCode()\n{\n    return this.a + this.b + this.c + this.d;\n}\n</code></pre> <p>Mit dieser Implementierung ist gegeben, dass zwei Vierecke, die laut <code>equals()</code>-Methode gleich sind (haben die gleichen Seitenl\u00e4ngen), auch den gleichen HashCode haben. Es muss (zum Gl\u00fcck) nicht gelten, dass zwei Vierecke, die laut <code>equals()</code>-Methode ungleich sind, einen unterschiedlichen HashCode haben m\u00fcssen. </p>"},{"location":"object/#die-objektmethode-clone","title":"Die Objektmethode <code>clone()</code>","text":"<p>Die Objektmethode <code>clone()</code> liefert einen identischen Clone (eine identische Kopie) des aufrufenden Objektes zur\u00fcck. Wir wollen uns an dieser Stelle gar nicht weiter detailliert um <code>clone()</code> k\u00fcmmern. Wir kommen darauf zur\u00fcck, wenn wir im 2. Semester Interfaces kennenlernen. Die Methode <code>clone()</code> ist auch nicht unumstritten - das aber nur zur Information, wie auch ein Beispiel f\u00fcr die folgende m\u00f6gliche Implementierung der Methode in der Klasse <code>Viereck</code>. </p> <pre><code>@Override\nprotected Object clone()\n{\n    return new Viereck(this.a, this.b, this.c, this.d);\n}\n</code></pre> <p>Das dient nur zum Verst\u00e4ndinis der Idee von <code>clone()</code>. Im Gegensatz zu <code>toString()</code> und <code>equals()</code> (und also auch <code>hashCode()</code>) werden wir <code>clone()</code> nicht so oft \u00fcberschreiben. </p> <p>Success</p> <p>Wir haben mit <code>Object</code> die Mutter aller Klassen in Java kennengelernt. Jede Klasse in Java erbt (implizit) von <code>Object</code>. Jede Referenzvariable ist somit (auch) vom Laufzeittyp <code>Object</code>. F\u00fcr alle Klassen, die wir in Zukunft schreiben, werden wir die Objektmethoden <code>toString()</code> und <code>equals()</code> (und also auch <code>hashCode()</code>) \u00fcberschreiben. </p>"},{"location":"object/#polymorphie","title":"Polymorphie","text":"<p>Polymorphie geh\u00f6rt neben der Datenkapselung und der Vererbung zu den wesentlichen Konzepten der objektorientierten Programmierung. Die Grundidee der Polymorphie ist, dass es verschiedene Methoden gibt, die gleich hei\u00dfen und dass entweder der Compiler (statisch) oder die Laufzeitumgebung (dynamisch) ausw\u00e4hlt, welche dieser Methoden ausgef\u00fchrt wird. Man unterscheidet zwischen statischer und dynamischer Polymorphie. </p>"},{"location":"object/#statische-polymorphie","title":"Statische Polymorphie","text":"<p>Statische Polymorphie kennen wir als \u00dcberladen von Methoden. Der Compiler kann (an der Methodensignatur) erkennen, welche Methode aufgerufen wird. Angenommen, wir haben folgende Methoden: <pre><code>public void printArray(int[] arr)\n{\n    // Ausgabe eines int[]-Arrays\n}\n\npublic void printArray(char[] arr)\n{\n    // Ausgabe eines char[]-Arrays\n}\n\npublic void printArray(double[] arr)\n{\n    // Ausgabe eines double[]-Arrays\n}\n\npublic void printArray(String[] arr)\n{\n    // Ausgabe eines String[]-Arrays\n}\n\npublic void printArray(Object[] arr)\n{\n    // Ausgabe eines Object[]-Arrays\n}\n</code></pre> , dann wird durch den Typs des als Parameter \u00fcbergebenen Arrays klar, welche dieser Methoden aufgerufen wird. Es wird also unter vielen Implementierungen durch den Compiler die \"richtige\" ausgew\u00e4hlt. </p>"},{"location":"object/#dynamische-polymorphie","title":"Dynamische Polymorphie","text":"<p>Dynamische Polymorphie wird durch Vererbung und insbesondere durch das \u00dcberschreiben von Methoden erm\u00f6glicht. Wir betrachten folgendes Beispiel - gegeben sind drei Klassen <code>Base</code>, <code>Sub</code> und <code>SubSub</code>:</p> <pre><code>public class Base \n{\n    public void methodBase()\n    {\n        System.out.println(\"Base\");\n    }\n}\n</code></pre> <pre><code>public class Sub extends Base \n{\n    @Override\n    public void methodBase()\n    {\n        System.out.println(\"Sub\");\n    }\n}\n</code></pre> <pre><code>public class SubSub extends Sub \n{\n    @Override\n    public void methodBase()\n    {\n        System.out.println(\"SubSub\");\n    }\n}\n</code></pre> <p>Die Klasse <code>Sub</code> erbt von <code>Base</code> und die Klasse <code>SubSub</code> erbt von <code>Sub</code>. In beiden Kindklassen wird die Methode <code>methodBase()</code> \u00fcberschrieben, die in <code>Base</code> erstmalig definiert wird. Angenommen, wir haben nun folgende <code>main()</code>-Methode:</p> <pre><code>public void main() \n{\n    Base[] base = new Base[3];\n    base[0] = new Base();       // Compilertyp Base, Laufzeittyp Base\n    base[1] = new Sub();        // Compilertyp Base, Laufzeittyp Sub\n    base[2] = new SubSub();     // Compilertyp Base, Laufzeittyp SubSub\n\n    base[0].methodBase();       // Base\n    base[1].methodBase();       // Sub\n    base[2].methodBase();       // SubSub\n}   \n</code></pre> <p>Wir erstellen uns also ein Array, deren Elemente vom Compilertyp <code>Base</code> sind. Das erste Element ist eine Referenz auf ein <code>Base</code>-Objekt, das zweite Element ist eine Referenz auf ein <code>Sub</code>-Objekt und das dritte zeigt auf ein <code>SubSub</code>-Objekt. F\u00fcr alle drei Referenzvariablen wird nun die <code>methodBase()</code>-Methode aufgerufen. Es werden folgende Ausgaben erzeugt:</p> <pre><code>Base\nSub\nSubSub\n</code></pre> <p>Das bedeutet, dass die Laufzeitumgebung von Java die speziellstm\u00f6gliche Implementierung der Methode ausw\u00e4hlt. Mit speziellstm\u00f6glich ist gemeint, dass die Implementierung des speziellsten Laufzeittypen ausgew\u00e4hlt wird. In der Vererbungshierarchie <code>SubSub</code>\u2192 <code>Sub</code> \u2192 <code>Base</code> ist <code>SubSub</code> der speziellste Typ, <code>Sub</code> ist spezieller als <code>Base</code>, aber allgemeiner als <code>Sub</code> und <code>Base</code> ist allgemeiner als <code>Sub</code> und erst recht als <code>SubSub</code>. </p> <ul> <li>Der speziellste Laufzeittyp von <code>base[0]</code> ist <code>Base</code> und somit wird die <code>methodBase()</code>-Implementierung der Klasse <code>Base</code> verwendet. </li> <li>Der speziellste Laufzeittyp von <code>base[1]</code> ist <code>Sub</code> und somit wird die <code>methodBase()</code>-Implementierung der Klasse <code>Sub</code> verwendet. </li> <li>Der speziellste Laufzeittyp von <code>base[2]</code> ist <code>SubSub</code> und somit wird die <code>methodBase()</code>-Implementierung der Klasse <code>SubSub</code> verwendet. </li> </ul> <p>Success</p> <p>Polymorphie ist ein tolles Konzept der objektorientierten Programmierung. Der Nutzen von Polymorphie wird uns jetzt noch nicht vollst\u00e4ndig deutlich. Wir werden aber immer wieder darauf hinweisen, wenn wir Polymorphie im Einsatz sehen. Vielleicht erkennen Sie ja jetzt besser, warum z.B. die Methode <code>System.out.println(Object o)</code> so funktioniert. Sp\u00e4testens, wenn wir Interfaces behandeln, kommen wir auf dieses Konzept zur\u00fcck. </p>"},{"location":"objekte1/","title":"Klassen und Objekte","text":"<p>Wir haben Datentypen kennengelernt, in denen wir bestimmte Werte speichern konnten, z.B. <code>int</code> f\u00fcr ganze Zahlen, <code>boolean</code> f\u00fcr Wahrheitswerte, <code>char</code> f\u00fcr einzelne Zeichen, <code>double</code> f\u00fcr Gleitkommawerte usw. Eine Variable von so einem Wertetyp kann immer genau einen Wert speichern. Das gen\u00fcgt meistens jedoch nicht. Das haben wir bereits gemerkt, als wir nicht nur ein Zeichen speichern wollten, sondern eine ganze Zeichenkette. Dazu haben wir den Datentyp <code>String</code> verwendet. Bei diesem Datentyp war es dann nicht nur so, dass wir ganze Zeichenketten speichern konnten, sondern dazu kamen auch noch Methoden, die in diesem Datentyp definiert sind, die wir zur Manipulation von solchen Zeichenketten verwenden k\u00f6nnen, z.B. <code>charAt()</code>, <code>length()</code>, <code>substring()</code> usw. </p> <p>Wenn wir nun z.B. <code>Auto</code>s speichern wollen oder <code>Adresse</code>n oder <code>Studentin</code>nnen, dann gibt es daf\u00fcr keinen passenden Datentyp in Java. Das wollen wir nun \u00e4ndern. Wir bauen uns eigene Datentypen. </p> <p>Wenn wir uns die Welt betrachten, dann besteht diese aus lauter Objekten, die miteinander in Beziehung stehen. Man ganz konkret \u00fcber bestimmte Objekte sprechen:</p> <ul> <li>\u201edas ist ein sch\u00f6ner Stuhl\u201c</li> <li>\u201edas ist ein teurer Tisch\u201c</li> <li>\u201edas Auto ist blau\u201c</li> </ul> <p>oder ganz allgemein \u00fcber eine Klasse von Objekten:</p> <ul> <li>\u201eComputer machen immer, was sie wollen\u201c</li> <li>\u201edie Bahnen kommen immer zu sp\u00e4t\u201c</li> <li>\"Klausuren sind immer schwer\"</li> </ul> <p>In der Welt des objektorientierten Programmierens sind die Klassen die \"Muster\" oder die \"Bauanleitungen\" f\u00fcr konkrete Objekte. Mit Klassen beschreiben wir die allgemeinen Eigenschaften, die f\u00fcr alle Objekte dieser Klasse gelten. Klassen beschreiben</p> <ul> <li>eine Struktur der Objekte (das sind die Objektvariablen) und</li> <li>ein Verhalten dieser Objekte (das sind die Objektmethoden). </li> </ul> <p>Insgesamt sprechen wir bei der Struktur und dem Verhalten von den Eigenschaften einer Klasse. Eine Klasse ist ein Datentyp und jeder \"Wert\" ist ein konkretes Objekt von diesem Typ. Von einer Klasse k\u00f6nnen wir beliebig viele Objekte erzeugen. </p> <p>Beachte!</p> <p>In der objektorientierten Programmierung unterscheiden wir sehr genau zwischen Objekten und Werten. Werte sind soetwas wie <code>4</code>, <code>true</code>, <code>5.5</code> usw. Solche Werte haben kein Verhalten. Objekte haben aber ein Verhalten (die Objektmethoden - siehe z.B. f\u00fcr <code>String</code> die Methoden <code>charAt()</code>, <code>length()</code>, <code>substring()</code>). Wir werden sehr detailliert auf die Unterschiede zwischen Werten und Objekten eingehen. Die Datentypen, die wir erstellen, sind sogenannte Referentypen. Eine Variable von so einem Referenztyp zeigt auf (referenziert) ein Objekt.</p>"},{"location":"objekte1/#ein-erster-eigener-datentyp-adresse","title":"Ein erster eigener Datentyp <code>Adresse</code>","text":"<p>Wir erstellen uns einfach mal einen neuen Datentyp. Wir nennen ihn <code>Adresse</code>. In unserer IDE (Eclipse) erstellen wir eine neue Klasse <code>Adresse</code>. Achtung! Wenn wir einen Datentyp erzeugen, dann ohne <code>main()</code>-Methode. Die <code>main()</code>-Methode ist keine Eigenschaft eines Datentyps. Unsere neue Klasse sieht also so aus:</p> Adresse.java <pre><code>public class Adresse\n{\n\n}\n</code></pre> <p>Wir erstellen uns eine weitere Klasse (am besten im gleichen Paket) mit <code>main()</code>-Methode - wir nennen die Klasse <code>Testklasse</code>:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1;\n\n    }\n}\n</code></pre> <p>In der <code>main()</code>-Methode k\u00f6nnen wir nun bereits den Datentyp verwenden, um eine Variable zu deklarieren. Wir nennen die Variable <code>adresse1</code> und weisen ihr den Typ <code>Adresse</code> zu. Wir haben unseren ersten eigenen Datentyp erstellt!</p>"},{"location":"objekte1/#eigenschaften-definieren","title":"Eigenschaften definieren","text":"<p>Unser Datentyp <code>Adresse</code> hat noch keine Eigenschaften. Als erstes definieren wir uns Objektvariablen f\u00fcr unsere Klasse:</p> Adresse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    public String strasse;\n    public int nummer;\n    public int postleitzahl;\n    public String wohnort;\n\n}\n</code></pre> <p>Die Struktur aller Objekte unserer Klasse sieht also wie folgt aus. Jedes Objekt vom Typ <code>Adresse</code> hat </p> <ul> <li>eine eigene Variable <code>strasse</code> (vom Typ <code>String</code>),</li> <li>eine eigene Variable <code>nummer</code> (vom Typ <code>int</code>),</li> <li>eine eigene Variable <code>postleitzahl</code> (vom Typ <code>int</code>),</li> <li>eine eigene Variable <code>wohnort</code> (vom Typ <code>String</code>).</li> </ul>"},{"location":"objekte1/#objektvariablen-sind-global","title":"Objektvariablen sind global!","text":"<p>Bis jetzt hatten wir unsere Variablen immer lokal in einer Methode deklariert. Diese Variablen waren nur in der Methode sichtbar und existierten auch nur in der Methode, in der sie deklariert wurden. Siehe dazu Sichtbarkeit und Lebensdauer von lokalen Variablen. </p> <p>Objektvariablen sind in der Klasse deklariert, nicht in einer Methode - sie sind global. Objektvariablen sind deshalb in der gesamten Klasse sichtbar, d.h. es kann in der gesamten Klasse daruf zugegriffen werden (in jeder Methode der Klasse). Objektvariablen existieren f\u00fcr ein konkretes Objekt. Jedes Objekt hat seine eigenen Objektvariablen. Diese existieren f\u00fcr das Objekt also so lange, solange das Objekt existiert. </p> <p>Objektvariablen sind global und sind in allen Methoden der Klasse sichtbar, d.h. es kann in allen Methoden der Klasse auf die Objektvariablen zugegriffen werden.</p>"},{"location":"objekte1/#objektmethode-hinzufugen","title":"Objektmethode hinzuf\u00fcgen","text":"<p>Jetzt wollen wir auch noch ein Verhalten implementieren und definieren uns dazu eine Objektmethode:</p> Adresse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    public String strasse;\n    public int nummer;\n    public int postleitzahl;\n    public String wohnort;\n\n    // --- Objektmethoden ------\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n    }       \n}\n</code></pre> <p>Achtung! Objektmethoden sind nicht <code>static</code>! Methoden, die als <code>static</code> deklariert sind, k\u00f6nnen ausgef\u00fchrt werden, ohne ein Objekt der Klasse zu erzeugen. Von unseren bisherigen Klassen <code>Uebung1</code>, <code>Uebung2</code>, <code>Aufgabe1</code>, <code>Aufgabe2</code> usw. haben wir keine Objekte erzeugt und wollten aber die Methoden trotzdem aufrufen. Wir haben sie deshalb als <code>static</code> deklariert. Von den Klassen, die wir nun als <code>Datentyp</code> implementieren, wollen wir Objekte erzeugen. Deshalb werden die Methoden nicht als <code>static</code> deklariert. Objektmethoden k\u00f6nnen nur von Objekten aufgerufen werden! Jedes Objekt der Klasse <code>Adresse</code> hat seine eigene Methode <code>getAdresse()</code>. </p>"},{"location":"objekte1/#objekte-erzeugen-der-konstruktor","title":"Objekte erzeugen - der Konstruktor","text":"<p>Wir haben jetzt einen \"Bauplan\" f\u00fcr alle Objekte vom Datentyp <code>Adresse</code> erzeugt. Nun wollen wir nach diesem Bauplan Objekte von der Klasse (vom Datentyp) <code>Adresse</code> erzeugen. Das geschieht mithilfe des Konstruktors.</p> <p>der Konstruktor einer Klasse hei\u00dft genau wie die Klasse selbst, ist aber eine Methode (z.B. <code>Adresse()</code>)</p> <p>Um ein Objekt der Klasse zu erzeugen, verwenden wir das Schl\u00fcsselwort <code>new</code> und rufen dann den Konstruktor der Klasse auf:</p> <p><code>new Klassenname();</code> </p> <p>Wir erzeugen in der <code>main()</code>-Methode der <code>Testklasse</code> zwei Objekte der Klasse <code>Adresse</code>:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse();       // erstes Objekt erzeugt\n        Adresse adresse2 = new Adresse();       // zweites Objekt erzeugt\n    }\n}\n</code></pre> <p>Das generelle Vorgehen bei der Erzeugung eines Objektes zeigt die folgende Abbildung:</p> <p></p> <p>Wir haben nun zwei Objekte vom Typ <code>Adresse</code> erstellt. Die Referenzvariable <code>adresse1</code> zeigt auf das erste Objekt (Sie k\u00f6nnen auch sagen, dass <code>adresse1</code> der Name des ersten Objektes ist) und die Referenzvariable <code>adresse2</code> zeigt auf das zweite Objekt. Jedes dieser beiden Objekte hat seine eigenen Objektvariablen <code>strasse</code>, <code>nummer</code>, <code>postleitzahl</code> und <code>wohnort</code> und seine eigene Objektmethode <code>getAdresse()</code>. Wir werden jetzt auf diese Eigenschaften zugreifen.</p>"},{"location":"objekte1/#zugriff-auf-objekteigenschaften-punktnotation","title":"Zugriff auf Objekteigenschaften - Punktnotation","text":"<p>Auf die Eigenschaften eines Objektes k\u00f6nnen wir \u00fcber die Referenzvariable mittels Punktnotation zugreifen. Wir kennen das bereits z.B. von <code>Random</code>, wenn wir \u00fcber die Variable <code>r</code> auf die <code>nextInt()</code>-Methode zugreifen <code>r.nextInt()</code> oder von <code>String</code> mit dem Zugriff <code>pi.charAt()</code> usw. Die Syntax ist also wie folgt:</p> <p><code>referenzVariable.eigenschaft</code> </p> <p>Wir verwenden die Punktnotation f\u00fcr unsere Objekte vom Typ <code>Adresse</code>, um ihnen Werte f\u00fcr die Objektvariablen zuzuweisen und jeweils auf die Objektmethode zuzugreifen:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse();\n        Adresse adresse2 = new Adresse();\n\n        adresse1.strasse = \"Wilhelminenhofstr.\";\n        adresse1.nummer = 75;\n        adresse1.postleitzahl = 12459;\n        adresse1.wohnort = \"Berlin\";\n\n        adresse2.strasse = \"Treskowallee\";\n        adresse2.nummer = 8;\n        adresse2.postleitzahl = 10318;\n        adresse2.wohnort = \"Berlin\";\n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n    }\n}\n</code></pre> <p>Wir weisen also den jeweiligen Objektvariablen der beiden Objekte Werte zu und geben diese jeweils mithilfe der <code>getAdresse()</code>-Methode aus. Es ist ganz wichtig, zu verstehen, dass jedes Objekt seine eigenen Objektvariablen und seine eigenen Objektmethoden hat. Zugriff auf diese Variablen und Methoden gibt es stets nur \u00fcber ein Objekt!</p> <p>Die Ausgabe f\u00fcr obiges Beispiel sieht so aus:</p> <pre><code>Wilhelminenhofstr. 75 in 12459 Berlin\nTreskowallee 8 in 10318 Berlin\n</code></pre> <p>Alle Objekte werden also nach dem gleichen \"Bauplan\" erstellt. Alle Objekte vom Typ <code>Adresse</code> haben die Eigenschaften:</p> <ul> <li><code>strasse</code>, </li> <li><code>nummer</code>, </li> <li><code>postleitzahl</code>,  </li> <li><code>wohnort</code> und </li> <li><code>getAdresse()</code></li> </ul> <p>Wenn wir die Klasse <code>Adresse</code> \u00e4ndern, dann \u00e4ndern sich auch die Eigenschaften entsprechend f\u00fcr alle Objekte dieser Klasse. </p>"},{"location":"objekte1/#datenkapselung-information-hiding-das-schlusselwort-private","title":"Datenkapselung (Information Hiding) - das Schl\u00fcsselwort <code>private</code>","text":"<p>Ein wesentlicher Grundsatz der objektorientierten Programmierung ist das Prinzip der Datenkapselung (auch data hiding oder information hiding genannt). Dieses Prinzip dient dem Datenschutz. Wir wollen vermeiden, dass</p> <ul> <li>Unbefugte die Struktur (die Daten) unserer Objekte kennen und</li> <li>Unbefugte die Daten \u00e4ndern k\u00f6nnen, ohne dass wir es erlauben. </li> </ul> <p>Angenommen, Sie haben eine Klasse <code>Konto</code> und es w\u00e4re m\u00f6glich, ganz einfach auf ihre <code>pin</code> zuzugreifen. Das w\u00e4re fatal. Bereits der lesende Zugriff darauf k\u00f6nnte sch\u00e4dlich sein, aber genau so \u00e4rgerlich w\u00e4re es, wenn die <code>pin</code> einfach durch Fremde ge\u00e4ndert werden k\u00f6nnte. Wir wollen deshalb sowohl den lesenden als auch den schreibenden Zugriff auf unsere Daten (auf unsere Objektvariablen) verbieten. Dazu deklarieren wir unsere Objektvariablen als <code>private</code>:</p> Adresse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    private String strasse;         // Zugriff nur innerhalb der Klasse\n    private int nummer;             // Zugriff nur innerhalb der Klasse\n    private int postleitzahl;       // Zugriff nur innerhalb der Klasse\n    private String wohnort;         // Zugriff nur innerhalb der Klasse\n\n    // --- Objektmethoden ------\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n    }       \n}\n</code></pre> <p>Wir haben die Sichtbarkeit der Objektvariablen in unserer Klasse ge\u00e4ndert. Vorher waren die Objektvariablen als <code>public</code> deklariert. Das f\u00fchrte dazu, dass sie von allen anderen Klassen gelesen und geschrieben werden konnten (z.B. von unserer <code>Testklasse</code>). Indem wir die Variablen als <code>private</code> deklarieren, ist der Zugriff darauf au\u00dferhalb unserer Klasse nicht mehr m\u00f6glich. </p> <p>Wenn wir uns jetzt unsere <code>Testklasse</code> anschauen, dann sehen wir Fehler:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse();\n        Adresse adresse2 = new Adresse();\n\n        adresse1.strasse = \"Wilhelminenhofstr.\";    // Fehler: The field Adresse.strasse is not visible\n        adresse1.nummer = 75;                       // Fehler: The field Adresse.nummer is not visible\n        adresse1.postleitzahl = 12459;              // Fehler: The field Adresse.postleitzahl is not visible\n        adresse1.wohnort = \"Berlin\";                // Fehler: The field Adresse.wohnort is not visible\n\n        adresse2.strasse = \"Treskowallee\";          // Fehler: The field Adresse.strasse is not visible\n        adresse2.nummer = 8;                        // Fehler: The field Adresse.nummer is not visible\n        adresse2.postleitzahl = 10318;              // Fehler: The field Adresse.postleitzahl is not visible\n        adresse2.wohnort = \"Berlin\";                // Fehler: The field Adresse.wohnort is not visible\n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n    }\n}\n</code></pre> <p>Die <code>Testklasse</code> l\u00e4sst sich nun nicht mehr compilieren und ausf\u00fchren. Auch lesende Zugriffe, z.B. <code>System.out.println(adresse1.wohnort);</code> sind nicht mehr m\u00f6glich. Beachten Sie aber, dass wir weiterhin die Methode <code>getAdresse()</code> aufrufen k\u00f6nnen. Sie ist als <code>public</code> deklariert und deshalb in anderen Klassen durch <code>Adresse</code>-Objekte ausf\u00fchrbar. Wir k\u00f6nnten auch die Methode als <code>private</code> deklarieren, dann w\u00fcrde auch sie nicht mehr ausf\u00fchrbar in anderen Klassen sein. </p> <p>Auf eine als <code>private</code> deklarierte Variable kann au\u00dferhalb der Klasse, in der sie deklariert ist, nicht zugegriffen werden.</p> <p>Eine als <code>private</code> deklarierte Methode kann au\u00dferhalb der Klasse, in der sie definiert ist, nicht ausgef\u00fchrt (aufgerufen) werden. </p> <p>Wie k\u00f6nnen wir unseren Objektvariablen aber nun Werte zuweisen? Daf\u00fcr gibt es zwei Antworten</p> <ol> <li>durch einen parametrisierten Konstruktor und</li> <li>durch sogenannte Setter</li> </ol> <p>Wir betrachten zun\u00e4chst den parametrisierten Konstruktor. </p>"},{"location":"objekte1/#ein-eigener-konstruktor","title":"Ein eigener Konstruktor","text":"<p>Wir haben einen Konstruktor bereits kennengelernt. Ein Konstruktor ist eine Methode, die genau wie die Klasse hei\u00dft (also auch gro\u00dfgeschrieben) und mit runden Klammern. Wir haben den Konstruktor auch bereits verwendet, n\u00e4mlich zur Erzeugung von Objekten (genau daf\u00fcr ist er auch da). Betrachten wir nochmal die beiden Aufrufe:</p> <pre><code>Adresse adresse1 = new Adresse();   // Aufruf des Standardkonstruktors\nAdresse adresse2 = new Adresse();   // Aufruf des Standardkonstruktors\n</code></pre> <p>Wir konnten die Objekte vom Typ <code>Adresse</code> mithilfe des Konstrutors <code>Adresse()</code> erzeugen. Dies ist ein sogenannter Standardkonstruktor, denn er existiert automatisch f\u00fcr jede neue Klasse (f\u00fcr jeden Datentyp), die wir erstellen. Jetzt wollen wir aber einen eigenen Konstruktor definieren, den wir in Zukunft zur Erzeugung unserer <code>Adresse</code>-Objekte verwenden wollen. In unserem neuen Konstruktor wollen wir n\u00e4mlich bereits Werte als Parameter \u00fcbergeben, die f\u00fcr die Initialisierung der Objektvariablen verwendet werden sollen. Wir erweitern unsere Klasse <code>Adresse</code> um einen solchen Konstruktor:</p> Adresse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    private String strasse;         // Zugriff nur innerhalb der Klasse\n    private int nummer;             // Zugriff nur innerhalb der Klasse\n    private int postleitzahl;       // Zugriff nur innerhalb der Klasse\n    private String wohnort;         // Zugriff nur innerhalb der Klasse\n\n    // --- Konstruktor ---------\n    public Adresse(String str, int nr, int plz, String ort)\n    {\n        strasse = str;\n        nummer = nr;\n        postleitzahl = plz;\n        wohnort = ort;\n    }\n\n    // --- Objektmethoden ------\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n    }       \n}\n</code></pre> <p>In den Zeilen <code>10-16</code> haben wir einen solchen Konstruktor hinzugef\u00fcgt. Wir \u00fcbergeben dem Konstruktor vier Parameterwerte. Diese Werte werden verwendet, um unsere Objektvariablen zu initialisieren. Der Konstruktor wird aufgerufen, um ein neues Objekt zu erzeugen. Wir verwenden ihn hinter dem Schl\u00fcsselwort <code>new</code>. </p> <p>Bei der Definition eines solchen Konstruktors sind zwei Dinge zu beachten: </p> <ol> <li>Der Konstruktor hei\u00dft exakt wie die Klasse (also auch Gro\u00dfschreibung beachten).</li> <li>Der Konstruktor hat keinen R\u00fcckgabetyp (auch nicht <code>void</code>).</li> </ol> <p>Die Aufgabe eines Konstruktors ist einzig und allein Objekte der Klasse zu erzeugen. Die \"R\u00fcckgabe\" eines solchen Konstruktors ist also ein Objekt der Klasse. Theoretisch w\u00e4re der R\u00fcckhgabetyp hier also <code>Adresse</code>. Aber wie gesagt, bei der Definition eines Konstruktors gibt man keinen R\u00fcckgabetyp an!</p> <p>Wenn wir uns nun erneut die <code>Testklasse</code> anschauen, dann sind durch die Definition eines eigenen Konstruktors weitere Fehler hinzugekommen:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse();           // Fehler: The constructor Adresse() is undefined\n        Adresse adresse2 = new Adresse();           // Fehler: The constructor Adresse() is undefined\n\n        adresse1.strasse = \"Wilhelminenhofstr.\";    // Fehler: The field Adresse.strasse is not visible\n        adresse1.nummer = 75;                       // Fehler: The field Adresse.nummer is not visible\n        adresse1.postleitzahl = 12459;              // Fehler: The field Adresse.postleitzahl is not visible\n        adresse1.wohnort = \"Berlin\";                // Fehler: The field Adresse.wohnort is not visible\n\n        adresse2.strasse = \"Treskowallee\";          // Fehler: The field Adresse.strasse is not visible\n        adresse2.nummer = 8;                        // Fehler: The field Adresse.nummer is not visible\n        adresse2.postleitzahl = 10318;              // Fehler: The field Adresse.postleitzahl is not visible\n        adresse2.wohnort = \"Berlin\";                // Fehler: The field Adresse.wohnort is not visible\n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n    }\n}\n</code></pre> <p>Dadurch, dass wir einen eigenen Konstruktor geschrieben haben, existiert der Standardkonstruktor nicht mehr (siehe Zeilen <code>6</code> und <code>7</code>). Wir m\u00fcssen (und wollen ja auch) nun unseren eigenen Konstruktor verwenden, um Objekte zu erzeugen. Wir passen die <code>Testklasse</code> entsprechend an:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n        Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\");         \n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n    }\n}\n</code></pre> <p>In den Zeilen <code>6</code> und <code>7</code> verwenden wir nun den eigenen Konstruktor und \u00fcbergeben die Werte f\u00fcr die Objektvariablen als Parameter. Bei der Erzeugung der Objekte werden die Objektvariablen nun gleich initialisiert. Der direkte Zugriff auf die Objektvariablen wurde entfernt, da dieser aufgrund der <code>private</code>-Deklaration nicht mehr m\u00f6glich ist. Die Ausgaben in Zeilen <code>9</code> und <code>10</code> zeigen aber, dass die Objekte die entsprechenden Werte enthalten:</p> <pre><code>Wilhelminenhofstr. 75 in 12459 Berlin\nTreskowallee 8 in 10318 Berlin\n</code></pre> <p>Die Objekte erhalten somit gleich bei der Erzeugung alle Werte f\u00fcr die Objektvariablen und es ist nun auch nicht mehr m\u00f6glich, diese Werte zu \u00e4ndern. Ein direkter Zugriff auf die Objektvariablen ist nicht m\u00f6glich. Die einzigen Wertzuweisungen finden im Konstruktor statt. Objekte, deren Werte nicht mehr ge\u00e4ndert werden k\u00f6nnen, hei\u00dfen immutable objects (unver\u00e4nderliche Objekte). Sehr h\u00e4ufig ist es w\u00fcnschenswert, dass Objekte immutable sind - das vermeidet Fehler. Wir kommen (sehr viel sp\u00e4ter) nochmal darauf zu sprechen. </p> <p>Die einzige Schnittstelle (also die M\u00f6glichkeiten anderer Klassen unseren neuen Datentyp <code>Adresse</code> zu nutzen) unserer Klasse besteht nun aus zwei Methoden: dem Konstruktor zum Erzeugen eines Objektes und der Methode <code>getAdresse()</code>. Wenn wir aber z.B. nur den <code>wohnort</code> wissen wollen, dann ist es derzeit noch nicht m\u00f6glich. Wir wollen deshalb den lesenden Zugriff auf unsere Objektvariablen erlauben und definieren uns daf\u00fcr sogenannte Getter.</p>"},{"location":"objekte1/#getxxx-methoden-getter","title":"<code>getXXX()</code>-Methoden - Getter","text":"<p>Da die Objektvariablen alle als <code>private</code> deklariert sind, ist au\u00dferhalb der Klasse <code>Adresse</code> kein Zugriff auf diese Variablen m\u00f6glich. Wir k\u00f6nnen ihnen weder Werte zuweisen, noch deren Werte auslesen. Wir haben bereits gesagt, dass dies ein Feature der objektorientierten Programmierung ist, ein solches information hiding einfach durchf\u00fchren zu k\u00f6nnen. </p> <p>Wir k\u00f6nnen jetzt steuern, ob und wie der Zugriff doch m\u00f6glich sein soll. Wenn man bspw. den lesenden Zugriff erlauben m\u00f6chte, dann definiert man sich innerhalb der Klasse sogenannte <code>get</code>-Methoden (Getter). Eine solche <code>get</code>-methode gibt den Wert einer Objektvariablen zur\u00fcck. Es wird somit ein lesender Zugriff auf den Wert der Variablen erm\u00f6glicht. F\u00fcr unsere Klasse schreiben wir uns nun f\u00fcr jede Objektvariable einen eigenen Getter:</p> <ul> <li><code>getWohnort()</code> gibt den Wert von <code>wohnort</code> zur\u00fcck, ist also vom R\u00fcckgabetyp <code>String</code></li> <li><code>getPostleitzahl()</code> gibt den Wert von <code>postleitzahl</code> zur\u00fcck, ist also vom R\u00fcckgabetyp <code>int</code></li> <li><code>getStrasse()</code> gibt den Wert von <code>strasse</code> zur\u00fcck, ist also vom R\u00fcckgabetyp <code>String</code></li> <li><code>getNummer()</code> gibt den Wert von <code>nummer</code> zur\u00fcck, ist also vom R\u00fcckgabetyp <code>int</code></li> </ul> <p>Unsere Klasse <code>Adresse</code> sieht nun wie folgt aus:</p> Adresse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    private String strasse;\n    private int nummer;\n    private int postleitzahl;\n    private String wohnort;\n\n    // --- Konstruktor ---------\n    public Adresse(String str, int nr, int plz, String ort)\n    {\n        strasse = str;\n        nummer = nr;\n        postleitzahl = plz;\n        wohnort = ort;\n    }\n\n    // --- Objektmethoden ------\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n    }\n\n    public String getStrasse()\n    {\n        return strasse;\n    }\n\n    public int getNummer()\n    {\n        return nummer;\n    }\n\n    public int getPostleitzahl()\n    {\n        return postleitzahl;\n    }\n\n    public String getWohnort()\n    {\n        return wohnort;\n    }\n}\n</code></pre> <p>Unsere Schnittstelle hat sich also erweitert. Es sind jetzt auch mehr Methoden unserer Klasse <code>Adresse</code> nutzbar. Wir probieren die Methoden in unserer <code>Testklasse</code> aus:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n        Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\");         \n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n\n        System.out.println(\"Strasse Nr  : \" + adresse1.getStrasse() + \" \" +  adresse1.getNummer());\n        System.out.println(\"PLZ Wohnort : \" + adresse1.getPostleitzahl() + \" \" + adresse1.getWohnort());\n\n        System.out.println(\"Strasse Nr  : \" + adresse2.getStrasse() + \" \" +  adresse1.getNummer());\n        System.out.println(\"PLZ Wohnort : \" + adresse2.getPostleitzahl() + \" \" +  adresse1.getWohnort());\n    }\n}\n</code></pre> <p>Beachten Sie, dass der Aufruf unserer <code>get</code>-Methoden auch wieder nur f\u00fcr konkrete Objekte erfolgen kann, hier also f\u00fcr <code>adresse1</code> und <code>adresse2</code>. Wir greifen also wieder mittels Punktnotation auf diese Methoden zu. Wir sehen, dass wir nun mithilfe der Getter lesenden Zugriff auf die Objektvariablen haben - in der <code>Testklasse</code> k\u00f6nnen also die einzelnen Werte der Objektvariablen der jeweiligen <code>Adresse</code>-Objekte ausgelesen werden. </p> <p>Success</p> <p>Wir haben unseren ersten eigenen Datentyp erstellt! Wir haben dazu eine Klasse geschrieben. Die Klasse enth\u00e4lt Objektvariablen und Objektmethoden. Wir haben mithilfe des Schl\u00fcsselwortes <code>new</code> und dem Aufruf eines Konstruktors Objekte dieser Klasse erzeugt. \u00dcber die Punktnotation k\u00f6nnen wir auf die Objektmethoden zugreifen und diese ausf\u00fchren. Wir haben au\u00dferdem das Schl\u00fcsselwort <code>private</code> kennengelernt. Auf Objektvariablen und Objektmethoden, die als <code>private</code> deklariert sind, kann au\u00dferhalb der Klasse nicht zugegriffen werden. Um doch einen lesenden Zugriff auf die Werte der Objektvariablen zu erm\u00f6glichen, haben wir Getter definiert. </p> <p>Wir wollen jetzt das Neuerlernte an weiteren Beispielen festigen.</p>"},{"location":"objekte1/#eine-weiterer-datentyp-point","title":"Eine weiterer Datentyp <code>Point</code>","text":"<p>Angenommen, wir wollen in einem kartesischen Koordinatensystem einen Punkt beschreiben, also soetwas wie in der folgenden Abbildung:</p> <p></p> <p>Um uns eine eigene Klasse f\u00fcr <code>Point</code> zu schreiben, \u00fcberlegen wir uns zun\u00e4chst, was die allgemeine Struktur eines solchen Punktes ist. Das ist recht leicht aus der oberen Abbildung zu erkennen: ein Punkt wird durch zwei <code>int</code>-Werte <code>x</code> und <code>y</code> beschrieben. Dieses werden also unsere Objektvariablen:</p> Point.java <pre><code>public class Point\n{\n    // --- Objektvariablen -----\n    private int x;\n    private int y;\n}\n</code></pre> <p>Wir setzen die Objektvariablen nun gleich auf <code>private</code>. Wenn keine zwingenden Gr\u00fcnde dagegen sprechen (und das ist fast nie der Fall), deklarieren wir unsere Objektvariablen stets als <code>private</code>, um dem Prinzip des information hiding zu entsprechen. Hier nochmal eine \u00dcbersicht der bisherigen Begriffe und Bedeutungen:</p> <p></p> <p>Wir erstellen uns auch gleich einen parametrisierten Konstruktor, um den Objektvariablen bereits beim Erzeugen der Objekte ihre Werte zuzuweisen:</p> Point.java <pre><code>public class Point\n{\n    // --- Objektvariablen -----\n    private int x;\n    private int y;\n\n    // --- Konstruktor ---------\n    public Point(int px, int py)\n    {\n        x = px;\n        y = py;\n    }\n}\n</code></pre> <p>Wie wir bereits wissen, hei\u00dft der Konstruktor exakt wie die Klasse und hat keinen R\u00fcckgabetyp (auch nicht <code>void</code>). Achten Sie darauf, dass die Parameter (derzeit noch) anders hei\u00dfen, als die Objektvariablen. Wir haben ansonsten innerhalb des Konstruktors einen Namenskonflikt. Diesen werden wir aufl\u00f6sen, wenn wir das Schl\u00fcsselwort <code>this</code> kennenlernen. </p> <p>In unserer Testklasse k\u00f6nnen wir uns nun einige <code>Point</code>-Objekte erzeugen:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Point p1 = new Point(1, 2);\n        Point p2 = new Point(2, 4);\n        Point p3 = new Point(4, 6);\n        Point p4 = new Point(5, 3);\n    }\n}\n</code></pre> <p>Wir erstellen uns also vier <code>Point</code>-Objekte. Die Variablen <code>p1</code>, <code>p2</code>, <code>p3</code> und <code>p4</code> referenzieren jeweils ein <code>Point</code>-Objekt und sind vom Typ <code>Point</code>. Wir k\u00f6nnen uns die vier Objekte wie folgt veranschaulichen:</p> <p></p> <p>Jedes <code>Point</code>-Objekt hat also seine eigenen Objektvariablen mit den dazugeh\u00f6rigen Werten.  </p>"},{"location":"objekte1/#getter-und-eine-print-methode-fur-point","title":"Getter und eine <code>print()</code>-Methode f\u00fcr <code>Point</code>","text":"<p>Wir wollen jetzt, dass au\u00dferhalb der Klasse die Werte von <code>x</code> und <code>y</code> ausgelesen werden k\u00f6nnen. Dazu definieren wir uns Getter, also eine <code>getX()</code>- und eine <code>getY()</code>-Methode. Au\u00dferdem wollen wir eine <code>print()</code>-Methode zur Klasse <code>Point</code> hinzuf\u00fcgen, um die Werte von <code>x</code> und <code>y</code> auf die Konsole auszugeben. Die Klasse <code>Point</code> sieht nun so aus:</p> Point.java <pre><code>public class Point\n{\n    // --- Objektvariablen -----------\n    private int x;\n    private int y;\n\n    // --- Konstruktor ---------------\n    public Point(int px, int py)\n    {\n        x = px;\n        y = py;\n    }\n\n    // --- Getter --------------------\n    public int getX()\n    {\n        return x;\n    }\n\n    public int getY()\n    {\n        return y;\n    }\n\n    // --- weitere Objektmethoden ----\n    public void print()\n    {\n        System.out.println(\"[ x=\" + x + \", y=\" + y + \" ]\");\n    }\n}\n</code></pre> <p>Wir testen die neuerstellten Objektmethoden in unserer <code>Testklasse</code>:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Point p1 = new Point(1, 2);\n        Point p2 = new Point(2, 4);\n        Point p3 = new Point(4, 6);\n        Point p4 = new Point(5, 3);\n\n        System.out.println(\" p1 : ( \" + p1.getX() + \", \" + p1.getY() + \" )\");\n        System.out.println(\" p2 : ( \" + p2.getX() + \", \" + p2.getY() + \" )\");\n        System.out.println(\" p3 : ( \" + p3.getX() + \", \" + p3.getY() + \" )\");   \n        System.out.println(\" p4 : ( \" + p4.getX() + \", \" + p4.getY() + \" )\");\n\n        p1.print();\n        p2.print();\n        p3.print();\n        p4.print();\n    }\n}\n</code></pre> <p>Wir greifen also wieder \u00fcber die jeweilige Referenzvariable <code>p1</code>, <code>p2</code>, <code>p3</code> bzw. <code>p4</code> \u00fcber Punktnotation auf die Objektmethoden zu. Beachten Sie, dass - genau wie f\u00fcr die Objektvariablen - auch bei den Objektmethoden jedes Objekt \"seine eigene\" Objektmethode hat. <code>p1.getX()</code> gibt also genau den <code>x</code>-Wert des Objektes aus, auf das <code>p1</code> zeigt (<code>1</code>) und <code>p2.getX()</code> gibt also genau den <code>x</code>-Wert des Objektes aus, auf das <code>p2</code> zeigt (<code>2</code>). Die <code>print()</code>-Methode gibt genau die <code>x</code>- und <code>y</code>-Werte des Objektes aus, das die <code>print()</code>-Methode aufgerufen hat. Unsere vier Objekte k\u00f6nnen wir uns nun also so veranschaulichen:</p> <p></p> <p>Die Ausgabe sieht so aus:</p> <pre><code> p1 : ( 1, 2 )\n p2 : ( 2, 4 )\n p3 : ( 4, 6 )\n p4 : ( 5, 3 )\n[ x=1, y=2 ]\n[ x=2, y=4 ]\n[ x=4, y=6 ]\n[ x=5, y=3 ]\n</code></pre> <p>Wir erstellen eine weitere Objektmethode f\u00fcr die Klasse <code>Point</code>, um einen Punkt zu verschieben. </p>"},{"location":"objekte1/#objektmethode-translate-fur-point","title":"Objektmethode <code>translate()</code> f\u00fcr <code>Point</code>","text":"<p>Wir wollen einen Punkt um ein <code>deltaX</code> nach links oder rechts und um ein <code>deltaY</code> nach oben oder unten verschieben:</p> <p></p> <p>Angenommen, unser Punkt ist, wie in der obigen Abbildung gezeigt, bei <code>x=1</code> und <code>y=2</code> und er soll um <code>deltaX=4</code> nach rechts und um <code>deltaY=3</code> nach oben verschoben werden, dann ist er nach <code>translate(4,3)</code> bei <code>x=5</code> und <code>y=5</code>. Wir implementieren die Objektmethode in der Klasse <code>Point</code> wie folgt:</p> <pre><code>    public void translate(int deltaX, int deltaY)\n    {\n        x = x + deltaX;\n        y = y + deltaY;\n    }\n</code></pre> <p>Beachten Sie, dass der R\u00fcckgabetyp <code>void</code> ist. Das hatten wir bisher immer nur bei Methoden, in denen eine Ausgabe auf die Konsole erfolgte. Bei Objektmethoden wird dies nun h\u00e4ufig vorkommen. In der Methode <code>translate()</code> werden die Werte von den Objektvariablen <code>x</code> und <code>y</code> neu gesetzt. Sie ergeben sich hier aus den alten Werten von <code>x</code> und <code>y</code> und der Addition mit <code>deltaX</code> bzw. <code>deltaY</code>. Beachten Sie auch, dass die Werte von <code>deltaX</code> und <code>deltaY</code> negativ sein k\u00f6nnen. Dann wird der Punkt nach links bzw. nach unten verschoben. Im Ergebnis der Ausf\u00fchrung der Methode <code>translate()</code> haben die Objektvariablen des Objektes, das diese Methode aufgerufen hat, neue Werte. Wir testen das in unserer <code>Testklasse</code>:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        /* hier gekuerzt - siehe oben                       */\n        /* die Erzeugung der Objekte muss bleiben           */\n        /* Testen der Getter und print() kann auch bleiben  */ \n\n        p1.print();             // [ x=1, y=2 ]\n        p1.translate(4, 3);\n        p1.print();             // [ x=5, y=5 ]\n\n        p4.print();             // [ x=5, y=3 ]\n        p4.translate(-3, -1);\n        p4.print();             // [ x=2, y=2 ]\n    }\n}\n</code></pre>"},{"location":"objekte1/#vergleiche-mit-anderen-objekten-gleichen-typs","title":"Vergleiche mit anderen Objekten gleichen Typs","text":"<p>Angenommen, ein Punkt m\u00f6chte \"wissen\", ob er selbst weiter links positioniert ist, als ein anderer Punkt. Dann muss er seinen eigenen <code>x</code>-Wert mit dem <code>x</code>-Wert des anderen Punktes vergleichen. Wenn wir daf\u00fcr eine Objektmethode schreiben wollen, dann m\u00fcssen wir den anderen Punkt als Parameter \u00fcbergeben. Das ist kein Problem:</p> <pre><code>    public boolean isLeft(Point otherPoint)\n    {\n        return (x &lt; otherPoint.x);\n    }\n</code></pre> <p>Wir \u00fcbergeben der Objektmethode ein Objekt vom Typ <code>Point</code>. Wir wissen, dass jedes <code>Point</code>-Objekt folgende Eigenschaften hat:</p> <ul> <li><code>x</code>, </li> <li><code>y</code>, </li> <li><code>getX()</code>, </li> <li><code>getY()</code>,</li> <li><code>print()</code> und </li> <li><code>translate()</code> </li> </ul> <p>Auf diese Eigenschaften k\u00f6nnen wir nat\u00fcrlich auch innerhalb der Klasse \u00fcber die Punktnotation zugreifen. Hierbei ist anzumerken, dass wir innerhalb der Klasse auch direkt auf die <code>x</code>- und <code>y</code>-variablen zugreifen k\u00f6nnen. Der Sichtbarkeitsmodifizierer <code>private</code> besagt nur, dass wir nicht au\u00dferhalb der Klasse auf die Objektvariablen zugreifen k\u00f6nnen. Innerhalb der Klasse ist der direkte Zugriff erlaubt! Wir h\u00e4tten aber auch \u00fcber die <code>getX()</code>-Methode den Wert von <code>x</code> von <code>otherPoint</code> auslesen k\u00f6nnen. </p> <p>Wir erweitern um die Methoden <code>isRight()</code>, <code>isAbove()</code>, <code>isBelow()</code>. Die gesamte Klasse <code>Point</code> sieht dann so aus:</p> Point.java <pre><code>public class Point\n{\n    // --- Objektvariablen -----------\n    private int x;\n    private int y;\n\n    // --- Konstruktor ---------------\n    public Point(int px, int py)\n    {\n        x = px;\n        y = py;\n    }\n\n    // --- Getter --------------------\n    public int getX()\n    {\n        return x;\n    }\n\n    public int getY()\n    {\n        return y;\n    }\n\n    // --- weitere Objektmethoden ----\n    public void print()\n    {\n        System.out.println(\"[ x=\" + x + \", y=\" + y + \" ]\");\n    }\n\n    public void translate(int deltaX, int deltaY)\n    {\n        x = x + deltaX;\n        y = y + deltaY;\n    }\n\n    public boolean isLeft(Point otherPoint)\n    {\n        return (x &lt; otherPoint.x);\n    }\n\n    public boolean isRight(Point otherPoint)\n    {\n        return (x &gt; otherPoint.x);\n    }\n\n    public boolean isAbove(Point otherPoint)\n    {\n        return (y &gt; otherPoint.y);\n    }\n\n    public boolean isBelow(Point otherPoint)\n    {\n        return (y &lt; otherPoint.y);\n    }\n}\n</code></pre> <p>Wir testen die Methoden in unserer Testklasse:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Point p1 = new Point(1, 2);\n        Point p2 = new Point(2, 4);\n        Point p3 = new Point(4, 6);\n        Point p4 = new Point(5, 3);\n\n        System.out.println(\" p1 : ( \" + p1.getX() + \", \" + p1.getY() + \" )\");\n        System.out.println(\" p2 : ( \" + p2.getX() + \", \" + p2.getY() + \" )\");\n        System.out.println(\" p3 : ( \" + p3.getX() + \", \" + p3.getY() + \" )\");   \n        System.out.println(\" p4 : ( \" + p4.getX() + \", \" + p4.getY() + \" )\");\n\n        p1.print();\n        p2.print();\n        p3.print();\n        p4.print();\n\n        p1.print();             // [ x=1, y=2 ]\n        p1.translate(4, 3);\n        p1.print();             // [ x=5, y=5 ]\n\n        p4.print();             // [ x=5, y=3 ]\n        p4.translate(-3, -1);\n        p4.print();             // [ x=2, y=2 ]\n\n        System.out.println(\"p1 links  von p2 ? \" + p1.isLeft(p2));      // p1.x=5 &gt; p2.x=2\n        System.out.println(\"p1 rechts von p2 ? \" + p1.isRight(p2));\n        System.out.println(\"p3 ueber p4 ? \" + p3.isAbove(p4));          // p3.y=6 &gt; p4.y=2\n        System.out.println(\"p3 unter p4 ? \" + p3.isBelow(p4));\n    }\n}\n</code></pre> <p>Beachten Sie, dass es immer ein Objekt gibt, das die Methode aufruft und ein Objekt, das der Methode als Parameter \u00fcbergeben wird. Beispielsweise ist bei <code>p1.isLeft(p2)</code> das <code>Point</code>-Objekt <code>p1</code> das aufrufende Objekt und das <code>Point</code>-Objekt <code>p2</code> das Objekt, das der Methode als Parameter\"wert\" \u00fcbergeben wird. <code>p1</code> vergleicht sich also selbst mit <code>p2</code>. Da der <code>x</code>-Wert von <code>p1</code> <code>5</code> ist und der <code>x</code>-Wert von <code>p2</code> ist <code>2</code> ergibt <code>p1.isLeft(p2)</code> <code>false</code>. Der Aufruf <code>p2.isLeft(p1)</code> w\u00fcrde dann <code>true</code> ergeben. </p> <p>Success</p> <p>Wir haben einen weiteren Datentyp erstellt, n\u00e4mlich <code>Point</code>. In diesem beispiel gibt es eine Methode <code>translate()</code>, in der die Werte der Objektvariablen <code>x</code> und <code>y</code> ge\u00e4ndert werden. Objekte vom Typ <code>Point</code> sind somit nicht immutable (unver\u00e4nderlich). Der R\u00fcckgabetyp solcher Objektmethoden, die die Werte von Objektvariablen \u00e4ndern, ist typischerweise <code>void</code>. Wir haben au\u00dferdem Objektmethoden definiert, in denen sich das aufrufende Objekt mit einem anderen Objekt gleichen Typs vergleicht. Der Vergleich erfolgt \u00fcber die Werte der Objektvariablen sowohl des aufrufenden Objektes, als auch der Werte der Objektvariablen des Objektes, mit dem verglichen wird (das als Parameter \u00fcbergeben wird). </p> <p>Wir festigen unserer neuen Erkenntnisse an einem weiteren Beispiel:</p>"},{"location":"objekte1/#ein-weiterer-datentyp-circle","title":"Ein weiterer Datentyp <code>Circle</code>","text":"<p>Wir erstellen uns einen Datentyp, der einen Kreis repr\u00e4sentiert. Wir nennen den Datentyp <code>Circle</code>. Ein Kreis ist durch seinen <code>radius</code> eindeutig beschrieben. Wir k\u00f6nnten als Objektvariable auch den Durchmesser <code>diameter</code> w\u00e4hlen, das bleibt sich gleich und ist eine eigene Programmierentscheidung. Wir sollten aber keinesfalls <code>radius</code> und <code>diameter</code> als Objekteigenschaften w\u00e4hlen, da es ansonsten zu Inkonsistenten kommen k\u00f6nnte - angenommen, <code>radius</code> h\u00e4tte den Wert <code>5</code> und <code>diameter</code> den Wert <code>11</code>, das w\u00e4re inkonsistent und w\u00fcrde nicht passen. Vielmehr kann der Durchmesser aus dem Radius berechnet werden. Wir implementieren also:</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double pRadius)\n    {\n        radius = pRadius;\n    }\n\n    // ----- Getter der Objektvariablen -----\n    public double getRadius()\n    {\n        return radius;\n    }\n\n    // ----- weitere Objektmethoden ---------\n    public double getDiameter()\n    {\n        return 2.0 * radius;\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius      : \" + radius);\n        System.out.println(\"Durchmesser : \" + getDiameter());   // Aufruf Objektmethode\n    }\n}\n</code></pre> <p>Die Objektvariable <code>radius</code> ist wieder als <code>private</code> deklariert - es gibt keinen Grund, dies nicht zu tun. Wir erlauben aber den lesenden Zugriff darauf durch die Erstellung der <code>getRadius()</code>-Methode, die <code>public</code> ist. Au\u00dferdem berechnen wir auch noch den Durchmesser und geben ihn mit der <code>getDiameter()</code>-Methode zur\u00fcck. Beachten Sie, dass sowohl <code>radius</code> als auch <code>getDiameter()</code> vom Typ <code>double</code> sind. Damit wir die Werte auch ausgeben, haben wir eine <code>print()</code>-Methode erstellt. Beachten Sie, dass wir in der <code>print()</code>-Methode die Objektmethode <code>getDiameter()</code> aufrufen. </p> <p>Wir testen den Datentyp <code>Circle</code> in der <code>Testklasse</code>:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Circle c1 = new Circle(5.0);\n        Circle c2 = new Circle(3.5);\n\n        c1.print();\n        System.out.println();\n        c2.print();\n    }\n}\n</code></pre> <p>Es werden folgende Ausgaben erzeugt:</p> <pre><code>Radius      : 5.0\nDurchmesser : 10.0\n\nRadius      : 3.5\nDurchmesser : 7.0\n</code></pre> <p>F\u00fcr einen Kreis k\u00f6nnen wir auch noch den Umfang <code>circumference()</code> und den Fl\u00e4cheninhalt <code>area()</code> berechnen und verwenden dazu die Konstante <code>PI</code> aus der <code>Math</code>-Klasse (siehe Die Klasse <code>Math</code>). Mit den Ergebnissen der <code>circumference()</code>- und der <code>area()</code>-Methode erweitern wir auch die Ausgabe in <code>print()</code>: </p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double pRadius)\n    {\n        radius = pRadius;\n    }\n\n    // ----- Getter der Objektvariablen -----\n    public double getRadius()\n    {\n        return radius;\n    }\n\n    // ----- weitere Objektmethoden ---------\n    public double getDiameter()\n    {\n        return 2.0 * radius;\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius         : \" + radius);\n        System.out.println(\"Durchmesser    : \" + getDiameter());    // Aufruf Objektmethode\n        System.out.println(\"Umfang         : \" + circumference());  // Aufruf Objektmethode\n        System.out.println(\"Flaecheninhalt : \" + area());   // Aufruf Objektmethode\n    }\n\n    public double circumference()\n    {\n        return Math.PI * getDiameter();\n    }\n\n    public double area()\n    {\n        return Math.PI * radius * radius;\n    }\n}\n</code></pre> <p>Das erneute Ausf\u00fchren der <code>Testklasse</code> (in der <code>Testklasse</code> nichts ge\u00e4ndert, aber die <code>print()</code>-Methode wurde ge\u00e4ndert) ergibt:</p> <pre><code>Radius         : 5.0\nDurchmesser    : 10.0\nUmfang         : 31.41592653589793\nFlaecheninhalt : 78.53981633974483\n\nRadius         : 3.5\nDurchmesser    : 7.0\nUmfang         : 21.991148575128552\nFlaecheninhalt : 38.48451000647496\n</code></pre> <p>Zur Weiderholung und Festigung wollen wir auch hier zwei <code>Circle</code>-Objekte miteinander vergleichen. Auch hier gibt es immer ein aufrufendes <code>Circle</code>-Objekt und ein <code>Circle</code>-Objekt, das als Parameter \u00fcbergeben wird. Wir schreiben drei Methoden, die jeweils ein <code>boolean</code> zur\u00fcckgeben: <code>isSmaller()</code>, <code>isBigger()</code>, <code>isEqual()</code>:</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double pRadius)\n    {\n        radius = pRadius;\n    }\n\n    // ----- Getter der Objektvariablen -----\n    public double getRadius()\n    {\n        return radius;\n    }\n\n    // ----- weitere Objektmethoden ---------\n    public double getDiameter()\n    {\n        return 2.0 * radius;\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius         : \" + radius);\n        System.out.println(\"Durchmesser    : \" + getDiameter());    // Aufruf Objektmethode\n        System.out.println(\"Umfang         : \" + circumference());  // Aufruf Objektmethode\n        System.out.println(\"Flaecheninhalt : \" + area());   // Aufruf Objektmethode\n    }\n\n    public double circumference()\n    {\n        return Math.PI * getDiameter();\n    }\n\n    public double area()\n    {\n        return Math.PI * radius * radius;\n    }\n\n    public boolean isSmaller(Circle c)\n    {\n        return (radius &lt; c.radius);\n    }\n\n    public boolean isBigger(Circle c)\n    {\n        return (radius &gt; c.radius);\n    }\n\n    public boolean isEqual(Circle c)\n    {\n        return !isSmaller(c) &amp;&amp; !isBigger(c);\n    }\n}\n</code></pre> <p>In der <code>isEqual()</code>-Methode h\u00e4tten wir nat\u00fcrlich auch <code>return radius==c.radius;</code> schreiben k\u00f6nnen. Aber wir wollten hier nochmal die Verwendung von Objektmethoden innerhalb der Klasse zeigen. Die <code>Testklasse</code></p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Circle c1 = new Circle(5.0);\n        Circle c2 = new Circle(3.5);\n\n        c1.print();\n        System.out.println();   \n        c2.print();\n\n        System.out.println(\"c1 groesser als c2 ? \" + c1.isBigger(c2));      \n        System.out.println(\"c1 kleiner als c2  ? \" + c1.isSmaller(c2));     \n        System.out.println(\"c1 gleich c2       ? \" + c1.isEqual(c2));\n        System.out.println();\n\n        System.out.println(\"c2 groesser als c1 ? \" + c2.isBigger(c1));      \n        System.out.println(\"c2 kleiner als c1  ? \" + c2.isSmaller(c1));     \n        System.out.println(\"c2 gleich c1       ? \" + c2.isEqual(c1));\n        System.out.println();\n\n        System.out.println(\"c1 groesser als c1 ? \" + c1.isBigger(c1));      \n        System.out.println(\"c1 kleiner als c1  ? \" + c1.isSmaller(c1));     \n        System.out.println(\"c1 gleich c1       ? \" + c1.isEqual(c1));\n        System.out.println();   \n    }\n}\n</code></pre> <p>erzeugt folgende Ausgaben (nur die Vergleiche):</p> <pre><code>bash\nc1 groesser als c2 ? true\nc1 kleiner als c2  ? false\nc1 gleich c2       ? false\n\nc2 groesser als c1 ? false\nc2 kleiner als c1  ? true\nc2 gleich c1       ? false\n\nc1 groesser als c1 ? false\nc1 kleiner als c1  ? false\nc1 gleich c1       ? true\n</code></pre> <p>Beachten Sie, dass im dritten Vergleichsblock das <code>c1</code>-Objekt mit sich selbst verglichen wird. Auch das ist ohne Probleme m\u00f6glich (aber normalerweise sinnlos).</p> <p>Success</p> <p>Wir haben in diesem dritten Beispiel die ersten Erkenntnisse \u00fcber das objektorientierte Programmieren wiederholt und gefestigt. In der Klasse <code>Circle</code> haben wir insbesondere h\u00e4ufiger die Objektmethoden innerhalb der Klasse aufgerufen. Die Einf\u00fchrung in die objektorientierte Programmierung ist hiermit zun\u00e4chst beendet. Beim n\u00e4chsten Mal werden wir mehrere Konstruktoren in der Klasse definieren, wir werden eigene Datentypen in neuen Datentypen verwenden und das Schl\u00fcsselwort <code>this</code> kennenlernen. Viel Spa\u00df beim \u00dcben!</p> Die Klassen <code>Adresse</code>, <code>Point</code>, <code>Circle</code> und <code>Testklasse</code> Adresse.javaPoint.javaCircle.javaTestklasse.java <pre><code>public class Adresse\n{\n    // --- Objektvariablen -----\n    private String strasse;\n    private int nummer;\n    private int postleitzahl;\n    private String wohnort;\n\n    // --- Konstruktor ---------\n    public Adresse(String str, int nr, int plz, String ort)\n    {\n        strasse = str;\n        nummer = nr;\n        postleitzahl = plz;\n        wohnort = ort;\n    }\n\n    // --- Objektmethoden ------\n    public String getAdresse()\n    {\n        return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n    }\n\n    public String getStrasse()\n    {\n        return strasse;\n    }\n\n    public int getNummer()\n    {\n        return nummer;\n    }\n\n    public int getPostleitzahl()\n    {\n        return postleitzahl;\n    }\n\n    public String getWohnort()\n    {\n        return wohnort;\n    }\n}\n</code></pre> <pre><code>public class Point\n{\n    // --- Objektvariablen -----------\n    private int x;\n    private int y;\n\n    // --- Konstruktor ---------------\n    public Point(int px, int py)\n    {\n        x = px;\n        y = py;\n    }\n\n    // --- Getter --------------------\n    public int getX()\n    {\n        return x;\n    }\n\n    public int getY()\n    {\n        return y;\n    }\n\n    // --- weitere Objektmethoden ----\n    public void print()\n    {\n        System.out.println(\"[ x=\" + x + \", y=\" + y + \" ]\");\n    }\n\n    public void translate(int deltaX, int deltaY)\n    {\n        x = x + deltaX;\n        y = y + deltaY;\n    }\n\n    public boolean isLeft(Point otherPoint)\n    {\n        return (x &lt; otherPoint.x);\n    }\n\n    public boolean isRight(Point otherPoint)\n    {\n        return (x &gt; otherPoint.x);\n    }\n\n    public boolean isAbove(Point otherPoint)\n    {\n        return (y &gt; otherPoint.y);\n    }\n\n    public boolean isBelow(Point otherPoint)\n    {\n        return (y &lt; otherPoint.y);\n    }\n}\n</code></pre> <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double pRadius)\n    {\n        radius = pRadius;\n    }\n\n    // ----- Getter der Objektvariablen -----\n    public double getRadius()\n    {\n        return radius;\n    }\n\n    // ----- weitere Objektmethoden ---------\n    public double getDiameter()\n    {\n        return 2.0 * radius;\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius         : \" + radius);\n        System.out.println(\"Durchmesser    : \" + getDiameter());    // Aufruf Objektmethode\n        System.out.println(\"Umfang         : \" + circumference());  // Aufruf Objektmethode\n        System.out.println(\"Flaecheninhalt : \" + area());   // Aufruf Objektmethode\n        System.out.println();\n    }\n\n    public double circumference()\n    {\n        return Math.PI * getDiameter();\n    }\n\n    public double area()\n    {\n        return Math.PI * radius * radius;\n    }\n\n    public boolean isSmaller(Circle c)\n    {\n        return (radius &lt; c.radius);\n    }\n\n    public boolean isBigger(Circle c)\n    {\n        return (radius &gt; c.radius);\n    }\n\n    public boolean isEqual(Circle c)\n    {\n        return !isSmaller(c) &amp;&amp; !isBigger(c);\n    }\n}       \n</code></pre> <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        // Tests fuer Adresse\n        System.out.printf(\"%n%n ---------------- Testen des Datentyps Adresse ------------------ %n%n\");\n        Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n        Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\");         \n\n        System.out.println(adresse1.getAdresse());\n        System.out.println(adresse2.getAdresse());\n\n        System.out.println(\"Strasse Nr  : \" + adresse1.getStrasse() + \" \" +  adresse1.getNummer());\n        System.out.println(\"PLZ Wohnort : \" + adresse1.getPostleitzahl() + \" \" + adresse1.getWohnort());\n\n        System.out.println(\"Strasse Nr  : \" + adresse2.getStrasse() + \" \" +  adresse1.getNummer());\n        System.out.println(\"PLZ Wohnort : \" + adresse2.getPostleitzahl() + \" \" +  adresse1.getWohnort());\n\n        // Tests fuer Point\n        System.out.printf(\"%n%n ---------------- Testen des Datentyps Point ------------------ %n%n\");\n        Point p1 = new Point(1, 2);\n        Point p2 = new Point(2, 4);\n        Point p3 = new Point(4, 6);\n        Point p4 = new Point(5, 3);\n\n        System.out.println(\" p1 : ( \" + p1.getX() + \", \" + p1.getY() + \" )\");\n        System.out.println(\" p2 : ( \" + p2.getX() + \", \" + p2.getY() + \" )\");\n        System.out.println(\" p3 : ( \" + p3.getX() + \", \" + p3.getY() + \" )\");   \n        System.out.println(\" p4 : ( \" + p4.getX() + \", \" + p4.getY() + \" )\");\n\n        p1.print();\n        p2.print();\n        p3.print();\n        p4.print();\n\n        p1.print();             // [ x=1, y=2 ]\n        p1.translate(4, 3);\n        p1.print();             // [ x=5, y=5 ]\n\n        p4.print();             // [ x=5, y=3 ]\n        p4.translate(-3, -1);\n        p4.print();             // [ x=2, y=2 ]\n\n        System.out.println(\"p1 links  von p2 ? \" + p1.isLeft(p2));      // p1.x=5 &gt; p2.x=2\n        System.out.println(\"p1 rechts von p2 ? \" + p1.isRight(p2));\n        System.out.println(\"p3 ueber p4 ? \" + p3.isAbove(p4));          // p3.y=6 &gt; p4.y=2\n        System.out.println(\"p3 unter p4 ? \" + p3.isBelow(p4));\n\n\n        // Tests fuer Circle\n        System.out.printf(\"%n%n ---------------- Testen des Datentyps Circle ------------------ %n%n\");\n        Circle c1 = new Circle(5.0);\n        Circle c2 = new Circle(3.5);\n\n        c1.print();\n        System.out.println();   \n        c2.print();\n\n        System.out.println(\"c1 groesser als c2 ? \" + c1.isBigger(c2));      \n        System.out.println(\"c1 kleiner als c2  ? \" + c1.isSmaller(c2));     \n        System.out.println(\"c1 gleich c2       ? \" + c1.isEqual(c2));\n        System.out.println();\n\n        System.out.println(\"c2 groesser als c1 ? \" + c2.isBigger(c1));      \n        System.out.println(\"c2 kleiner als c1  ? \" + c2.isSmaller(c1));     \n        System.out.println(\"c2 gleich c1       ? \" + c2.isEqual(c1));\n        System.out.println();\n\n        System.out.println(\"c1 groesser als c1 ? \" + c1.isBigger(c1));      \n        System.out.println(\"c1 kleiner als c1  ? \" + c1.isSmaller(c1));     \n        System.out.println(\"c1 gleich c1       ? \" + c1.isEqual(c1));\n        System.out.println();       \n    }\n}   \n</code></pre>"},{"location":"objekte2/","title":"Klassen und Objekte II","text":"<p>Wir machen weiter mit eigenen Datentypen und erstellen uns Objekte, die von diesen Typen sind. Wir werden im Folgenden</p> <ul> <li>eigene Datentypen in neuen Datentypen verwenden, </li> <li>mehrere Konstruktoren in der Klasse definieren,</li> <li>in Methoden Objekte erzeugen und diese auch zur\u00fcckgeben und</li> <li>das Schl\u00fcsselwort <code>this</code> kennenlernen. </li> </ul>"},{"location":"objekte2/#eigene-datentypen-in-eigenen-datentypen-verwenden","title":"Eigene Datentypen in eigenen Datentypen verwenden","text":"<p>Wir beginnen damit, eigene Datentypen in neuen Datentypen zu verwenden, da dies eine gute Wiederholung ist. Angenommen, wir haben unsere Klasse <code>Adresse</code> in einem package <code>themen.objekte</code> erstellt und wir wollen die kommenden Klassen in einem package <code>themn.objekte2</code> erstellen. In diesem package erstellen wir uns eine neue Klasse <code>Person</code> mit folgenden Objektvariablen:</p> <ul> <li><code>name</code> vom Typ <code>String</code>,</li> <li><code>vorname</code> vom Typ <code>String</code> und</li> <li><code>adresse</code> vom Typ <code>Adresse</code>. </li> </ul> <p>Wir f\u00fcgen auch gleich noch den Konstruktor hinzu und bereiten die <code>print()</code>-Methode vor:</p> themen/objekte2/Person.java <pre><code>package themen.objekte2;        // extra anders als bei Adresse, um import zu lernen\n\nimport themen.objekte.Adresse;  // das Paket ist bei Ihnen vielleicht anders\n\npublic class Person\n{\n    // ------- Objektvariablen -----------\n    private String name;\n    private String vorname;\n    private Adresse adresse;\n\n    // ------- Konstruktor -----------\n    public Person(String pName, String pVorname, Adresse pAdresse)\n    {\n        name = pName;\n        vorname = pVorname;\n        adresse = pAdresse;\n    }\n\n    // ------- Objektmethoden -----------\n    public void print()\n    {\n        // wie sieht die Ausgabe aus?\n        // wie kann ich die Adresse ausgeben?\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>10</code> verwenden wir die von uns geschriebene Klasse <code>Adresse</code>. Wir haben extra mal die Klasse <code>Person</code> in einem anderen Paket (<code>themen.objekte2</code> - siehe Zeile <code>1</code>) erstellt, als die Klasse <code>Adresse</code> (<code>themen.objekte</code> - ist bei Ihnen sicherlich ein anderes Paket), um zu zeigen, wie wir Klassen aus anderen Paketen importieren (siehe Zeile <code>3</code>).</li> <li>der Konstruktor (Zeilen <code>13-18</code>) sieht aus, wie erwartet. Wir initialisieren alle Objektvariablen mit den als Parameter \u00fcbergebenen Werten. </li> <li>in den Zeilen <code>21-25</code> haben wir auch schon die <code>print()</code>-Methode vorbereitet. Darin wollen wir alle Informationen \u00fcber das jeweilige <code>Person</code>-Objekt ausgeben. F\u00fcr <code>name</code> und <code>vorname</code> ist das sicherlich einfach. Aber wie kommen wir an die Informationen von <code>adresse</code>? </li> </ul> <p>Wir erstellen uns in einer Testklasse zun\u00e4chst Objekte der Klasse <code>Person</code>. </p>"},{"location":"objekte2/#person-objekte-erzeugen","title":"<code>Person</code>-Objekte erzeugen","text":"<p>Um Objekte von <code>Person</code> erstellen zu k\u00f6nnen, ben\u00f6tigen wir Objekte des Typs <code>Adresse</code>, da diese dem Konstruktor als Parameter \u00fcbergeben werden m\u00fcssen. Beachten Sie auch hier, dass wir die Klasse <code>Adresse</code> dazu aus dem package <code>themen.objekte</code> importieren. </p> themen/objekte2/Testklasse.java <pre><code>package themen.objekte2;\n\nimport themen.objekte.Adresse;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n        Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\"); \n\n        Person maria = new Person(\"Musterfrau\", \"Maria\", adresse1);\n        Person max = new Person(\"Mustermann\", \"Max\", adresse2);\n\n    }\n}\n</code></pre>"},{"location":"objekte2/#objektmethoden-aufrufen","title":"Objektmethoden aufrufen","text":"<p>Zun\u00e4chst erweitern wir unsere <code>print()</code>-Methode in <code>Person</code>:</p> print() in Person.java erweitern <pre><code>// ------- Objektmethoden -----------\npublic void print()\n{\n    System.out.println(vorname + \" \" + name); \n    // wie kann ich die Adresse ausgeben?\n}\n</code></pre> <p>In der <code>Testklasse</code> rufen wir die <code>print()</code>-Methode f\u00fcr die beiden <code>Person</code>-Objekte auf:</p> main() in Testklasse.java erweitern <pre><code>public static void main(String[] args)\n{\n    Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n    Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\"); \n\n    Person maria = new Person(\"Musterfrau\", \"Maria\", adresse1);\n    Person max = new Person(\"Mustermann\", \"Max\", adresse2);\n\n    maria.print();\n    max.print();\n}\n</code></pre> <p>Die Ausgabe erfolgt wie gew\u00fcnscht:</p> <pre><code>Maria Musterfrau\nMax Mustermann\n</code></pre> <p>Wie k\u00f6nnen wir nun auch die Adressen von <code>maria</code> und <code>max</code> ausgeben? Die Antwort ist: mithilfe der Objektmethoden von <code>Adresse</code>. Schauen wir uns die Objektmethoden von <code>Adresse</code> nochmal an (siehe auch hier):</p> Objektmethoden von Adresse.java <pre><code>// --- Objektmethoden ------\npublic String getAdresse()\n{\n    return strasse + \" \" + nummer + \" in \" + postleitzahl + \" \" + wohnort;\n}\n\npublic String getStrasse()\n{\n    return strasse;\n}\n\npublic int getNummer()\n{\n    return nummer;\n}\n\npublic int getPostleitzahl()\n{\n    return postleitzahl;\n}\n\npublic String getWohnort()\n{\n    return wohnort;\n}\n</code></pre> <p>Alle diese Methoden sind <code>public</code> und k\u00f6nnen von allen Klassen aufgerufen werden. Wir nutzen in der <code>print()</code>-Methode von <code>Person</code> die Objektmethode <code>getAdresse()</code> von <code>Adresse</code>, k\u00f6nnten aber auch alle anderen Objektmethoden verwenden. </p> print() in Person.java erweitern <pre><code>// ------- Objektmethoden -----------\npublic void print()\n{\n    // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse()\n    System.out.println(vorname + \" \" + name + \" wohnt in \" + adresse.getAdresse()); \n}\n</code></pre> <p>Erneutes Ausf\u00fchren der <code>Testklasse</code> erzeugt nun folgende Ausgabe:</p> <pre><code>Maria Musterfrau wohnt in Wilhelminenhofstr. 75 in 12459 Berlin\nMax Mustermann wohnt in Treskowallee 8 in 10318 Berlin\n</code></pre> <p>Die Objekteigenschaft <code>adresse</code> der Klasse <code>Person</code> ist vom Typ Adresse. Um ein Objekt der Klasse <code>Person</code> zu erzeugen, muss dem Konstruktor der Klasse <code>Person</code> ein Objekt der Klasse <code>Adresse</code> \u00fcbergeben werden - das erwartet der Konstruktor als Parameter. Jedes Objekt vom Typ <code>Person</code> \"besitzt\" somit ein eigenes Objekt von Typ <code>Adresse</code>, welches in <code>adresse</code> gespeichert ist. F\u00fcr dieses Objekt k\u00f6nnen alle Objekteigenschaften aus <code>Adresse</code> aufgerufen werden (z.B. auch <code>getStrasse()</code>, <code>getNummer()</code>, <code>getPostleitzahl()</code> und <code>getWohnort()</code>). </p>"},{"location":"objekte2/#getter-fur-person-erzeugen","title":"Getter f\u00fcr <code>Person</code> erzeugen","text":"<p>Wir erstellen uns f\u00fcr die Klasse <code>Person</code> getter (also <code>getXXX()</code>-Methoden) f\u00fcr die Objektvariablen:</p> themen/objekte2/Person.java <pre><code>package themen.objekte2;        // extra anders als bei Adresse, um import zu lernen\n\nimport themen.objekte.Adresse;  // das Paket ist bei Ihnen vielleicht anders\n\npublic class Person\n{\n    // ------- Objektvariablen -----------\n    private String name;\n    private String vorname;\n    private Adresse adresse;\n\n    // ------- Konstruktor -----------\n    public Person(String pName, String pVorname, Adresse pAdresse)\n    {\n        name = pName;\n        vorname = pVorname;\n        adresse = pAdresse;\n    }\n\n    // ------- Objektmethoden -----------\n    public void print()\n    {\n        // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse()\n        System.out.println(vorname + \" \" + name + \" wohnt in \" + adresse.getAdresse()); \n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public String getVorname()\n    {\n        return vorname;\n    }\n\n    public Adresse getAdresse()\n    {\n        return adresse;\n    }\n}\n</code></pre> <p>Die Implementierungen der Getter sind so, wie wir sie bereits kennen. Wir nennen die Methoden <code>get</code> und h\u00e4ngen jeweils in camel-case-Schreibweise den Namen der Objektvariablen an, also <code>getName()</code>, <code>getVorname()</code> und <code>getAdrese()</code>. Der R\u00fcckgabetyp der Methode entspricht stets dem Typ der Variablen, also f\u00fcr <code>name</code> und <code>vorname</code> ist der R\u00fcckgabetyp der Methoden <code>getName()</code> und <code>getVorname()</code> jeweils <code>String</code> und der R\u00fcckgabetyp von <code>getAdresse()</code> ist wie der Typ von <code>adresse</code>, n\u00e4mlich <code>Adresse</code>. </p> <p>Wir betrachten nun besonders die Methode <code>getAdresse()</code> der Klasse <code>Person</code> und rufen diese in der <code>Testklasse</code> auf. </p> main() in Testklasse.java erweitern <pre><code>public static void main(String[] args)\n{\n    Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n    Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\"); \n\n    Person maria = new Person(\"Musterfrau\", \"Maria\", adresse1);\n    Person max = new Person(\"Mustermann\", \"Max\", adresse2);\n\n    maria.print();\n    max.print();\n\n    Adresse mariasAdresse = maria.getAdresse(); // getAdresse() von Person\n    Adresse maxAdresse = max.getAdresse();      // getAdresse() von Person\n\n    System.out.println(mariasAdresse.getAdresse()); // getAdresse() von Adresse\n    System.out.println(maxAdresse.getAdresse());    // getAdresse() von Adresse\n}\n</code></pre> <ul> <li>In Zeile <code>19</code> rufen wir die soeben erstelle Methode <code>getAdresse()</code> f\u00fcr das <code>Person</code>-Objekt <code>maria</code> auf. Die R\u00fcckgabe dieser Objektmethode ist die <code>adresse</code> von <code>maria</code>, also ein Objekt vom Typ <code>Adresse</code>, welches wir in der Referenzvariablen <code>mariasAdresse</code> vom Typ <code>Adresse</code> speichern. </li> <li>In Zeile <code>20</code> passiert das gleiche mit dem <code>Person</code>-Obejkt <code>max</code>. In der Variablen <code>maxAdresse</code> vom Typ <code>Adresse</code> ist nun das <code>Adresse</code>-Objekt von <code>max</code> gespeichert. </li> <li>f\u00fcr diese beiden <code>Adresse</code>-Objekte k\u00f6nnen wir nun alle Objektmethoden aus <code>Adresse</code> aufrufen. In Zeile <code>22</code> wird z.B. die <code>getAdresse()</code>-Methode des Objektes <code>mariasAdresse</code> aufgerufen und in Zeile <code>23</code> die <code>getAdresse()</code>-Methode des <code>Adresse</code>-Objektes <code>maxAdresse</code>. </li> </ul> <p>Beachten Sie, dass es zwei Methoden mit dem gleichen Namen gibt! Es existiert eine <code>getAdresse()</code>-Methode f\u00fcr den Datentyp <code>Adresse</code>. Diese Methode kann von Objekten des Typs <code>Adresse</code> aufegrufen werden und gibt einen <code>String</code> zur\u00fcck. Au\u00dferdem gibt es eine <code>getAdresse()</code>-Methode f\u00fcr den Datentyp <code>Person</code>. Diese kann von Objekten des Datentyps <code>Person</code> aufgerufen werden und gibt eine <code>Adresse</code> zur\u00fcck. </p>"},{"location":"objekte2/#aneinanderreihung-von-aufrufen-von-objektmethoden","title":"Aneinanderreihung von Aufrufen von Objektmethoden","text":"<p>Wir h\u00e4tten in der <code>main()</code>-Methode der <code>Testklasse</code> auch folgende Anweisungen ausf\u00fchren k\u00f6nnen:</p> main() in Testklasse.java erweitern <pre><code>public static void main(String[] args)\n{\n    Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n    Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\"); \n\n    Person maria = new Person(\"Musterfrau\", \"Maria\", adresse1);\n    Person max = new Person(\"Mustermann\", \"Max\", adresse2);\n\n    maria.print();\n    max.print();\n\n    Adresse mariasAdresse = maria.getAdresse(); // getAdresse() von Person\n    Adresse maxAdresse = max.getAdresse();      // getAdresse() von Person\n\n    System.out.println(mariasAdresse.getAdresse()); // getAdresse() von Adresse\n    System.out.println(maxAdresse.getAdresse());    // getAdresse() von Adresse\n\n    // ginge auch\n    System.out.println(maria.getAdresse().getAdresse()); // getAdresse() von Person und von Adresse\n    System.out.println(max.getAdresse().getAdresse());   // getAdresse() von Person und von Adresse\n}\n</code></pre> <p>Die Anweisung <code>maria.getAdresse()</code> gibt, wie gesagt, ein <code>Adresse</code>-Objekt zur\u00fcck. Wir m\u00fcssen dieses Objekt nicht zwingend zwischenspeichern (so, wie in Zeile <code>12</code>), sondern k\u00f6nnen auch gleich f\u00fcr dieses Objekt eine Objektmethode aufrufen, n\u00e4mlich z.B. die Methode <code>getAdresse()</code> des Typs <code>Adresse</code>, welche einen <code>String</code> zur\u00fcckgibt, der durch <code>println()</code> ausgegeben wird. Das gleiche passiert in Zeile <code>20</code> mit dem <code>Person</code>-Objekt <code>max</code>, f\u00fcr das zun\u00e4chst die <code>getAdresse()</code>-Methode aus <code>Person</code> aufgerufen wird, welche ein <code>Adresse</code>-Objekt zur\u00fcckgibt und f\u00fcr diese <code>Adresse</code>-Objekt wird die Objektmethode <code>getAdresse()</code> des Typs <code>Adresse</code> aufgerufen. </p> <p>Wir sehen bereits an diesem einfachen Beispiel, dass eine solche Hintereinanderreihung von Aufrufen von Objektmethoden leicht f\u00fcr Verwirrung Sorgen kann und schwer zu verstehen ist. Hier kommt noch gesondert hinzu, dass verschiedene Methoden gleich hei\u00dfen. Eine solche Hintereinanderreihung von Objektmethoden sollten wir m\u00f6glichst vermeiden. Wir k\u00f6nnten unserer <code>Person</code>-Klasse z.B. eine Methode <code>getAdresseString()</code> hinzuf\u00fcgen, die uns die Adresse als <code>String</code> zur\u00fcckgibt:</p> themen/objekte2/Person.java <pre><code>package themen.objekte2;        // extra anders als bei Adresse, um import zu lernen\n\nimport themen.objekte.Adresse;  // das Paket ist bei Ihnen vielleicht anders\n\npublic class Person\n{\n    // ------- Objektvariablen -----------\n    private String name;\n    private String vorname;\n    private Adresse adresse;\n\n    // ------- Konstruktor -----------\n    public Person(String pName, String pVorname, Adresse pAdresse)\n    {\n        name = pName;\n        vorname = pVorname;\n        adresse = pAdresse;\n    }\n\n    // ------- Objektmethoden -----------\n    public void print()\n    {\n        // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse()\n        System.out.println(vorname + \" \" + name + \" wohnt in \" + adresse.getAdresse()); \n    }\n\n    public String getName()\n    {\n        return name;\n    }\n\n    public String getVorname()\n    {\n        return vorname;\n    }\n\n    public Adresse getAdresse()\n    {\n        return adresse;\n    }\n\n    public String getAdresseString()\n    {\n        return adresse.getAdresse();\n    }\n}\n</code></pre> <p>Dann k\u00f6nnten wir in der <code>main()</code>-Methode der <code>Testklasse</code> </p> main() in Testklasse.java erweitern <pre><code>public static void main(String[] args)\n{\n    /* gekuerzt - siehe oben */\n\n    System.out.println(maria.getAdresseString());\n    System.out.println(max.getAdresseString());\n}\n</code></pre> <p>die neue Objektmethode aus <code>Person</code> aufrufen und bek\u00e4men die Adresse als <code>String</code> zur\u00fcck. </p>"},{"location":"objekte2/#das-schlusselwort-this","title":"Das Schl\u00fcsselwort <code>this</code>","text":"<p>Wir wissen jetzt schon, dass Objektmethoden immer nur von Objekten aufgerufen werden k\u00f6nnen. Wir k\u00f6nnen z.B. nicht einfach nur <code>getAdresseString()</code> aus der Klasse <code>Person</code> aufrufen, sondern ben\u00f6tigen ein Objekt der Klasse <code>Person</code>, welches die Objektmethode aufruft. </p> <p>Objektmethoden k\u00f6nnen nur von einem Objekt aufgerufen werden!</p> <p>In dem obigen Beispiel hatten wir z.B. die Objekte <code>maria</code> und <code>max</code> vom Typ <code>Person</code>, die beide jeweils (f\u00fcr sich) die Objektmethode <code>getAdresseString()</code> aufgerufen haben. </p> <p>Wenn wir uns also den Aufruf einer Objektmethode anschauen, dann wissen wir auch immer:</p> <p>Wenn eine Objektmethode aufgerufen wird, dann immer durch genau ein konkretes Objekt. </p> <p>Innerhalb der Klasse <code>Person</code> wissen wir nicht, von welchem konkreten Objekt eine Objektmethode aufgerufen wird. Die Referenzvariablen <code>max</code> und <code>maria</code> sind z.B. innerhalb der Klasse <code>Person</code> nicht sichtbar (es sind lokale Variablen der <code>main()</code>-Methode von <code>Testklasse</code>). Wir wissen aber, dass es ein aufrufendes Objekt gibt (denn nur f\u00fcr ein konkretes Objekt kann eine Objektmethode aufgerufen werden). Dieses konkrete Objekt k\u00f6nnen wir innerhalb der Klasse referenzieren - das machen wir mit dem Schl\u00fcsselwort <code>this</code>. <code>this</code> steht also f\u00fcr das konkrete Objekt, das die Methode (gerade) aufruft. </p> <p><code>this</code> ist das aufrufende Objekt. (genauer: die Referenz auf das aufrufende Objekt)</p> <p>Schauen wir uns zur Wiederholung nochmal die Klasse Circle an. In der dazugeh\u00f6rigen <code>Testklasse</code> hatten wir zwei Objekte der Klasse <code>Circle</code> erstellt und diese Objekte haben Objektmethoden aufgerufen:</p> Testklasse.java <pre><code>public class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        Circle c1 = new Circle(5.0);\n        Circle c2 = new Circle(3.5);\n\n        c1.print();\n        System.out.println();   \n        c2.print();\n\n        System.out.println(\"c1 groesser als c2 ? \" + c1.isBigger(c2));      \n        System.out.println(\"c1 kleiner als c2  ? \" + c1.isSmaller(c2));     \n        System.out.println(\"c1 gleich c2       ? \" + c1.isEqual(c2));\n        System.out.println();\n    }\n}\n</code></pre> <p>In den Zeilen <code>6</code> und <code>7</code> werden die beiden <code>Circle</code>-Objekte erzeugt. In Zeile <code>9</code> ruft das <code>c1</code>-Objekt die <code>print()</code>-Methode auf und in Zeile <code>11</code> ruft das <code>c2</code>-Objekt die <code>print()</code>-Methode auf. Innerhalb der Klasse w\u00e4re dann <code>this</code> einmal das <code>c1</code>-Objekt (n\u00e4mlich bei <code>c1.print()</code>) und ein anderes Mal ist <code>this</code> das <code>c2</code>-Objekt, n\u00e4mlich bei <code>c2.print()</code>. Bei den Aufrufen <code>c1.isBigger(c2)</code>, <code>c1.isSmaller(c2)</code> und <code>c1.isEqual(c2)</code> ist das aufrufende Objekt immer <code>c1</code>. </p> <p>Wozu ben\u00f6tigen wir <code>this</code> \u00fcberhaupt? Bis jetzt kamen wir ohne <code>this</code> aus. Aber schauen wir uns nur einmal den Konstruktor von <code>Circle</code> an:</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double pRadius)\n    {\n        radius = pRadius;\n    }\n}\n</code></pre> <p>Im Konstruktor wird die Objektvariable <code>radius</code> mit dem Wert des Parameters <code>pRadius</code> initialisiert. Die Objektvariable <code>radius</code> ist global, d.h. wir haben in jeder Methode der Klasse Zugriff auf diese Variable. Objektvariablen werden innerhalb der Klasse (nicht innerhalb einer Methode) deklariert und sind deshalb in dem gesamten Anweisungsblock der Klasse, also in der gesamten Klasse sichtbar. Wir k\u00f6nnen in allen Methoden der Klasse auf die Objektvariablen zugreifen. </p> <p>Der Parameter <code>pRadius</code> ist eine lokale Variable. Diese Variable wird in der Methode deklariert und ist auch nur dort sichtbar. Sie existiert auch nur, solange die Methode ausgef\u00fchrt wird. Was passiert aber, wenn wir den Parameter genau wir die Objektvariable nennen?</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double radius)    // Parameter heisst wie die Objektvariable\n    {\n        radius = radius;            // Achtung!!! nur Parameter sichtbar - sogenanntes shadowing!!!\n    }\n}\n</code></pre> <p>Wenn der Parameter genau so hei\u00dft, wie die Objektvariable, gibt es einen Namenskonflikt. Wir k\u00f6nnen in der Methode auf die Objektvariable zugreifen (sie ist ja global), es gibt aber auch eine lokale Variable mit dem gleichen Namen <code>radius</code>. Woher soll der Compiler (oder die Laufzeitumgebung) nun wissen, ob wir die Objektvariable <code>radius</code> meinen oder die lokale Variable <code>radius</code>? </p> <p>Tats\u00e4chlich, stehen in der Anweisung <code>radius = radius;</code> in Zeile <code>9</code> beide <code>radius</code> f\u00fcr den Parameter, d.h. wir weisen dem Parameter <code>radius</code> dort den Wert des Parameters <code>radius</code> zu. Das ist erstens nicht gewollte und zweitens unsinnig. Die Objektvariable <code>radius</code> wird durch den Parameter <code>radius</code> \u00fcberschattet - sogenanntes shadowing. Wenn wir in diesem Falle die Objektvariable <code>radius</code> meinen, dann m\u00fcssen wir <code>this.radius</code> schreiben. </p> <p>Mit <code>this.</code> k\u00f6nnen wir innerhalb der Klasse auf alle Objekteigenschaften (Objektvariablen und Objektmethoden) zugreifen. </p> <p>Die korrekte Implementierung des Konstruktors lautet also:</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double radius)    // Parameter heisst wie die Objektvariable\n    {\n        this.radius = radius;       // Objektvariable = Parameterwert;\n    }\n}\n</code></pre> <p>Jetzt wird der Objektvariablen <code>this.radius</code> der Wert des Parameters <code>radius</code> zugewiesen. </p> <p>Ab jetzt referenzieren wir alle Objekteigenschaften innerhalb der Klasse mit <code>this</code>! Wir passen zun\u00e4chst die Implementierung von <code>Circle</code> an:</p> Circle.java <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktor ----------------\n    public Circle(double radius)    // Parameter heisst wie die Objektvariable\n    {\n        this.radius = radius;       // hier muss this\n    }\n\n    // ----- Getter der Objektvariablen -----\n    public double getRadius()\n    {\n        return this.radius;         // hier kann this - sollte ab jetzt aber immer\n    }\n\n    // ----- weitere Objektmethoden ---------\n    public double getDiameter()\n    {\n        return 2.0 * this.radius;\n    }\n\n    public void print()\n    {\n        System.out.println(\"Radius         : \" + this.radius);\n        System.out.println(\"Durchmesser    : \" + this.getDiameter());   // Aufruf Objektmethode\n        System.out.println(\"Umfang         : \" + this.circumference()); // Aufruf Objektmethode\n        System.out.println(\"Flaecheninhalt : \" + this.area());          // Aufruf Objektmethode\n        System.out.println();\n    }\n\n    public double circumference()\n    {\n        return Math.PI * this.getDiameter();\n    }\n\n    public double area()\n    {\n        return Math.PI * this.radius * this.radius;\n    }\n\n    public boolean isSmaller(Circle c)\n    {\n        return (this.radius &lt; c.radius);\n    }\n\n    public boolean isBigger(Circle c)\n    {\n        return (this.radius &gt; c.radius);\n    }\n\n    public boolean isEqual(Circle c)\n    {\n        return !this.isSmaller(c) &amp;&amp; !this.isBigger(c);\n    }\n}\n</code></pre> <p>Wir sehen, dass wir \u00fcberall dort, wo wir auf Objekteigenschaften zugreifen, die Referenz <code>this.</code> davor gesetzt haben. das sollten wir von un ab in Zukunft auch immer so handhaben, da der Code dann leichter erweiterbar ist (wir m\u00fcssen uns nicht darum k\u00fcmmern, ob eine neue lokale Variable eventuell genau so hei\u00dft, wie eine Objektvariable) und er ist auch besser lesbar, denn wir k\u00f6nnen leichter zwischen Methoden anderer Klassen und eigenen unterscheiden. </p> <p>Betrachten wir die Implementierung der Methode <code>isSmaller()</code> nochmal genauer:</p> <pre><code>public boolean isSmaller(Circle c)\n{\n    return (this.radius &lt; c.radius);\n}\n</code></pre> <p>Angenommen, wir haben, wie oben in dem Beispiel, in der <code>main()</code>-Methode den Aufruf <code>c1.isSmaller(c2)</code>. Dann ist <code>c1</code> das aufrufende Objekt dieser Objektmethode und steht innerhalb der Klasse f\u00fcr das <code>this</code>. Das Objekt <code>c2</code> wird als Parameter \u00fcbergeben und steht in der Implementierung f\u00fcr das Objekt <code>c</code> der Klasse <code>Circle</code>. Innerhalb der Methode werden die Werte von <code>radius</code> vom aufrufenden Objekt <code>this</code> und vom Parameter <code>c</code> miteinander verglichen. </p> <p>Wir passen auch unsere Klasse <code>Person</code> entsprechend an:</p> Person.java mit <code>this</code> <pre><code>package themen.objekte2;        \n\nimport themen.objekte.Adresse;\n\npublic class Person\n{\n    // ------- Objektvariablen -----------\n    private String name;\n    private String vorname;\n    private Adresse adresse;\n\n    // ------- Konstruktor -----------\n    public Person(String name, String vorname, Adresse adresse)\n    {\n        this.name = name;\n        this.vorname = vorname;\n        this.adresse = adresse;\n    }\n\n    // ------- Objektmethoden -----------\n    public void print()\n    {\n        // adresse ist vom Typ Adresse und besitzt die Objektmethode getAdresse()\n        System.out.println(this.vorname + \" \" + this.name + \" wohnt in \" + this.adresse.getAdresse()); \n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public String getVorname()\n    {\n        return this.vorname;\n    }\n\n    public Adresse getAdresse()\n    {\n        return this.adresse;\n    }\n\n    public String getAdresseString()\n    {\n        return this.adresse.getAdresse();\n    }\n}\n</code></pre> <p>Insbesondere innerhalb der Mthode <code>getAdresseString()</code> erkennen wir gut, dass wir darin nicht auf die <code>getAdresse()</code>-Methode von <code>Person</code> zugreifen, sondern auf die <code>getAdresse()</code>-Methode von <code>Adresse</code>. Wir haben auch die Parameter des Konstruktors anegpasst, denn es ist v\u00f6llig \u00fcblich, die Parameter so zu nennen, wie die Objektvariablen, die damit initialisiert werden sollen. Aber dann muss vor den Objektvariablen auch jeweils <code>this.</code> stehen!</p> Integrieren Sie auch in den Klassen <code>Adresse</code> und <code>Point</code> die <code>this.</code>-Referenz!"},{"location":"objekte2/#mehrere-konstruktoren","title":"Mehrere Konstruktoren","text":"<p>Es kann vorkommen, dass wir gar nicht allen Objektvariablen einen Wert im Konstruktor \u00fcbergeben wollen. Wenn wir f\u00fcr eine Objektvariable keinen Wert im Konstruktor \u00fcbergeben, dann soll dieser Objektvariablen ein Standardwert zugewiesen werden. Ein einfaches Beispiel w\u00e4re, dass wir f\u00fcr unsere Klasse <code>Circle</code> einen Konstruktor haben, dem ein Wert f\u00fcr <code>radius</code> \u00fcbergeben wird und einen Konstruktor, der parameterlos ist, dem also kein Wert f\u00fcr <code>radius</code> \u00fcbergeben wird. In diesem Fall soll <code>radius</code> den Wert <code>1.0</code> annhmen, also der Einheitskreis sein. </p> <p>Diese Anforderung erf\u00fcllen wir, indem wir zwei Konstruktoren definieren:</p> Circle.java mit zwei Konstruktoren <pre><code>public class Circle\n{\n    // ------- Objektvariable ---------------\n    private double radius;\n\n    // --------- Konstruktoren ----------------\n    public Circle(double radius)    // Parameter heisst wie die Objektvariable\n    {\n        this.radius = radius;       // hier muss this\n    }\n\n    public Circle()                 // parameterlos\n    {\n        this.radius = 1.0;          // Standardwert - Einheitskreis\n    }\n\n    /* alle anderen Methoden bleiben, wie sie sind - siehe oben */\n}\n</code></pre> <p>Jetzt k\u00f6nnen Objekte von <code>Circle</code> sowohl unter Verwendung des parametrisierten Konstruktors, als auch unter Verwendung des parameterlosen Konstruktors erzeugt werden:</p> Testklasse.java - Auszug main()-Methode <pre><code>Circle c1 = new Circle(5.0);\nCircle c2 = new Circle(3.5);\nCircle c3 = new Circle();       // parameterloser Konstruktor - Einheitskreis\n\nc1.print(); \nc2.print();\nc3.print();\n</code></pre> <p>ergibt folgende Ausgabe:</p> <pre><code>Radius         : 5.0\nDurchmesser    : 10.0\nUmfang         : 31.41592653589793\nFlaecheninhalt : 78.53981633974483\n\nRadius         : 3.5\nDurchmesser    : 7.0\nUmfang         : 21.991148575128552\nFlaecheninhalt : 38.48451000647496\n\nRadius         : 1.0\nDurchmesser    : 2.0\nUmfang         : 6.283185307179586\nFlaecheninhalt : 3.141592653589793\n</code></pre> <p>Das Prinzip, das hierbei angewendet wird, nennt sich \u00dcberladen von Methoden. </p>"},{"location":"objekte2/#uberladen-von-methoden","title":"\u00dcberladen von Methoden","text":"<p>Das \u00dcberladen von Methoden erfolgt immer dann, wenn Methoden gleichen Namens existieren. Wichtig ist, dass sich diese Methoden in ihrer Parameterliste unterscheiden.</p> <p>Was bedeutet, dass sich Parameterlisten von Methoden unterscheiden? Methoden haben eine unterschiedliche Parameterliste, wenn</p> <ul> <li>sich die Anzahl der Parameter unterscheidet oder wenn</li> <li>sich die Typen bzw. die Typreihenfolge der Parameter unterscheiden. </li> </ul> <p>Angenommen, unsere Methode hei\u00dft <code>method</code>, dann haben folgende Methoden eine unterschiedliche Parmaterliste:</p> <ol> <li><code>method(int number)</code>                 // nur ein Parameter</li> <li><code>method(int nr1, int nr2)</code>           // zwei Parameter int, int</li> <li><code>method(double nr1, double nr2)</code>     // zwei parameter double, double</li> <li><code>method(int nr1, double nr2)</code>        // zwei Parameter int, double</li> <li><code>method(double nr1, int nr2)</code>        // zwei parameter double, int</li> </ol> <p>Die Methode <code>method</code> w\u00e4re also in diesem Fall (wenn es jeweils noch passende Implementierungen dazu gibt), f\u00fcnf Mal \u00fcberladen. Dem Compiler muss beim Aufruf klar sein, welche der jeweiligen Methoden er aufrufen muss. Das ist durch unterschiedliche Parameterlisten gegeben. Folgende Beispiele zeigen dies:</p> <ul> <li><code>method(3.0, 3);</code>     // ruft Methode 5. auf</li> <li><code>method(3, 3);</code>       // ruft Methode 2. auf</li> <li><code>method(3.0, 3.0);</code>   // ruft Methode 3. auf</li> <li><code>method(3);</code>          // ruft Methode 1. auf</li> <li><code>method(3, 3.0);</code>     // ruft Methode 4. auf</li> </ul> <p>Die Namen der Parameter spielen keine Rolle. Beispielsweise w\u00e4re <code>method(int number1, int number2)</code> ein Dopplung zu Methode 2. Das programm lie\u00dfe sich gar nicht \u00fcbersetzen. Auch der R\u00fcckgabetyp wird nicht zur Unterscheidung der Methodensignatur  hinzugezogen. Die beiden Methoden <code>int method(int nr1, int nr2)</code> und <code>double method(int nr1, int nr2)</code> w\u00e4ren ebenfalls eine Dopplung. Woher soll der Compiler beim Aufruf von z.B.  <code>method(3, 3);</code> wissen, welche der beiden Methoden ausgef\u00fchrt werden soll, die die ein <code>int</code> zur\u00fcckgibt oder die, die ein <code>double</code> zur\u00fcckgibt. </p> <p>Zur Methodensignatur geh\u00f6ren der Name der Methode und die Parameterliste.</p> <p>F\u00fcr alle Methoden einer Klasse m\u00fcssen sich deren Methodensignaturen unterscheiden, also entweder deren Namen oder deren Parameterlisten. </p>"},{"location":"objekte2/#mehrere-konstruktoren-in-point","title":"Mehrere Konstruktoren in <code>Point</code>","text":"<p>F\u00fcr unsere Klasse <code>Point</code> wollen wir ebenfalls mehrere Konstruktoren definieren:</p> <ul> <li>Konstruktor mit zwei Paramtern (haben wir schon) \u2192 <code>x</code> und <code>y</code> werden mit den Parameterwerten initialisiert</li> <li>Konstruktor mit einem Parameter \u2192 <code>x</code> und <code>y</code> bekommen den gleichen Wert, den des Parameters</li> <li>Konstruktor ohne Parameter \u2192 <code>x</code> und <code>y</code> bekommen jeweils den Wert <code>0</code></li> </ul> Point.java Ausschnitt nur Konstruktoren <pre><code>public class Point\n{\n    // --- Objektvariablen -----------\n    private int x;\n    private int y;\n\n    // --- Konstruktoren ---------------\n    public Point(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    public Point(int value)\n    {\n        this.x = value;\n        this.y = value;\n    }\n\n    public Point()\n    {\n        this.x = 0;\n        this.y = 0;\n    }\n\n    /* restliche Methoden bleiben gleich - hier gekuerzt    */\n    /* siehe oben.                                          */ \n</code></pre>"},{"location":"objekte2/#mehrere-konstruktoren-in-person","title":"Mehrere Konstruktoren in <code>Person</code>","text":"<p>Der Konstruktor in <code>Person</code> sieht derzeit so aus:</p> <pre><code>public Person(String name, String vorname, Adresse adresse)\n{\n    this.name = name;\n    this.vorname = vorname;\n    this.adresse = adresse;\n}\n</code></pre> <p>Das hei\u00dft, wir erwarten ein Objekt vom Typ <code>Adresse</code>, um ein Objekt vom Typ <code>Person</code> erstellen zu k\u00f6nnen. Es k\u00f6nnte ja aber sein, dass ein solches Objekt (noch) gar nicht existiert und wir selbst ein solches Objekt innerhalb unserer Konstruktors erstellen m\u00fcssen. Wir br\u00e4uchten daf\u00fcr nur alle Informationen, um das Objekt erstellen zu k\u00f6nnen, also </p> <ul> <li>eine Strasse (<code>String</code>), </li> <li>eine Hausnummer (<code>int</code>),</li> <li>ein Wohnort (<code>String</code>) und</li> <li>eine Postleitzahl (<code>int</code>).</li> </ul> <p>Wir erstellen uns einen Konstruktor, der daf\u00fcr Werte \u00fcbergibt (und auch f\u00fcr <code>name</code> und <code>vorname</code>):</p> <pre><code>public Person(String name, String vorname, String strasse, int nummer, int postleitzahl, String wohnort)\n{\n    this.name = name;\n    this.vorname = vorname;\n    this.adresse = new Adresse(strasse, nummer, postleitzahl, wohnort);\n}\n</code></pre> <p>Es wird also kein existierendes <code>Adresse</code>-Objekt dem Konstruktor \u00fcbergeben, sondern erst im Konstruktor eines erstellt. Die restliche Implementierung der Klasse <code>Person</code> \u00e4ndert sich aber nicht, da sich ja auch f\u00fcr <code>adresse</code> nichts ge\u00e4ndert hat - die Variable zeigt auf ein <code>Adresse</code>-Objekt. </p>"},{"location":"objekte2/#objekterzeugende-methoden","title":"Objekterzeugende Methoden","text":"<p>Genau die gleiche L\u00f6sung k\u00f6nnen wir verwenden, wenn eine <code>Person</code> umzieht, also ihre <code>Adresse</code> \u00e4ndert. <code>umzug()</code> ist dabei auf jeden Fall eher eine Eigenschaft der Klasse <code>Person</code>, als der Klasse <code>Adresse</code>! Wir erweitern die Klasse <code>Person</code> um zwei <code>umzug()</code>-Methoden. Die eine erwartet ein (neues) <code>Adresse</code>-Objekt und die andere bekommt Werte f\u00fcr die Erstellung eines neuen <code>Adresse</code>-Objektes \u00fcbergeben:</p> Person.java - Auszug: umzug()-Methoden <pre><code>public void umzug(Adresse neueAdresse)\n{\n    this.adresse = neueAdresse;\n}\n\npublic void umzug(String neueStrasse, int neueNummer, int neuePostleitzahl, String neuerWohnort)\n{\n    this.adresse = new Adresse(neueStrasse, neueNummer, neuePostleitzahl, neuerWohnort);\n}\n</code></pre> <p>Der Aufruf in der <code>main()</code>-Methode k\u00f6nnte dann so aussehen:</p> <pre><code>public static void main(String[] args)\n{\n    Adresse adresse1 = new Adresse(\"Wilhelminenhofstr.\", 75, 12459, \"Berlin\");          \n    Adresse adresse2 = new Adresse(\"Treskowallee\", 8, 10318, \"Berlin\"); \n\n    Person maria = new Person(\"Musterfrau\", \"Maria\", adresse1); \n    System.out.println(maria.getAdresseString());\n    maria.umzug(adresse2);\n    System.out.println(maria.getAdresseString());\n    maria.umzug(\"Rudower Chaussee\", 25, 12489, \"Berlin\");\n    System.out.println(maria.getAdresseString());\n}\n</code></pre> <p>mit folgender Ausgabe:</p> <pre><code>Wilhelminenhofstr. 75 in 12459 Berlin\nTreskowallee 8 in 10318 Berlin\nRudower Chaussee 25 in 12489 Berlin\n</code></pre>"},{"location":"objekte2/#objekterzeugende-methoden-mit-objekt-als-ruckgabe","title":"Objekterzeugende Methoden mit Objekt als R\u00fcckgabe","text":"<p>Wir betrachten zur Wiederholung erneut die Klasse <code>Point</code>. Wir erinnern uns: ein <code>Point</code> bestand aus einer <code>x</code>- und einer <code>y</code>-Koordinate. Wir hatten verschiedene Objektmethoden f\u00fcr <code>Point</code> erstellt - siehe hier. </p> <p>Angenommen, wir wollen zwei Punkte addieren - z.B. ein <code>Point p1</code> und ein <code>Point p2</code>. Die Idee dabei ist, dass die Summe der beiden <code>x</code>-Werte (<code>p1.x + p2.x</code>) einen neuen <code>x</code>-Wert und die Summe der beiden <code>y</code>-Werte (<code>p1.y + p2.y</code>) einen neuen <code>y</code>-Wert ergibt. </p> <p>Wir starten einen ersten Versuch und implementieren eine <code>add()</code>-Methode wie folgt:</p> <pre><code>public void add(Point p)\n{\n    this.x = this.x + p.x;\n    this.y = this.y + p.y;\n}\n</code></pre> <p>Der Aufruf in einer <code>Testklasse</code> mit:</p> <pre><code>Point p1 = new Point(1, 2);\nPoint p2 = new Point(2, 4);\n\np1.print();\np1.add(p2);\np1.print();\n</code></pre> <p>f\u00fchrt zu folgender Ausgabe:</p> <pre><code>[ x=1, y=2 ]\n[ x=3, y=6 ]\n</code></pre> <p>Das hei\u00dft, durch die Addition mit <code>p2</code> hat sich das <code>p1</code>-Objekt ge\u00e4ndert. Die Frage ist, ob das beabsichtigt ist und eine eindeutige Antwort ja oder nein kann hier nicht gegeben werden. Es ist nicht ganz klar, ob sich das aufrufende Objekt selbst ver\u00e4ndern sollte, wenn es mit einem anderen <code>Point</code> addiert wird. Insbesondere macht es einen Unterschied, ob wir <code>p1.add(p2)</code> aufrufen oder <code>p2.add(p1)</code>. Im ersten Fall ist nach der Addition <code>p1 -&gt; [ x=3, y=6 ]</code> und <code>p2 -&gt; [ x=2, y=4 ]</code>. Im zweiten Fall ist nach der Addition <code>p1 -&gt; [ x=1, y=2 ]</code> und <code>p2 -&gt; [ x=3, y=6 ]</code>. Wir erreichen also einen anderen Gesamtzustand des Systems. </p> <p>Es spricht Vieles daf\u00fcr, die Implementierung zu \u00e4ndern und die beiden sich addierenden Punkte unver\u00e4ndert zu lassen und stattdessen einen neuen <code>Point</code> zu erzeugen:</p> <pre><code>public Point add(Point p)\n{\n    int newX = this.x + p.x;\n    int newY = this.y + p.y;\n    return new Point(newX, newY);\n}\n</code></pre> <p>Das hei\u00dft, wir ermitteln erneut die Summen <code>this.x + p.x</code> bzw. <code>this.y + p.y</code>, doch anstelle mit diesen Summen das aufrufende Objekt zu \u00e4ndern, wird ein neues <code>Point</code>-Objekt erstellt. Wenn man sich nun den Gesamtzustand des gesamten Systems nach der Addition von <code>p1</code> und <code>p2</code> anschaut, dann ist es egal, ob wir <code>p1.add(p2)</code> oder ob wir <code>p2.add(p1)</code> aufgerufen haben. Wir haben nach der Addition drei Point-Objekte mit den Werten <code>p1 -&gt; [ x=1, y=2 ]</code>, <code>p2 -&gt; [ x=2, y=4 ]</code> und ein neues <code>Point</code>-Objekt mit <code>[ x=3, y=6 ]</code>.</p> <p>Obiges Beispiel aus der Testklasse w\u00fcrde dann so aussehen:</p> <pre><code>Point p1 = new Point(1, 2);\nPoint p2 = new Point(2, 4);\n\np1.print();\nPoint p3 = p1.add(p2);  // kann auch p2.add(p1), ist egal\np3.print();\n</code></pre> <p>mit der Ausgabe</p> <pre><code>[ x=1, y=2 ]\n[ x=3, y=6 ]\n</code></pre> <p>Wesentlichster Unterschied zur ersten Variante ist, dass sich weder <code>p1</code> noch <code>p2</code> durch die Addition ge\u00e4ndert haben. Wenn wir das Ziel verfolgen, m\u00f6glichst unver\u00e4nderliche Objekte zu erzeugen, dann ist die zweite L\u00f6sung auf jeden Fall die bessere. So oder so haben wir eine Methode kennengelernt, in der ein Objekt der Klasse erzeugt und dieses Objekt zur\u00fcckgegeben wird. Solche Objekte kommen nicht selten vor - und nun kennen wir ein Beispiel. Weitere Beispiele werden wir in der Aufgabe Bruch erzeugen.  </p> <p>Success</p> <p>Wir haben eigene Datentypen in der Definition eigener Datentypen verwendet. Wir haben das Schl\u00fcsselwort <code>this</code> kennengerlernt, mit dem wir innerhalb der Klasse das aufrufende Objekt referenzieren k\u00f6nnen. Wir haben das \u00dcberladen von Methoden betrachtet und Konstruktoren in Klassen mehrfach \u00fcberladen. Das \u00dcberladen von Methoden l\u00e4sst sich auf alle Methoden anwenden. Dar\u00fcber hinaus haben wir Methoden erstellt, in denen Objekte erzeugt werden. Zuletzt gibt eine solche Methode das von ihr erzeugte Objekt auch zur\u00fcck. </p>"},{"location":"selektion/","title":"Selektion","text":"<p>In Programmablaufstrukturen haben wir uns die drei Kontrollstrukturen angeschaut, die in Programmen vorkommen k\u00f6nnen:</p> <ul> <li>die Sequenz,</li> <li>die Iteration und</li> <li>die Selektion. </li> </ul> <p>Wir betrachten nun die Selektion genauer und schauen uns an, wie wir sie in Java umsetzen. </p>"},{"location":"selektion/#ifelse","title":"<code>if...else</code>","text":"<p>Bei der Selektion ist die Ausf\u00fchrung von Anweisungen von einer Bedingung abh\u00e4ngig. Angenommen, wir wollen erreichen, dass eine Zahl <code>number</code> halbiert wird, wenn sie gerade ist oder sie wird mit 3 multipliziert und 1 addiert, wenn sie ungerade ist. Es findet also eine Selektion der Anwesiungen statt, je nachdem ob <code>number</code> gerade ist oder nicht. Als \"Pseudocode\" sieht das so aus:</p> <pre><code>wenn (number ist gerade)\n    dann teile number durch 2\nsonst\n    multipliziere number mit 3 und addiere 1\n</code></pre> <p>In Java gibt es daf\u00fcr die <code>if ... else</code>-Anweisung:</p> <pre><code>if(number%2 == 0)\n{\n    number = number / 2;\n}\nelse\n{\n    number = 3 * number +1;\n}\n</code></pre> <p>Das hei\u00dft, es wird zun\u00e4chst eine Bedingung (ein Ausdruck vom Typ <code>boolean</code>) gepr\u00fcft. Ist der Wert dieser Bedingung <code>true</code>, dann wird der erste Anweisungsblock ausgef\u00fchrt. Ist der Wert der Bedingung jedoch <code>false</code>, dann wird der zweite Anweisungsblock (der nach dem <code>else</code>) ausgef\u00fchrt. Es wird also genau einer der beiden Anweisungsbl\u00f6cke ausgef\u00fchrt - entweder der eine oder der andere (je nach Wert der Bedingung). </p> <p>Noch ein Beispiel aus dem euklidischen Algorithmus:</p> <pre><code>if(a &gt; b)\n{\n    a = a - b;\n}\nelse\n{\n    b = b - a;\n}\n</code></pre> <p>Innerhalb der Anweisungsbl\u00f6cke k\u00f6nnen nat\u00fcrlich jeweils mehrere Anweisungen stehen. Als Information sei hier gesagt, dass es theoretisch m\u00f6glich ist, bei nur einer Anweisung die Klammern wegzulassen, also z.B.</p> <pre><code>if(a &gt; b)   a = a - b;\nelse        b = b - a;\n</code></pre> <p>Aber wir machen das nicht, da solche Programme nicht gut erweiterbar sind! Es gibt gen\u00fcgend Beispiele, in denen so etwas schief lief (z.B. bei Apple). </p> <p>Die allgemeine Syntax einer solchen Selektion sieht also wie folgt aus:</p> <pre><code>if(bedingung)\n{\n    /* \n     * Anweisungsblock, der ausgef\u00fchrt wird,\n     * wenn die bedingung true ist.\n     * das k\u00f6nnen beliebig viele Anweisungen sein:\n     * Sequenzen, Iterationen und/oder Selektionen\n     */\n}\nelse\n{\n    /* \n     * Anweisungsblock, der ausgef\u00fchrt wird,\n     * wenn die bedingung false ist.\n     * das k\u00f6nnen beliebig viele Anweisungen sein:\n     * Sequenzen, Iterationen und/oder Selektionen\n     * dieser else-Block kann aber auch ganz weg-\n     * gelassen werden - sehen wir gleich \n     */\n}\n</code></pre>"},{"location":"selektion/#bedingungen","title":"Bedingungen","text":"<p>Bevor wir uns noch weitere Varianten der <code>if...else</code>-Anweisung anschauen, gehen wir nochmal darauf ein, was eine Bedingung ist. </p> <pre><code>Eine Bedingung ist ein logischer Ausdruck, \n- d.h. der Datentyp des Wertes einer Bedingung ist `boolean`,\n- d.h. der Wert einer Bedingung ist entweder `true` oder `false`\n</code></pre> <p>Wir betrachten einige Beispiele von Bedingungen (wir nehmen an, dass die Methoden <code>isOdd(int)</code> und <code>notZero(int)</code> existieren und ein <code>boolean</code> zur\u00fcckgeben):</p> <pre><code>boolean cond1 = true;                   // kann genutzt werden als if(cond1) oder if(true)\nboolean cond2 = cond1;                  // kann genutzt werden als if(cond2) oder if(cond1)\nboolean cond3 = cond1 &amp;&amp; true;          // kann genutzt werden als if(cond3) oder if(cond1 &amp;&amp; true)\nboolean cond4 = (7 &gt;= 4);               // kann genutzt werden als if(cond4) oder if(7 &gt;= 4)\nboolean cond5 = (7 &gt;= 4) &amp;&amp; (3 &lt; 5);    // kann genutzt werden als if(cond5) oder if((7 &gt;= 4) &amp;&amp; (3 &lt; 5))\nboolean cond6 = cond5 ||\u00a0cond3;         // kann genutzt werden als if(cond6) oder if(cond5 ||\u00a0cond3)\nboolean cond7 = isOdd(3) &amp;&amp; notZero(3); // kann genutzt werden als if(cond7) oder if(isOdd(3) &amp;&amp; notZero(3))\n</code></pre> <p>Wichtig ist also, dass alle Werte, die vom Typ <code>boolean</code> sind, als Bedingungen verwendet werden k\u00f6nnen. Achten Sie auch darauf, dass die Ausdr\u00fccke selbst (also die Bedingungen) kein Semikolon am Ende haben - Ausdr\u00fccke sind keine Anweisungen.</p> <p>Beachte</p> <p>Vergleichen Sie logische Ausdr\u00fccke nicht mit <code>true</code>! Man sieht h\u00e4ufig so etwas wie <code>isOdd(3) == true</code>. Das ist unn\u00f6tig! Angenommen, der Wert von <code>isOdd(3)</code> ist <code>true</code>, dann ist auch der Vergleich <code>isOdd(3) == true</code> <code>true</code>. Angenommen, der Wert von <code>isOdd(3)</code> ist <code>false</code>, dann ist auch der Vergleich <code>isOdd(3) == true</code> <code>false</code>. Das bedeutet, der Wert des Vergleiches entspricht exakt dem Wert von <code>isOdd(3)</code>, also benutzen wir nur <code>isOdd(3)</code>.</p>"},{"location":"selektion/#ifelse-ohne-else-block","title":"<code>if...else</code> ohne <code>else</code>-Block","text":"<p>Der <code>else</code>-Block ist nicht zwingend n\u00f6tig. Es gibt Beispiele, in denen etwas getan werden soll, wenn eine bestimmte Bedingung gilt, aber wenn sie nicht gilt, dann muss auch nichts getan werden, z.B. (Methoden ausgedacht):</p> <pre><code>if(fileOpen(file))\n{\n    closeFile(file);\n}\n\nif(connectionEstablished(database))\n{\n    disconnect(database);\n}\n\nif(divisor == 0)\n{\n    System.out.println(\"Divsion durch 0 nicht m\u00f6glich!\");\n}\n</code></pre>"},{"location":"selektion/#verschachtelte-selektionen","title":"Verschachtelte Selektionen","text":"<p>Die Anweisungsbl\u00f6cke sowohl im <code>true</code>-Zweig als auch im <code>else</code>-Zweig k\u00f6nnen beliebige Kontrollstrukturen enthalten:</p> <ul> <li>nur eine Anweisung oder</li> <li>Sequenzen von Anweisungen und/oder</li> <li>Iterationen und/oder</li> <li>Selektionen.</li> </ul> <p>Ist eine Selektion innerhalb einer Selektion, spricht man auch von verschachtelten Selektionen. Angenommen, wir haben drei <code>int</code>-Variablen <code>a</code>, <code>b</code>, <code>c</code> und wollen diese der Gr\u00f6\u00dfe nach sortieren (und wollen auch noch pr\u00fcfen, ob die Werte evenzuell gleich sind):</p> <pre><code>// a, b, c vom Typ `int`\nif(a &gt; b)\n{\n    if(b &gt; c)\n    {\n        System.out.println(\"a &gt; b &gt; c\");\n    }\n    else    // c &gt;= b\n    {\n        if(c &gt; b)\n        {\n            if(a &gt; c)\n            {\n                System.out.println(\"a &gt; c &gt; b\");\n            }\n            else // c &gt;= a\n            {\n                if(c &gt; a)\n                {\n                    System.out.println(\"c &gt; a &gt; b\");\n                }\n                else    // c == a\n                {\n                    System.out.println(\"c = a &gt; b\");\n                }\n            }\n        }\n        else    // c == b\n        {\n            System.out.println(\"a &gt; b = c\");\n        }\n    }\n}\nelse    // b &gt;= a\n{\n    if(b &gt; a) \n    {\n        if(b &gt; c)\n        {\n            if(a &gt; c) \n            {\n                System.out.println(\"b &gt; a &gt; c\");\n            }\n            else // c &gt;= a\n            {\n                if(c &gt; a)\n                {\n                    System.out.println(\"b &gt; c &gt; a\");\n                }\n                else // a == c\n                {\n                    System.out.println(\"b &gt; a = c\");\n                }\n            }\n        }\n        else // c &gt;= b\n        {\n            if(c == b)\n            {\n                System.out.println(\"b = c &gt; a\");\n            }\n            else // c &gt; b\n            {\n                System.out.println(\"c &gt; b &gt; a\");\n            }\n        }   \n    }\n    else    // b == a\n    {\n        if(b &gt; c)\n        {\n            System.out.println(\"a = b &gt; c\");\n        }\n        else // c &gt;= b\n        {\n            if(c == b)\n            {\n                System.out.println(\"a = b = c\");\n            }\n            else // c &gt; b\n            {\n                System.out.println(\"c &gt; b = a\");\n            }\n        }       \n    }\n}\n</code></pre> <p>Sie sehen, so etwas wird sehr schnell sehr un\u00fcbersichtlich. Wir sollten versuchen, solche Verschachtelungen nur auf sehr geringe Verschachtelungstiefen zu beschr\u00e4nken. Die beste M\u00f6glichkeit, solche Verschachtelungstiefen zu vermeiden, besteht darin, die Bedingungen komplexer zu gestalten indem wir logische Operatoren verwenden, z.B. <code>if(a &gt; b) &amp;&amp; (b &gt; c))</code>. Wir zeigen das mal am obigen Beispiel, in dem wir gar keine Verschachtelungstiefe haben:</p> <pre><code>// a, b, c vom Typ `int`\nif(a &gt; b &amp;&amp; b &gt; c)\n{\n    System.out.println(\"a &gt; b &gt; c\");    \n}\nif(a &gt; b &amp;&amp; c &gt; b &amp;&amp; a &gt; c)\n{\n    System.out.println(\"a &gt; c &gt; b\");    \n}\nif(a &gt; b &amp;&amp; c &gt; b &amp;&amp; c &gt; a)\n{\n    System.out.println(\"c &gt; a &gt; b\");    \n}\nif(a &gt; b &amp;&amp; c &gt; b &amp;&amp; c == a)\n{\n    System.out.println(\"a = c &gt; b\");\n}\nif(a &gt; b &amp;&amp; b == c)\n{\n    System.out.println(\"a &gt; b = c\");\n}\nif(a == b &amp;&amp; b == c)\n{\n    System.out.println(\"a = b = c\");\n}\nif(a == b &amp;&amp; b &gt; c)\n{\n    System.out.println(\"a = b &gt; c\");\n}\nif(a == b &amp;&amp; c &gt; b)\n{\n    System.out.println(\"c &gt; a = b\");\n}\nif(b &gt; a &amp;&amp; a &gt; c)\n{\n    System.out.println(\"b &gt; a &gt; c\");\n}\nif(b &gt; a &amp;&amp; c &gt; a &amp;&amp; b &gt; c)\n{\n    System.out.println(\"b &gt; c &gt; a\");\n}\nif(b &gt; a &amp;&amp; c &gt; a &amp;&amp; b == c)\n{\n    System.out.println(\"b = c &gt; a\");\n}\nif(b &gt; a &amp;&amp; c == a)\n{\n    System.out.println(\"b &gt; c = a\");\n}\nif(b &gt; a &amp;&amp; c &gt; b)\n{\n    System.out.println(\"c &gt; b &gt; a\");\n}\n</code></pre> \u00dcbung <p>Bei welchem der beiden oberen Programme werden (im Durchschnitt) mehr Vergleiche durchgef\u00fchrt und warum?</p> <p>Das Problem mit komplexen Bedingungen besteht darin, dass diese recht schwer zu verstehen sind. F\u00fcr komplexe Bedingungen sollten wir stets eigene Methoden definieren (die ein <code>boolean</code>zur\u00fcckgeben) und die mit ihrem Namen verraten, was die Bedingung pr\u00fcft. Darauf kommen wir sp\u00e4ter nochmal zur\u00fcck. </p>"},{"location":"selektion/#switch-anweisung","title":"<code>switch</code>-Anweisung","text":"<p>Die <code>switch</code>-Anweisung war in Java lange ungl\u00fccklich gel\u00f6st. Die <code>switch</code>-Anweisung kann verwendet werden, wenn Sie viele Fallunterscheidungen haben. Wir geben zun\u00e4chst ein Beispiel in der alten Form der <code>switch</code>-Anweisung, die immer noch funktioniert und die Sie so wahrscheinlich auch noch sehr h\u00e4ufig antreffen werden:</p> <pre><code>// monat vom Typ `int`\nswitch(monat)\n{\n    case 1: System.out.println(\"Januar\");\n            break;\n    case 2: System.out.println(\"Februar\");\n            break;\n    case 3: System.out.println(\"M\u00e4rz\");\n            break;\n    case 4: System.out.println(\"April\");\n            break;\n    case 5: System.out.println(\"Mai\");\n            break;\n    case 6: System.out.println(\"Juni\");\n            break;\n    case 7: System.out.println(\"Juli\");\n            break;\n    case 8: System.out.println(\"August\");\n            break;\n    case 9: System.out.println(\"September\");\n            break;\n    case 10: System.out.println(\"Oktober\");\n            break;\n    case 11: System.out.println(\"November\");\n            break;\n    case 12: System.out.println(\"Dezember\");\n            break;\n    default: System.out.println(\"kein Monat\");\n}\n</code></pre> <p>Betrachten wir die Anweisung zun\u00e4chst etwas genauer. Die Fallunterscheidungen betreffen den Wert der <code>int</code>-Variablen <code>monat</code>. Das bedeutet schonmal, dass in den runden Klammern der <code>switch()</code>-Anweisung keine Bedingung steht, sondern ein Ausdruck, der von verschiedenen Datentypen sein kann, z.B. <code>byte</code>, <code>short</code>, <code>int</code> und <code>String</code>. </p> <p>Der Ablauf einer <code>switch()</code>-Anweisung ist nun so, dass f\u00fcr den entsprechenden Wert der <code>case</code> gesucht wird, also z.B. wenn <code>month</code> den Wert <code>6</code> hat, dann ist <code>case 6:</code> der \"Einsprungspunkt\". Dort werden nun alle Anweisungen abgearbeitet, bis</p> <ul> <li>entweder ein <code>break;</code> kommt oder</li> <li>die <code>switch()</code>-Anweisung beendet ist. </li> </ul> <p><code>break;</code> stoppt also die Abarbeitung. W\u00fcrde in unserem Beispiel kein <code>break</code> enthalten sien und w\u00e4re <code>month</code>z.B. <code>6</code>, dann w\u00fcrden alle Monate ab und inkl. Juli ausgegeben werden. Der <code>default:</code>-Fall ist daf\u00fcr, falls keine der <code>case</code> passt. Der <code>default:</code>-Fall ist optional. </p> <p>Dass die Anweisungen nach <code>case x:</code> nicht in Anweisungsbl\u00f6cken stehen und dass die Verwendung von <code>break;</code> erforderlich ist, um die Ausf\u00fchrung von Anweisungen zu stoppen, macht diese alte Syntax der <code>switch()</code>-Anweisung unsch\u00f6n. Wir betrachten noch ein Beispiel in der alten Syntax, um den Unterschied zur neuen noch besser zu erl\u00e4utern:</p> <pre><code>// monat vom Typ `int`\nint anzahlTageImMonat = 0;\nswitch(monat)\n{\n    case 1: \n    case 3: \n    case 5: \n    case 7: \n    case 8: \n    case 10: \n    case 12: anzahlTageImMonat = 31;\n             break;\n    case 4: \n    case 6: \n    case 9: \n    case 11: anzahlTageImMonat = 30;\n             break;\n    case 2:  anzahlTageImMonat = 28;\n}\n</code></pre> <p>Ab Java 12 wurde die <code>switch()</code>-Anweisung gr\u00fcndlich \u00fcberarbeitet. Wir betrachten das so eben gezeigte Beispiel nun in der neuen Schreibweise:</p> <pre><code>int anzahlTageImMonat = switch(monat)\n{\n    case 1, 3, 5, 7, 8, 10, 12 -&gt; 31;\n    case 4, 6, 9, 11 -&gt; 30;  \n    case 2 -&gt; 28;\n    default -&gt; 0;\n};\n</code></pre> <p>Mehrere Dinge fallen auf:</p> <ol> <li>kann eine <code>switch()</code>-Anweisung nun auch als Ausdruck verwendet werden und somit z.B. einer Variablen einen Wert zu weisen (das machen wir hier)</li> <li>hat sich die Schreibweise beim <code>case</code> ge\u00e4ndert. Aus dem Doppelpunkt wurde ein Pfeil und es k\u00f6nnen mit einem <code>case</code> auch mehrere durch Komma getrennte Werte aufgef\u00fchrt werden</li> <li>und - besonders gut - wir ben\u00f6tigen kein <code>break</code>mehr. Es wird immer nur der <code>case</code> ausgef\u00fchrt. Die Abarbeitung der dort beschriebenen Anweisungen stoppt beim n\u00e4chsten <code>case</code> bzw. bei <code>default</code> oder am Ende der <code>switch()</code>-Anweisung</li> </ol> <p>Success</p> <p>Wir haben 2 M\u00f6glichkeiten kennengelernt, die Selktion in Java zu implementieren. Die eine (und bedeutendste) M\u00f6glichkeit ist die <code>if...else</code>-Anweisung. Dort wird in Abh\u00e4ngigkeit vom Wahreheitswert einer Bedingung entweder der eine oder der andere Anweisungsblock ausgef\u00fchrt. Der <code>else</code>-Block kann auch weggelassen werden. Innerhalb eines Anweisungsblockes k\u00f6nnen beliebige Kontrollstrukturen stehen: Sequenzen, Iterationen und Selektionen.  Die zweite M\u00f6glichkeit ist die <code>switch()</code>-Anweisung, die seit Java 12 auch selbst ein Ausdruck sein kann. Wir haben die alte Syntax der <code>switch()</code>-Anweisung kritisch betrachtet und die neue Syntax kennengelernt.</p>"},{"location":"sortieren/","title":"Sortieren von Arrays","text":"<p>Es ist h\u00e4ufig notwendig, die Elemente von bestimmten Datenstrukturen (Arrays, Listen, B\u00e4ume, \u2026 - bis jetzt kennen wir davon nur Arrays) zu sortieren. Dazu muss es eine Ordnung \u00fcber die Elemente geben (z.B. numerische Ordnungen von Zahlen, lexikografische Ordnungen von Zeichenketten, \u2026). Man unterscheidet zwischen Sortierverfahren, die mit dem gegebenen Speicherplatz der Datenstruktur auskommen und denen, die zus\u00e4tzlichen Platz zum zwischenzeitlichen Auslagern von Elementen ben\u00f6tigen. Prinzipiell ist der paarweise Vergleich aller Elemente notwendig. Es gibt verschiedene Sortierverfahren, die unterschiedliche Aufw\u00e4nde f\u00fcr den besten Fall, den schlechtesten Fall und im Durchschnitt aufweisen. Wir werden im Folgenden verschiedene Sortierverfahren betrachten. Sie m\u00fcssen aber nur eins selbst\u00e4ndig umsetzen k\u00f6nnen! Ich nehme an, das wird f\u00fcr die allermeisten Bubble-Sort sein. </p>"},{"location":"sortieren/#bubble-sort","title":"Bubble-Sort","text":"<p>Bei Bubble-Sort wird das gr\u00f6\u00dfte Element immer nach rechts \"gebubbled\". Das Prinzip bei Bubble-Sort ist wie folgt:</p> <ul> <li>die Datenstruktur (hier: Array) wird von links nach rechts durchlaufen</li> <li>\u201eBubble-Phase\u201c<ul> <li>es wird stets das aktuelle Element mit den rechten Nachbarn verglichen</li> <li>ist die Ordnung falsch, werden die Elemente getauscht</li> <li>am Ende einer Bubble-Phase befindet sich das gr\u00f6\u00dfte Element ganz rechts</li> </ul> </li> <li>Wiederholung der Bubble-Phase<ul> <li>Bubble-Phase wird wiederholt, d.h. es wird wieder vorne im Array angefangen und jedes Element mit seinem rechten Nachbarn verglichen</li> <li>da das ganz rechte Element bereits das gr\u00f6\u00dfte ist, muss es nicht mehr verglichen werden</li> <li>mit jeder Bubble-Phase muss also ein Vergleich weniger durchgef\u00fchrt werden und das jeweils gr\u00f6\u00dfte rutscht nach rechts</li> <li>die Bubble-Phasen werden so oft wiederholt, bis das Array komplett sortiert ist (L\u00e4nge des Arrays-1 Bubble-Phasen)</li> </ul> </li> </ul> <p>Wir betrachten ein Beispiel. Folgendes Array soll sortiert werden:</p> <pre><code>55 07 78 12 42\n</code></pre> <p>Wir starten von links nach rechts und vergleichen die Elemente paarweise:</p> <pre><code>1. Bubble-Phase\n55 07 78 12 42  --&gt; 55 und 07 vergleichen --&gt; es muss getauscht werden\n07 55 78 12 42  --&gt; 55 und 78 vergleichen --&gt; es muss nicht getauscht werden\n07 55 78 12 42  --&gt; 78 und 12 vergleichen --&gt; es muss getauscht werden\n07 55 12 78 42  --&gt; 78 und 42 vergleichen --&gt; es muss getauscht werden\n07 55 12 42 78  --&gt; 1. Bubble-Phase beendet --&gt; die gr\u00f6\u00dfte Zahl 78 steht ganz rechts\n</code></pre> <p>Nach der ersten Bubble-Phase steht die gr\u00f6\u00dfte Zahl aus dem Array ganz rechts. Diese muss nun nicht mehr mitverglichen werden. Bei der 2. Buble-Phase haben wir also einen Vergleich weniger, als bei der ersten.</p> <pre><code>2. Bubble-Phase\n07 55 12 42 78  --&gt; 07 und 55 vergleichen --&gt; es muss nicht getauscht werden\n07 55 12 42 78  --&gt; 55 und 12 vergleichen --&gt; es muss getauscht werden\n07 12 55 42 78  --&gt; 55 und 42 vergleichen --&gt; es muss getauscht werden\n07 12 42 55 78  --&gt; 2. Bubble-Phase beendet --&gt; die zweitgr\u00f6\u00dfte Zahl 55 steht an zweitletzter Stelle\n</code></pre> <p>Mit dem letzten Wert muss also in der 2. Bubble-Phase nicht mehr verglichen werden, da im Ergebnis der ersten Bubble-Phase ja der gr\u00f6\u00dfte Wert nach gaz rechts geschoben wurde. In der dritten Bubble-Phase muss dann auch nicht mehr mit dem vorletzten Wert verglichen werden usw. </p> <pre><code>3. Bubble-Phase\n07 12 42 55 78  --&gt; 07 und 12 vergleichen --&gt; es muss nicht getauscht werden\n07 12 42 55 78  --&gt; 12 und 42 vergleichen --&gt; es muss nicht getauscht werden\n07 12 42 55 78  --&gt; 3. Bubble-Phase beendet --&gt; die drittgr\u00f6\u00dfte Zahl 42 steht an drittletzter Stelle\n</code></pre> <p>Wie wir sehen, ist dieses Array sogar schon nach der 3. Buble-Phase sortiert. Wir werden uns sp\u00e4ter auch \u00fcberlegen, wie wir solche F\u00e4lle ausnutzen k\u00f6nnen, um nicht zwingend alle Bubble-Phasen durchlaufen zu m\u00fcssen, wenn das Array bereits vorzeitig sortiert ist. F\u00fcr ein Array der L\u00e4nge <code>5</code>, so wie hier, brauchen wir aber h\u00e4ufig noch die letzte Bubble-Phase <code>4</code>:</p> <pre><code>4. Bubble-Phase\n07 12 42 55 78  --&gt; 07 und 12 vergleichen --&gt; es muss nicht getauscht werden\n07 12 42 55 78  --&gt; 4. Bubble-Phase beendet --&gt; ein Array der L\u00e4nge 5 ist nach sp\u00e4testens 4 Bubble-Phasen sortiert\n</code></pre> <p>F\u00fcr ein Array der L\u00e4nge <code>n</code> braucht es <code>n-1</code> Bubble-Phasen. Die erste Bubble-Phase besteht aus <code>n-1</code> Vergleichen, die 2. Bubble-Phase besteht aus <code>n-2</code> Vergleichen usw. </p> <p>Wir wollen uns der algorithmischen Idee von Bubble-Sort ann\u00e4hern. Wir wollen eine Methode <code>bubblesort()</code> schreiben, f\u00fcr die folgendes gilt:</p> <ul> <li>Parameter: unsortiertes Array <code>a</code> </li> <li> <p>R\u00fcckgabe: sortiertes Array <code>b</code> </p> </li> <li> <p>Vorgehen:</p> <ul> <li>zuerst <code>a</code> komplett nach <code>b</code> kopieren, um <code>a</code> im Original zu belassen; <code>b</code> ist unsortiert</li> <li> <p>Array <code>b</code> vom ersten bis zum letzten Element durchlaufen und alle benachbarten Elemente <code>b[index]</code> und <code>b[index+1]</code> miteinander vergleichen</p> <ul> <li>wenn <code>b[index] &lt;= b[index+1]</code> \u2794 nichts tun</li> <li>wenn <code>b[index] &gt; b[index+1]</code> \u2794 <code>b[index]</code> und <code>b[index+1]</code> vertauschen</li> </ul> </li> <li> <p>Wenn Array <code>b</code> einmal durchlaufen \u2794 das gr\u00f6\u00dfte Element von <code>b</code> steht an der letzten Stelle (\u2248 letztes Element sortiert)</p> <ul> <li>Verfahren auf Array <code>b</code> vom ersten bis zum vorletzten Element anwenden</li> <li>\u2026 bis alle Elemente in <code>b</code> sortiert</li> </ul> </li> </ul> </li> </ul> <p>Eine m\u00f6gliche Implementierung von Bubble-Sort:</p> <pre><code>for(int bubble=1; bubble&lt;=b.length-1; bubble++)\n{\n    for(int index=0; index&lt;b.length-bubble; index++)\n    {\n        if(b[index] &gt; b[index+1])\n        {\n            int tmp = b[index+1];\n            b[index+1] = b[index];\n            b[index] = tmp;\n        }\n    }\n}\nreturn b;\n</code></pre> <ul> <li>Zeile <code>1</code> zeigt die \u00e4u\u00dfere <code>for</code>-Schleife f\u00fcr die Bubble-Phasen. Es werden <code>length-1</code> viele Bubble-Phasen durchlaufen (Initialisierung von <code>bubble</code> mit <code>1</code> und Bedingung <code>&lt;=</code>).</li> <li>Zeile <code>3</code> zeigt die innere <code>for</code>-Schleife, die in jeder Bubble-Phase durchlaufen wird. Die Anzahl der Durchl\u00e4ufe wird immer kleiner (wegen <code>length - bubble</code> in der Bedingung). Die innere <code>for</code>-Schleife ist f\u00fcr den Vergleich aller Nachbarn.</li> <li>Zeile <code>5</code> zeigt die Bedingung, unter der die Nachbarn tauschen m\u00fcssen. </li> <li>Zeilen <code>7-9</code> zeigt den Tausch der Werte zweier Nachbarn. Wir gehen auf diesen Tausch gleich nochmal ausf\u00fchrlich ein. </li> <li>Wenn die \u00e4u\u00dfere <code>for</code>-Schleife abgearbeitet wurde, also alle Bubble-Phasen durchlaufen wurden, ist das Array <code>b</code> sortiert und kann zur\u00fcckgegeben werden. </li> </ul> Sortieren.java zum Ausprobieren <pre><code>package themen.arrays.sortieren;\n\nimport java.util.Random;\n\npublic class Sortieren\n{\n    /*\n     * aus Skript\n     */\n    public static void printArray(int[] a)\n    {\n        String s = \"[ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + a[index] + \", \";\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + a[a.length-1] + \" ]\";\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * aus Skript\n     */\n    public static int[] createAndFillArray(int length, int bound)\n    {\n        int[] a = new int[length];\n        Random r = new Random();                    \n        for(int i=0; i&lt;a.length; i++)\n        {\n            a[i]=r.nextInt(bound);\n        }\n        return a;\n    }\n\n    public static int[] bubblesort(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = new int[a.length];\n        for (int index = 0; index &lt; b.length; index++)\n        {\n            b[index] = a[index];\n        }\n\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        for(int bubble=1; bubble&lt;=b.length-1; bubble++)\n        {\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                }\n            }\n        }\n        return b;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] unsorted = createAndFillArray(20, 50);\n        int[] sorted = bubblesort(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n    }\n\n}\n</code></pre>"},{"location":"sortieren/#tauschen-der-werte-zweier-nachbarn","title":"Tauschen der Werte zweier Nachbarn","text":"<p>Angenommen, wir haben folgenden Fall, in dem die Werte <code>18</code> und <code>7</code> ihre Positionen tauschen sollen, also die <code>18</code> auf den Index <code>3</code> wechseln soll und die <code>7</code> auf den Index <code>2</code>. </p> <p></p> <p>Was wir nicht machen k\u00f6nnen, ist etwas in der Art:</p> <pre><code>b[2] = b[3];    // b[2]==7 und b[3]==7 - die 18 ist \u00fcberschrieben\nb[3] = b[2];    // b[2]==7 und b[3]==7\n</code></pre> <p>Nach der ersten Anweisung w\u00fcrde sowohl in <code>b[2]</code> als auch in <code>b[3]</code> der Wert <code>7</code> stehen und die <code>18</code> w\u00e4re \"weg\". Wir brauchen eine Variable, auf die wir einen Wert zwischenspeichern k\u00f6nnen.</p> <p></p> <p>Wichtig ist, dass diese Variable vom selben Typ ist, wie alle Werte des Arrays (in diesem Fall <code>int</code>). In dieser Variablen k\u00f6nnen wir uns den Wert aus <code>b[2]</code> zun\u00e4chst (zwischen-)speichern.</p> <p></p> <p>Nun kann der Wert in <code>b[2]</code> problemlos \u00fcberschrieben werden, denn wir haben ihn ja noch in <code>tmp</code> verf\u00fcgbar. </p> <p></p> <p>Nun m\u00fcssen wir nur noch den Wert aus <code>tmp</code> nach <code>b[3]</code> kopieren. </p> <p></p> <p>Die Werte <code>7</code> und <code>18</code> haben im Array ihre Positionen getauscht. Im obigen Beispiel ist dieses Vertauschen in den 3 Zeilen ausgedr\u00fcckt:</p> <pre><code>int tmp = b[index+1];\nb[index+1] = b[index];\nb[index] = tmp;\n</code></pre>"},{"location":"sortieren/#verbesserung-von-bubble-sort","title":"Verbesserung von Bubble-Sort","text":"<p>In dem eingangs gezeigten Beispiel haben wir gesehen, dass manchmal gar nicht alle <code>length-1</code> Bubble-Phasen durchlaufen werden m\u00fcssen, da das Array manchmal schon vorher fertig sortiert ist. Wir wollen unsere Methode dahingehend verbessern, dass dies erkannt wird und dementsprechend die Sortierung gestoppt wird. </p> <p>Woran erkennen wir aber, dass das Array fertig sortiert ist? Die Antwort f\u00fcr den Bubble-Sort-Algorithmus: Wenn in einer Bubble-Phase gar kein Vertauschen mehr stattfindet, dann sind alle linken Nachbarn kleiner als ihre rechten und somit ist das Array fertig sortiert. Das hei\u00dft, wir pr\u00fcfen f\u00fcr eine Bubble-Phase, ob (mindestens) ein Vertauschen stattfand oder nicht. Dazu ben\u00f6tigen wir:</p> <ol> <li>eine Variable <code>swapped</code> vom Typ <code>boolean</code>, die <code>false</code> ist, wenn nicht getauscht wurde und <code>true</code>, wenn getauscht wurde \u2192 initial ist sie aber <code>true</code> (wegen 2.)</li> <li>eine Bedingung in der \u00e4u\u00dferen <code>for</code>-Schleife <code>&amp;&amp; swapped</code>. Neben der Bedingung \u00fcber den <code>bubble</code>-Wert pr\u00fcfen wir nun auch noch, ob <code>swapped</code> <code>true</code> ist. Nur wenn das der Fall ist (wenn getauscht wurde), betreten wir das Innere der Schleife. Wenn nicht getauscht wurde, ist der Wert von <code>swapped``false</code> und die Sortierung wird beendet.</li> <li>eine Anweisung <code>swapped=false;</code> direkt nachdem wir die \u00e4u\u00dfere <code>for</code>-Schleife betreten haben, d.h. eine neue Bubble-Phase angefangen hat. Wir setzen den Wert also erstmal auf <code>false</code> und nur dann, wenn ein Tausch stattfindet, wird er auf <code>true</code> gesetzt. </li> <li>eine Anweisung <code>swapped=true;</code> f\u00fcr den Fall, dass getauscht wird. Wenn die Bedingung <code>b[index] &gt; b[index+1]</code> <code>true</code> ist, dann tauschen die beiden Nachbarn auf den Indizes <code>index</code> und <code>index+1</code> ihre Positionen und also wurde getauscht \u2192 es muss noch (mindestens) eine weitere Bubble-Phase stattfinden.</li> </ol> <p>Die optimierte Bubble-Sortierung sieht dann so aus:</p> <pre><code>boolean swapped = true;\nfor(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n{\n    swapped = false;\n    for(int index=0; index&lt;b.length-bubble; index++)\n    {\n        if(b[index] &gt; b[index+1])\n        {\n            int tmp = b[index+1];\n            b[index+1] = b[index];\n            b[index] = tmp;\n            swapped = true;\n        }\n    }\n}\nreturn b;\n</code></pre> <p>Damit ist die Implementierung von Bubble-Sort vollst\u00e4ndig. So kann sie bleiben und genutzt werden. Wir wollen jetzt nur noch ein paar Ausgaben hinzuf\u00fcgen, die aber einzig und allein dem Verst\u00e4ndnis des Ablaufs der Sortierung mit Bubble-Sort dienen soll. </p> <pre><code>ori---&gt; [ 46, 12, 15, 39, 37, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n\n  1. Bubble-Phase : \n------&gt; [ 46, 12, 15, 39, 37, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  0 --&gt; [ 12, 46, 15, 39, 37, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  1 --&gt; [ 12, 15, 46, 39, 37, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  2 --&gt; [ 12, 15, 39, 46, 37, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  3 --&gt; [ 12, 15, 39, 37, 46, 12, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  4 --&gt; [ 12, 15, 39, 37, 12, 46, 20, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  5 --&gt; [ 12, 15, 39, 37, 12, 20, 46, 37, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  6 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 49, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  8 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 49, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n  9 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41, 49,  6,  2, 36, 49,  3, 14, 26, 24, 31 ]\n 10 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6, 49,  2, 36, 49,  3, 14, 26, 24, 31 ]\n 11 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 49, 36, 49,  3, 14, 26, 24, 31 ]\n 12 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49, 49,  3, 14, 26, 24, 31 ]\n 14 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 49, 14, 26, 24, 31 ]\n 15 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 49, 26, 24, 31 ]\n 16 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 49, 24, 31 ]\n 17 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 49, 31 ]\n 18 --&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n\n  2. Bubble-Phase : \n------&gt; [ 12, 15, 39, 37, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  2 --&gt; [ 12, 15, 37, 39, 12, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  3 --&gt; [ 12, 15, 37, 12, 39, 20, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  4 --&gt; [ 12, 15, 37, 12, 20, 39, 37, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  5 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 46, 38, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  7 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 46, 41,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  8 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41, 46,  6,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n  9 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6, 46,  2, 36, 49,  3, 14, 26, 24, 31, 49 ]\n 10 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 46, 36, 49,  3, 14, 26, 24, 31, 49 ]\n 11 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46, 49,  3, 14, 26, 24, 31, 49 ]\n 13 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 49, 14, 26, 24, 31, 49 ]\n 14 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 49, 26, 24, 31, 49 ]\n 15 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 49, 24, 31, 49 ]\n 16 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 24, 49, 31, 49 ]\n 17 --&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n\n  3. Bubble-Phase : \n------&gt; [ 12, 15, 37, 12, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n  2 --&gt; [ 12, 15, 12, 37, 20, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n  3 --&gt; [ 12, 15, 12, 20, 37, 37, 39, 38, 41,  6,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n  6 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39, 41,  6,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n  8 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6, 41,  2, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n  9 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 41, 36, 46,  3, 14, 26, 24, 31, 49, 49 ]\n 10 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41, 46,  3, 14, 26, 24, 31, 49, 49 ]\n 12 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 46, 14, 26, 24, 31, 49, 49 ]\n 13 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 46, 26, 24, 31, 49, 49 ]\n 14 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 26, 46, 24, 31, 49, 49 ]\n 15 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 26, 24, 46, 31, 49, 49 ]\n 16 --&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n\n  4. Bubble-Phase : \n------&gt; [ 12, 15, 12, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n  1 --&gt; [ 12, 12, 15, 20, 37, 37, 38, 39,  6,  2, 36, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n  7 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6, 39,  2, 36, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n  8 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 39, 36, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n  9 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39, 41,  3, 14, 26, 24, 31, 46, 49, 49 ]\n 11 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 41, 14, 26, 24, 31, 46, 49, 49 ]\n 12 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 14, 41, 26, 24, 31, 46, 49, 49 ]\n 13 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 14, 26, 41, 24, 31, 46, 49, 49 ]\n 14 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 14, 26, 24, 41, 31, 46, 49, 49 ]\n 15 --&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 14, 26, 24, 31, 41, 46, 49, 49 ]\n\n  5. Bubble-Phase : \n------&gt; [ 12, 12, 15, 20, 37, 37, 38,  6,  2, 36, 39,  3, 14, 26, 24, 31, 41, 46, 49, 49 ]\n  6 --&gt; [ 12, 12, 15, 20, 37, 37,  6, 38,  2, 36, 39,  3, 14, 26, 24, 31, 41, 46, 49, 49 ]\n  7 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 38, 36, 39,  3, 14, 26, 24, 31, 41, 46, 49, 49 ]\n  8 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38, 39,  3, 14, 26, 24, 31, 41, 46, 49, 49 ]\n 10 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 39, 14, 26, 24, 31, 41, 46, 49, 49 ]\n 11 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 14, 39, 26, 24, 31, 41, 46, 49, 49 ]\n 12 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 14, 26, 39, 24, 31, 41, 46, 49, 49 ]\n 13 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 14, 26, 24, 39, 31, 41, 46, 49, 49 ]\n 14 --&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n\n  6. Bubble-Phase : \n------&gt; [ 12, 12, 15, 20, 37, 37,  6,  2, 36, 38,  3, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n  5 --&gt; [ 12, 12, 15, 20, 37,  6, 37,  2, 36, 38,  3, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n  6 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 37, 36, 38,  3, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n  7 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37, 38,  3, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n  9 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 38, 14, 26, 24, 31, 39, 41, 46, 49, 49 ]\n 10 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 14, 38, 26, 24, 31, 39, 41, 46, 49, 49 ]\n 11 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 14, 26, 38, 24, 31, 39, 41, 46, 49, 49 ]\n 12 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 14, 26, 24, 38, 31, 39, 41, 46, 49, 49 ]\n 13 --&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n\n  7. Bubble-Phase : \n------&gt; [ 12, 12, 15, 20, 37,  6,  2, 36, 37,  3, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n  4 --&gt; [ 12, 12, 15, 20,  6, 37,  2, 36, 37,  3, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n  5 --&gt; [ 12, 12, 15, 20,  6,  2, 37, 36, 37,  3, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n  6 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37, 37,  3, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n  8 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 37, 14, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n  9 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 14, 37, 26, 24, 31, 38, 39, 41, 46, 49, 49 ]\n 10 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 14, 26, 37, 24, 31, 38, 39, 41, 46, 49, 49 ]\n 11 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 14, 26, 24, 37, 31, 38, 39, 41, 46, 49, 49 ]\n 12 --&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 14, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n\n  8. Bubble-Phase : \n------&gt; [ 12, 12, 15, 20,  6,  2, 36, 37,  3, 14, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n  3 --&gt; [ 12, 12, 15,  6, 20,  2, 36, 37,  3, 14, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n  4 --&gt; [ 12, 12, 15,  6,  2, 20, 36, 37,  3, 14, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n  7 --&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 37, 14, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n  8 --&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 14, 37, 26, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n  9 --&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 14, 26, 37, 24, 31, 37, 38, 39, 41, 46, 49, 49 ]\n 10 --&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 14, 26, 24, 37, 31, 37, 38, 39, 41, 46, 49, 49 ]\n 11 --&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 14, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n  9. Bubble-Phase : \n------&gt; [ 12, 12, 15,  6,  2, 20, 36,  3, 14, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  2 --&gt; [ 12, 12,  6, 15,  2, 20, 36,  3, 14, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  3 --&gt; [ 12, 12,  6,  2, 15, 20, 36,  3, 14, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  6 --&gt; [ 12, 12,  6,  2, 15, 20,  3, 36, 14, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  7 --&gt; [ 12, 12,  6,  2, 15, 20,  3, 14, 36, 26, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  8 --&gt; [ 12, 12,  6,  2, 15, 20,  3, 14, 26, 36, 24, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  9 --&gt; [ 12, 12,  6,  2, 15, 20,  3, 14, 26, 24, 36, 31, 37, 37, 38, 39, 41, 46, 49, 49 ]\n 10 --&gt; [ 12, 12,  6,  2, 15, 20,  3, 14, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 10. Bubble-Phase : \n------&gt; [ 12, 12,  6,  2, 15, 20,  3, 14, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  1 --&gt; [ 12,  6, 12,  2, 15, 20,  3, 14, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  2 --&gt; [ 12,  6,  2, 12, 15, 20,  3, 14, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  5 --&gt; [ 12,  6,  2, 12, 15,  3, 20, 14, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  6 --&gt; [ 12,  6,  2, 12, 15,  3, 14, 20, 26, 24, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  8 --&gt; [ 12,  6,  2, 12, 15,  3, 14, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 11. Bubble-Phase : \n------&gt; [ 12,  6,  2, 12, 15,  3, 14, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  0 --&gt; [  6, 12,  2, 12, 15,  3, 14, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  1 --&gt; [  6,  2, 12, 12, 15,  3, 14, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  4 --&gt; [  6,  2, 12, 12,  3, 15, 14, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  5 --&gt; [  6,  2, 12, 12,  3, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 12. Bubble-Phase : \n------&gt; [  6,  2, 12, 12,  3, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  0 --&gt; [  2,  6, 12, 12,  3, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  3 --&gt; [  2,  6, 12,  3, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 13. Bubble-Phase : \n------&gt; [  2,  6, 12,  3, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  2 --&gt; [  2,  6,  3, 12, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 14. Bubble-Phase : \n------&gt; [  2,  6,  3, 12, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n  1 --&gt; [  2,  3,  6, 12, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n\n 15. Bubble-Phase : \n------&gt; [  2,  3,  6, 12, 12, 14, 15, 20, 24, 26, 31, 36, 37, 37, 38, 39, 41, 46, 49, 49 ]\n</code></pre> <p>Wir sehen, wie sich von oben nach unten der sortierte Bereich von rechts nach links vergr\u00f6\u00dfert. Es werden immer nur die Zeilen mit ihren jeweiligen Indizes (die ganz linke Zahl am Anfang der Zeile) ausgegeben, in denen Nachbarn getauscht werden. In diesem Beispiel wird bereits in der 15. Bubble-Phase nichts mehr getauscht. Da das Array die L\u00e4nge <code>20</code> hat, g\u00e4be es eigentlich <code>19</code> Bubble-Phasen. </p> Der Code, der f\u00fcr die obige Ausgabe verwendet wurde <pre><code>package themen.arrays.sortieren;\n\nimport java.util.Random;\n\npublic class Sortieren\n{\n    /*\n     * aus Skript\n     */\n    public static void printArray(int[] a)\n    {\n        String s = \"[ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + a[index] + \", \";\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + a[a.length-1] + \" ]\";\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * angepasste printArray-Methode\n     * hier wird davon ausgegangen, dass die Zahlen\n     * in dem Array nie gr\u00f6\u00dfer als zweistellig sind\n     * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser\n     * miteinander verglichen werden k\u00f6nnen auf der Konsole\n     * \n     */\n    public static void print(int[] a)\n    {\n        String s = \"--&gt; [ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + String.format(\"%2d, \", a[index]);\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + String.format(\"%2d ]\", a[a.length-1]);\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * aus Skript\n     */\n    public static int[] createAndFillArray(int length, int bound)\n    {\n        int[] a = new int[length];\n        Random r = new Random();                    \n        for(int i=0; i&lt;a.length; i++)\n        {\n            a[i]=r.nextInt(bound);\n        }\n        return a;\n    }\n\n    public static int[] bubblesort(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = new int[a.length];\n        for (int index = 0; index &lt; b.length; index++)\n        {\n            b[index] = a[index];\n        }\n        System.out.print(\"ori-\");\n        print(b);       // Ausgangs-Array\n        System.out.println();\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        boolean swapped = true;\n        for(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n        {\n            System.out.printf(\"%3d. Bubble-Phase : %n----\", bubble);\n            print(b);\n            swapped = false;\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                    swapped = true;\n                    System.out.printf(\"%3d \", index);\n                    print(b);\n                }\n            }\n            System.out.println();\n        }\n        return b;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] unsorted = createAndFillArray(20, 50);\n        int[] sorted = bubblesort(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n    }\n\n}\n</code></pre> <p>Noch kurz ein Wort zur Komplexit\u00e4t von Bubble-Sort. Wenn <code>n</code> die L\u00e4nge des Arrays ist, dann finden in der ersten Bubble-Phase <code>n-1</code> Vergleiche statt, in der zweiten Bubble-Phase <code>n-2</code> Vergleiche usw. Es gibt maximal <code>n-1</code> Bubble-Phasen, also <code>(n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1</code> Vergleiche. Das sind <code>n*(n-1)/2</code> Vergleiche und maximal ebenso viele Vertauschungen. Das ergibt Vergleiche + Vertauschungen = <code>n*(n-1)</code> Operationen. Das entspricht einer (Zeit-)Komplexit\u00e4t von <code>O(n^2)</code>. </p> <p>Success</p> <p>Wir haben einen Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Beachten Sie, dass das nicht nur f\u00fcr <code>int</code>-Arrays m\u00f6glich ist, sondern f\u00fcr alle Datentypen, \u00fcber die sich eine Ordnung definieren l\u00e4sst. Wir werden jetzt noch weitere Sortieralgorithmen betrachten, aber nur aus Interesse. Den Bubble-Sort-Algorithmus sollten Sie aus dem Kopf beherrschen, also programmieren k\u00f6nnen. Alle weiteren Sortieralgorithmen sollten Sie \"nur\" verstehen. </p>"},{"location":"sortieren/#selection-sort","title":"Selection-Sort","text":"<p>Die Idee des Selection-Sort-Algorithmus ist die, dass bei jedem Durchlauf durch das Array das jeweils kleinste (oder gr\u00f6\u00dfte - je, nachdem, wie man sortieren m\u00f6chte) ausgew\u00e4hlt und an seine richtige Position im Array sortiert wird. Wir betrachten erneut unser Beispiel:</p> <pre><code>55 07 78 12 42\n</code></pre> <p>Erster Durchlauf:</p> <ul> <li>Im ersten Schritt suchen wir das kleinste Element im Array und wollen es ganz links (auf den Index <code>0</code>) legen</li> <li>die <code>7</code> ist das kleinste Element, also muss es seine Poition mit der <code>55</code> tauschen</li> </ul> <p>Nach dem ersten Schritt:</p> <pre><code>07 55 78 12 42\n</code></pre> <p>Zweiter Durchlauf: </p> <ul> <li>Jetzt steht das kleinste Element ganz links \u2192 es muss nicht mehr betrachtet werden</li> <li>wir suchen jetzt das zweitkleinste Element, um es auf den Index <code>1</code> zu legen</li> <li>die <code>12</code> ist das zweitkleinste Element, also muss es seine Position mit der <code>55</code> tauschen</li> </ul> <p>Nach dem zweiten Schritt:</p> <pre><code>07 12 78 55 42\n</code></pre> <p>Dritter Durchlauf: </p> <ul> <li>Jetzt stehen die 2 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden</li> <li>wir suchen jetzt das drittkleinste Element, um es auf den Index <code>2</code> zu legen</li> <li>die <code>42</code> ist das drittkleinste Element, also muss es seine Position mit der <code>78</code> tauschen</li> </ul> <p>Nach dem dritten Schritt:</p> <pre><code>07 12 42 55 78\n</code></pre> <p>Vierter Durchlauf: </p> <ul> <li>Jetzt stehen die 3 kleinsten Element ganz links \u2192 sie m\u00fcssen nicht mehr betrachtet werden</li> <li>wir suchen jetzt das viertkleinste Element, um es auf den Index <code>3</code> zu legen</li> <li>die <code>55</code> ist das viertkleinste Element, es ist bereits auf der richtigen Position \u2192 wir m\u00fcssen also nicht (mehr) tauschen</li> </ul> <p>Ein Array der L\u00e4nge <code>5</code> ist nach <code>4</code> Durchl\u00e4ufen sortiert. Generell gilt auch hier wieder, dass ein Array der L\u00e4nge <code>n</code> nach sp\u00e4testens <code>n-1</code> Durchl\u00e4ufen (das waren In Bubble-Sort die Bubble-Phasen) sortiert ist. </p> <p>W\u00e4hrend bei Bubble-Sort der sortierte Teil des Arrays von rechts anwuchs (von gro\u00df nach klein), w\u00e4chst bei Selection-Sort der sortierte Teil des Arrays von links an (von klein nach gro\u00df). Auch hier gilt wieder, dass immer nur der unsortierte Teil erneut durchsucht werden muss. Auch hier finden wieder paarweise Vergleiche mit allen unsortierten Elementen statt. Dieses Mal sind es aber nicht die Nachbarn, die verglichen und evtl. getauscht werden m\u00fcssen, sondern es wird im unsortierten (rechten) Teil nach dem kleinsten Element gesucht. </p> <p>Hier noch ein Bild, das den Selection-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: </p> <p></p> <p>Wir wollen uns der algorithmischen Idee von Selection-Sort ann\u00e4hern. Wir wollen eine Methode <code>selectionsort()</code> schreiben, f\u00fcr die folgendes gilt:</p> <ul> <li>Parameter: unsortiertes Array <code>a</code> </li> <li> <p>R\u00fcckgabe: sortiertes Array <code>b</code> </p> </li> <li> <p>Vorgehen:</p> <ul> <li>gedachte Teilung des Arrays in 2 Teile: <ul> <li>linker Teil: sortiert  </li> <li>rechter Teil: unsortiert</li> <li>\u2794 anfangs: linker Teil leer d.h. Array unsortiert</li> </ul> </li> <li>rechten unsortierten Teil <code>b[j]</code>,\u2026,<code>b[n-1]</code> betrachten (<code>n</code> ist L\u00e4nge des Arrays)<ul> <li>das kleinste Element (Minimum) im rechten Teil suchen</li> <li>mit dem ersten Element <code>b[j]</code> im rechten Teil vertauschen </li> <li>\u2794 rechter unsortierter Teil des Array <code>b[j+1]</code>,\u2026,<code>b[n-1]</code> um ein Element kleiner, linker sortierter Teil w\u00e4chst um ein Element <code>b[j]</code></li> </ul> </li> <li>so verfahren, bis rechter Teil nur ein Element <code>b[n-1]</code> enth\u00e4lt</li> </ul> </li> </ul> <p>Eine m\u00f6gliche Implementierung von Selection-Sort:</p> <pre><code>public static int[] selectionsort(int[] a)\n{\n    int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n    for (int durchlauf = 0; durchlauf &lt; b.length; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n    {\n        int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n        int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n        for (int index = durchlauf; index &lt; b.length; index++)  // Suche nach dem kleinsten Wert\n        {\n            if(minValue &gt; b[index])\n            {\n                minValue = b[index];    // aktuell kleinster Wert\n                minIndex = index;       // aktueller Index des kleinsten Wertes\n            }\n        }\n        // jetzt den kleinsten Wert auf den Index durchlauf legen\n        // der Wert, der auf durchlauf lag, kommt nach minIndex\n        int tmp = b[durchlauf];\n        b[durchlauf] = b[minIndex];\n        b[minIndex] = tmp;\n    }\n    return b;\n}\n</code></pre> <ul> <li>Zeile <code>5</code> zeigt die \u00e4u\u00dfere <code>for</code>-Schleife f\u00fcr die Durchl\u00e4ufe. Es werden <code>length-1</code> viele Phasen durchlaufen.</li> <li>in Zeile <code>7</code> wird die Variable deklariert, in der wir uns den kleinsten Wert des rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Wert im unsortierten Teil. Der unsortierte Teil beginnt beim Index <code>durchlauf</code>.</li> <li>in Zeile <code>8</code> wird die Variable deklariert, in der wir uns den Index des kleinsten Wertes im rechten (unsortierten) Teils merken. Wir initialisieren die Variable mit dem ersten Index im unsortierten Teil - dies ist <code>durchlauf</code>. </li> <li>in den Zeilen <code>19-21</code> tauschen wir die Werte. Der kleinste Wert kommt auf den Index <code>durchlauf</code> und der Wert, der auf dem Index <code>durchlauf</code> stand, kommt nach <code>minIndex</code></li> <li>Wenn die \u00e4u\u00dfere <code>for</code>-Schleife abgearbeitet wurde, also alle <code>length-1</code> Phasen durchlaufen wurden, ist das Array <code>b</code> sortiert und kann zur\u00fcckgegeben werden. </li> </ul> <p>Die <code>copy()</code>-Methode, die in Zeile <code>3</code> verwendet wurde, sieht so aus:</p> <pre><code>public static int[] copy(int[] a)\n{\n    int[] b = new int[a.length];\n    for (int index = 0; index &lt; b.length; index++)\n    {\n        b[index] = a[index];\n    }\n    return b;\n}\n</code></pre> <p>Wir werden jetzt die Implementierung des Selection-Sort-Algorithmus um einige Ausgaben erweitern, damit das Prinzip noch deutlicher wird (wie bei Bubble-Sort). Die Ausgaben haben in der Methode nat\u00fcrlich eigentlich nichts zu suchen - es ist hier nur zur n\u00e4heren Information:</p> <pre><code>  original -------&gt; [ 38, 22, 18,  6, 15, 12,  9,  1, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n\n  1. Durchlauf - kleinstes Element soll auf den index  0 \n----&gt; kleinster Wert ist   1 auf dem Index   7 \n  vor Tausch  : --&gt; [ 38, 22, 18,  6, 15, 12,  9,  1, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1, 22, 18,  6, 15, 12,  9, 38, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n\n  2. Durchlauf - kleinstes Element soll auf den index  1 \n----&gt; kleinster Wert ist   5 auf dem Index   9 \n  vor Tausch  : --&gt; [  1, 22, 18,  6, 15, 12,  9, 38, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5, 18,  6, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n\n  3. Durchlauf - kleinstes Element soll auf den index  2 \n----&gt; kleinster Wert ist   6 auf dem Index   3 \n  vor Tausch  : --&gt; [  1,  5, 18,  6, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6, 18, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n\n  4. Durchlauf - kleinstes Element soll auf den index  3 \n----&gt; kleinster Wert ist   9 auf dem Index   6 \n  vor Tausch  : --&gt; [  1,  5,  6, 18, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 15, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n\n  5. Durchlauf - kleinstes Element soll auf den index  4 \n----&gt; kleinster Wert ist  10 auf dem Index  17 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 15, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 15, 31, 49 ]\n\n  6. Durchlauf - kleinstes Element soll auf den index  5 \n----&gt; kleinster Wert ist  11 auf dem Index  14 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 18, 38, 14, 22, 22, 49, 31, 19, 12, 24, 30, 15, 31, 49 ]\n\n  7. Durchlauf - kleinstes Element soll auf den index  6 \n----&gt; kleinster Wert ist  12 auf dem Index  14 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 18, 38, 14, 22, 22, 49, 31, 19, 12, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 38, 14, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n\n  8. Durchlauf - kleinstes Element soll auf den index  7 \n----&gt; kleinster Wert ist  14 auf dem Index   8 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 38, 14, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 38, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n\n  9. Durchlauf - kleinstes Element soll auf den index  8 \n----&gt; kleinster Wert ist  15 auf dem Index  17 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 38, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 22, 22, 49, 31, 19, 18, 24, 30, 38, 31, 49 ]\n\n 10. Durchlauf - kleinstes Element soll auf den index  9 \n----&gt; kleinster Wert ist  18 auf dem Index  14 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 22, 22, 49, 31, 19, 18, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 22, 49, 31, 19, 22, 24, 30, 38, 31, 49 ]\n\n 11. Durchlauf - kleinstes Element soll auf den index 10 \n----&gt; kleinster Wert ist  19 auf dem Index  13 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 22, 49, 31, 19, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 49, 31, 22, 22, 24, 30, 38, 31, 49 ]\n\n 12. Durchlauf - kleinstes Element soll auf den index 11 \n----&gt; kleinster Wert ist  22 auf dem Index  13 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 49, 31, 22, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 31, 49, 22, 24, 30, 38, 31, 49 ]\n\n 13. Durchlauf - kleinstes Element soll auf den index 12 \n----&gt; kleinster Wert ist  22 auf dem Index  14 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 31, 49, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 49, 31, 24, 30, 38, 31, 49 ]\n\n 14. Durchlauf - kleinstes Element soll auf den index 13 \n----&gt; kleinster Wert ist  24 auf dem Index  15 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 49, 31, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 31, 49, 30, 38, 31, 49 ]\n\n 15. Durchlauf - kleinstes Element soll auf den index 14 \n----&gt; kleinster Wert ist  30 auf dem Index  16 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 31, 49, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 49, 31, 38, 31, 49 ]\n\n 16. Durchlauf - kleinstes Element soll auf den index 15 \n----&gt; kleinster Wert ist  31 auf dem Index  16 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 49, 31, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 49, 38, 31, 49 ]\n\n 17. Durchlauf - kleinstes Element soll auf den index 16 \n----&gt; kleinster Wert ist  31 auf dem Index  18 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 49, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n\n 18. Durchlauf - kleinstes Element soll auf den index 17 \n----&gt; kleinster Wert ist  38 auf dem Index  17 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n\n 19. Durchlauf - kleinstes Element soll auf den index 18 \n----&gt; kleinster Wert ist  49 auf dem Index  18 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n\n 20. Durchlauf - kleinstes Element soll auf den index 19 \n----&gt; kleinster Wert ist  49 auf dem Index  19 \n  vor Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n</code></pre> <p>Wenn wir nur alle Zeilen nach dem Tausch betrachten, dann sehen wir die Entwicklung der Sortierung von links nach rechts:</p> <pre><code>  original -------&gt; [ 38, 22, 18,  6, 15, 12,  9,  1, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1, 22, 18,  6, 15, 12,  9, 38, 14,  5, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5, 18,  6, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6, 18, 15, 12,  9, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 15, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 10, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 12, 18, 38, 14, 22, 22, 49, 31, 19, 11, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 18, 38, 14, 22, 22, 49, 31, 19, 12, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 38, 14, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 38, 22, 22, 49, 31, 19, 18, 24, 30, 15, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 22, 22, 49, 31, 19, 18, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 22, 49, 31, 19, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 49, 31, 22, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 31, 49, 22, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 49, 31, 24, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 31, 49, 30, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 49, 31, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 49, 38, 31, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n nach Tausch  : --&gt; [  1,  5,  6,  9, 10, 11, 12, 14, 15, 18, 19, 22, 22, 24, 30, 31, 31, 38, 49, 49 ]\n</code></pre>"},{"location":"sortieren/#verbesserung-von-selection-sort","title":"Verbesserung von Selection-Sort","text":"<p>In dem obigen Beispiel sehen wir, dass die letzten drei Durchl\u00e4ufe gar nicht mehr notwendig waren, da das Array dann bereits vollst\u00e4ndig sortiert war. Beim Selection-Sort-Algorithmus ist es jedoch gar nicht leicht, diesen Zustand zu erkennen. Stattdessen k\u00f6nnten wir aber folgende Optimierung vornehmen:</p> <ul> <li>wir suchen in einem Durchlauf nicht nur das kleinste Element und tauschen dieses nach links, </li> <li>sondern wir suchen gleichzeitig nach dem gr\u00f6\u00dften Element und tauschen dieses nach rechts</li> <li>dann entstehen drei Teile in unserem Array:<ul> <li>ein linker, sortierter Teil,</li> <li>ein rechter, sortierter Teil und</li> <li>ein mittlerer, unsortierter Teil</li> </ul> </li> </ul> <p>Die Anzahl der Durchl\u00e4ufe halbiert sich damit! Hier eine m\u00f6gliche Implementierung des optimieretn Selection-Sort-Algorithmus:</p> <pre><code>public static int[] selectionsortOptimiert(int[] a)\n{\n    int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n    for (int durchlauf = 0; durchlauf &lt; b.length/2+1; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n    {\n        int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n        int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n        int maxValue = b[b.length-1-durchlauf]; // in maxValue merken wir uns den aktuell groessten Wert\n        int maxIndex = b.length-1-durchlauf;        // in maxIndex merken wir uns den Index des aktuell groessten Wertes\n\n        for (int index = durchlauf; index &lt; b.length-durchlauf; index++)    // Suche nach dem kleinsten UND groessten Wert\n        {\n            if(minValue &gt; b[index])\n            {\n                minValue = b[index];    // aktuell kleinster Wert\n                minIndex = index;       // aktueller Index des kleinsten Wertes\n            }\n            if(maxValue &lt; b[index])\n            {\n                maxValue = b[index];    // aktuell groesster Wert\n                maxIndex = index;       // aktueller Index des groessten Wertes\n            }\n        }\n        /* \n         * jetzt den kleinsten Wert auf den Index durchlauf legen\n         * der Wert, der auf durchlauf lag, kommt nach minIndex\n         * UND den groessten Wert auf den Index b.length-1-durchlauf legen\n         * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex\n         * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu\n         * Konflikten beim Tauschen kommen!\n         * \n         */\n        int tmpMin = b[durchlauf];\n        int tmpMax = b[b.length-1-durchlauf];\n        b[durchlauf] = minValue;\n        b[minIndex] = tmpMin;\n        /*\n         * hier wird es sehr kompliziert\n         * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), \n         * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren\n         * es sind jetzt nur noch 3 Werte im Spiel\n         * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue!\n         * der alte Wert von length-1-durchlauf - ist in tmpMax\n         * der alte Wert von minIndex ist minValue und jetzt auf durchlauf\n         * Versuchen Sie es mal ohne die Bedingung und nur\n         *  b[b.length-1-durchlauf] = maxValue;\n         *  b[maxIndex] = tmpMax;\n         * dann sehen Sie den Fehler\n         */\n        if(maxIndex == durchlauf)\n        {\n            b[b.length-1-durchlauf] = b[minIndex];\n            b[minIndex] = tmpMax;\n        }\n        else\n        {\n            b[b.length-1-durchlauf] = maxValue;\n            b[maxIndex] = tmpMax;\n        }   \n\n    }\n    return b;\n}\n</code></pre> <p>Die Entwicklung eines Arrays mit Zufallszahlen sieht f\u00fcr den optimierten Selection-Sort-Algorithmus z.B. so aus:</p> <pre><code>--&gt; [  8,  6,  7, 49,  3,  7, 17, 40, 48, 37, 37, 49, 30, 34, 15, 34,  9, 38,  7, 32 ]      // Ausgangs-Array\n\n--&gt; [  3,  6,  7, 32,  8,  7, 17, 40, 48, 37, 37, 49, 30, 34, 15, 34,  9, 38,  7, 49 ]      // Durchlauf 1\n--&gt; [  3,  6,  7, 32,  8,  7, 17, 40, 48, 37, 37,  7, 30, 34, 15, 34,  9, 38, 49, 49 ]      // Durchlauf 2\n--&gt; [  3,  6,  7, 32,  8,  7, 17, 40, 38, 37, 37,  7, 30, 34, 15, 34,  9, 48, 49, 49 ]      // Durchlauf 3\n--&gt; [  3,  6,  7,  7,  8, 32, 17,  9, 38, 37, 37,  7, 30, 34, 15, 34, 40, 48, 49, 49 ]      // Durchlauf 4\n--&gt; [  3,  6,  7,  7,  7, 32, 17,  9, 34, 37, 37,  8, 30, 34, 15, 38, 40, 48, 49, 49 ]      // Durchlauf 5\n--&gt; [  3,  6,  7,  7,  7,  8, 17,  9, 34, 15, 37, 32, 30, 34, 37, 38, 40, 48, 49, 49 ]      // Durchlauf 6\n--&gt; [  3,  6,  7,  7,  7,  8,  9, 17, 34, 15, 34, 32, 30, 37, 37, 38, 40, 48, 49, 49 ]      // Durchlauf 7\n--&gt; [  3,  6,  7,  7,  7,  8,  9, 15, 30, 17, 34, 32, 34, 37, 37, 38, 40, 48, 49, 49 ]      // Durchlauf 8\n--&gt; [  3,  6,  7,  7,  7,  8,  9, 15, 17, 30, 32, 34, 34, 37, 37, 38, 40, 48, 49, 49 ]      // Durchlauf 9\n--&gt; [  3,  6,  7,  7,  7,  8,  9, 15, 17, 30, 32, 34, 34, 37, 37, 38, 40, 48, 49, 49 ]      // Durchlauf 10\n</code></pre> <p>Man sieht, dass sich nun die sortierten Teile sowohl von links als auch von rechts ann\u00e4hern und der mittlere, unsortierte Teil immer kleiner wird. </p> <p>Die Komplexit\u00e4t des Selection-Sort-Algorithmus ist die gleiche, wie bei Bubble-Sort. Wir ben\u00f6tigen im ersten Durchlauf <code>n-1</code> Vergleiche, um das Minimum zu bestimmen, im zweiten Durchlauf <code>n-2</code> usw. Insgesamt also wieder <code>n*(n-1)/2</code> Vergleiche. Dazu kommen <code>n-1</code> Vertauschungen. Das macht insgesamt <code>n^2/2 + n/2 + n - 1</code> Operationen und ergibt somit eine Zeitkomplexit\u00e4t von <code>O(n^2)</code>.</p> Aktueller Stand der Klasse <code>Sortieren.java</code> <pre><code>package themen.arrays.sortieren;\n\nimport java.util.Random;\n\npublic class Sortieren\n{\n    /*\n     * aus Skript\n     */\n    public static void printArray(int[] a)\n    {\n        String s = \"[ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + a[index] + \", \";\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + a[a.length-1] + \" ]\";\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * angepasste printArray-Methode\n     * hier wird davon ausgegangen, dass die Zahlen\n     * in dem Array nie gr\u00f6\u00dfer als zweistellig sind\n     * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser\n     * miteinander verglichen werden k\u00f6nnen auf der Konsole\n     * \n     */\n    public static void print(int[] a)\n    {\n        String s = \"--&gt; [ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + String.format(\"%2d, \", a[index]);\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + String.format(\"%2d ]\", a[a.length-1]);\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * aus Skript\n     */\n    public static int[] createAndFillArray(int length, int bound)\n    {\n        int[] a = new int[length];\n        Random r = new Random();                    \n        for(int i=0; i&lt;a.length; i++)\n        {\n            a[i]=r.nextInt(bound);\n        }\n        return a;\n    }\n\n    public static int[] copy(int[] a)\n    {\n        int[] b = new int[a.length];\n        for (int index = 0; index &lt; b.length; index++)\n        {\n            b[index] = a[index];\n        }\n        return b;\n    }\n\n    public static int[] bubblesortDebug(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = copy(a);\n\n        System.out.print(\"ori-\");\n        print(b);       // Ausgangs-Array\n        System.out.println();\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        boolean swapped = true;\n        for(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n        {\n            System.out.printf(\"%3d. Bubble-Phase : %n----\", bubble);\n            print(b);\n            swapped = false;\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                    swapped = true;\n                    System.out.printf(\"%3d \", index);\n                    print(b);\n                }\n            }\n            System.out.println();\n        }\n        return b;\n    }\n\n\n    public static int[] bubblesort(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = copy(a);\n\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        boolean swapped = true;\n        for(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n        {\n            swapped = false;\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                    swapped = true;\n                }\n            }\n        }\n        return b;\n    }\n\n    public static int[] selectionsortDebug(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n        System.out.print(\"  original -----\");\n        print(b);       // Ausgangs-Array\n        System.out.println();\n\n        for (int durchlauf = 0; durchlauf &lt; b.length; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n        {\n            System.out.printf(\"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----&gt; \", durchlauf+1, durchlauf);\n            int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n            int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n            for (int index = durchlauf; index &lt; b.length; index++)  // Suche nach dem kleinsten Wert\n            {\n                if(minValue &gt; b[index])\n                {\n                    minValue = b[index];    // aktuell kleinster Wert\n                    minIndex = index;       // aktueller Index des kleinsten Wertes\n                }\n            }\n            System.out.printf(\"kleinster Wert ist %3d auf dem Index %3d %n\", minValue, minIndex);\n            System.out.printf(\"%13s : \", \"vor Tausch \"); print(b);\n            // jetzt den kleinsten Wert auf den Index durchlauf legen\n            // der Wert, der auf durchlauf lag, kommt nach minIndex\n            int tmp = b[durchlauf];\n            b[durchlauf] = b[minIndex];\n            b[minIndex] = tmp;\n            System.out.printf(\"%13s : \", \"nach Tausch \"); print(b);\n            System.out.println();\n        }\n        return b;\n    }\n\n\n    public static int[] selectionsort(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n        for (int durchlauf = 0; durchlauf &lt; b.length; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n        {\n            int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n            int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n            for (int index = durchlauf; index &lt; b.length; index++)  // Suche nach dem kleinsten Wert\n            {\n                if(minValue &gt; b[index])\n                {\n                    minValue = b[index];    // aktuell kleinster Wert\n                    minIndex = index;       // aktueller Index des kleinsten Wertes\n                }\n            }\n            // jetzt den kleinsten Wert auf den Index durchlauf legen\n            // der Wert, der auf durchlauf lag, kommt nach minIndex\n            int tmp = b[durchlauf];\n            b[durchlauf] = b[minIndex];\n            b[minIndex] = tmp;\n        }\n        return b;\n    }\n\n\n    public static int[] selectionsortOptimiert(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n        System.out.print(\"                    \");print(b);      // Ausgangs-Array\n\n        for (int durchlauf = 0; durchlauf &lt; b.length/2; durchlauf++)    // durchlauf ist in Vorgehen j (siehe oben)\n        {\n            int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n            int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n            int maxValue = b[b.length-1-durchlauf]; // in maxValue merken wir uns den aktuell groessten Wert\n            int maxIndex = b.length-1-durchlauf;        // in maxIndex merken wir uns den Index des aktuell groessten Wertes\n            System.out.printf(\"%3d %3d %3d %3d %3d %n\", durchlauf, minValue, minIndex, maxValue, maxIndex);\n            for (int index = durchlauf; index &lt; b.length-durchlauf; index++)    // Suche nach dem kleinsten UND groessten Wert\n            {\n                if(minValue &gt; b[index])\n                {\n                    minValue = b[index];    // aktuell kleinster Wert\n                    minIndex = index;       // aktueller Index des kleinsten Wertes\n                }\n                if(maxValue &lt; b[index])\n                {\n                    maxValue = b[index];    // aktuell groesster Wert\n                    maxIndex = index;       // aktueller Index des groessten Wertes\n                }\n            }\n            /* \n             * jetzt den kleinsten Wert auf den Index durchlauf legen\n             * der Wert, der auf durchlauf lag, kommt nach minIndex\n             * UND den groessten Wert auf den Index b.length-1-durchlauf legen\n             * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex\n             * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu\n             * Konflikten beim Tauschen kommen!\n             * \n             */\n            System.out.printf(\"%3d %3d %3d %3d %3d \", durchlauf, minValue, minIndex, maxValue, maxIndex);\n            int tmpMin = b[durchlauf];\n            int tmpMax = b[b.length-1-durchlauf];\n            b[durchlauf] = minValue;\n            b[minIndex] = tmpMin;\n            /*\n             * hier wird es sehr kompliziert\n             * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), \n             * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren\n             * es sind jetzt nur noch 3 Werte im Spiel\n             * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue!\n             * der alte Wert von length-1-durchlauf - ist in tmpMax\n             * der alte Wert von minIndex ist minValue und jetzt auf durchlauf\n             * Versuchen Sie es mal ohne die Bedingung und nur\n             *  b[b.length-1-durchlauf] = maxValue;\n             *  b[maxIndex] = tmpMax;\n             * dann sehen Sie den Fehler\n             */\n            if(maxIndex == durchlauf)\n            {\n                b[b.length-1-durchlauf] = b[minIndex];\n                b[minIndex] = tmpMax;\n            }\n            else\n            {\n                b[b.length-1-durchlauf] = maxValue;\n                b[maxIndex] = tmpMax;\n            }   \n\n            print(b);\n        }\n        return b;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] unsorted = createAndFillArray(21, 50);\n\n        System.out.printf(\"%n%n--------------- bubblesort ----------------------%n%n\");\n        int[] sorted = bubblesort(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n\n        System.out.printf(\"%n%n--------------- selection ----------------------%n%n\");\n        int[] us = { 1, 12, 41, 35, 49,  2, 28, 38, 21, 35, 41, 12, 21, 29, 27, 17,  5,  6, 18,  3 };\n        sorted = selectionsortOptimiert(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n    }\n\n}\n</code></pre> <p>Success</p> <p>Wir haben einen zweiten Sortieralgorithmus kennengelernt, mit dem wir Arrays sortieren k\u00f6nnen. Das Grundprinzip hier ist, in jedem Durchgang das Minimum des unsortierten Teils des Arrays zu suchen und dieses an den Anfang des unsortierten Teils zu bewegen. Der Grundalgorithmus des Selection-Sort ist dadurch nicht sehr kompliziert. Die Optimierung von Selection-Sort, n\u00e4mlich nicht nur das Minimum, sondern auch das Maximum in einem Durchlauf zu bestimmen, ist jedoch aufgrund des recht komplizierten \"Vertauschens\" der Werte bereits sehr schwer zu verstehen. Aber, wie gesagt, es gen\u00fcgt ja auch, wenn Sie Bubble-Sort vollst\u00e4ndig verstanden haben. </p>"},{"location":"sortieren/#insertion-sort","title":"Insertion-Sort","text":"<p>Dieser Sortier-Algorithmus (auch h\u00e4ufig Insert-Sort genannt) basiert auf einer Idee, die immer mit der Aufnahme eines Kartenspiels verglichen wird. Man nimmt eine Karte auf, steckt sie an die richtige Position, nimmt die n\u00e4chste Karte auf, steckt sie wieder an die richtige Position usw. Wir betrachten zun\u00e4chst erneut unser Beispiel:</p> <pre><code>55 07 78 12 42\n</code></pre> <ul> <li>wir beginnen mit dem Index <code>1</code>(nicht mit <code>0</code> - die erste \"Karte\", die <code>55</code> haben wir bereits \"auf der Hand\")</li> <li>die <code>7</code> ist kleiner als die <code>55</code>, deshalb \"stecken\" wir die <code>7</code> vor die <code>55</code>:</li> </ul> <pre><code>07 55 78 12 42\n</code></pre> <ul> <li>jetzt sind die ersten beiden Elemente sortiert</li> <li>wir setzen mit dem Index <code>2</code> fort</li> <li>die <code>78</code> ist gr\u00f6\u00dfer als die <code>7</code> und gr\u00f6\u00dfer als die <code>55</code>, deshalb lassen wir die <code>78</code> dort, wo sie ist</li> </ul> <pre><code>07 55 78 12 42\n</code></pre> <ul> <li>jetzt sind die ersten drei Elemente sortiert</li> <li>wir setzen mit dem Index <code>3</code> fort</li> <li>die <code>12</code> ist gr\u00f6\u00dfer als die <code>7</code>, aber kleiner als die <code>55</code>, deshalb \"stecken\" wir die <code>12</code> zwischen die <code>7</code> und die <code>55</code></li> <li>die bereits sortierten Werte <code>55</code> und <code>78</code> \"rutschen\" um eins nach rechts</li> </ul> <pre><code>07 12 55 78 42\n</code></pre> <ul> <li>jetzt sind die ersten vier Elemente sortiert</li> <li>wir setzen mit dem Index <code>4</code> fort</li> <li>die <code>42</code> ist gr\u00f6\u00dfer als die <code>7</code> und gr\u00f6\u00dfer als die <code>12</code>, aber kleiner als die <code>55</code>, deshalb \"stecken\" wir die <code>42</code> zwischen die <code>12</code> und die <code>55</code></li> <li>die bereits sortierten Werte <code>55</code> und <code>78</code> \"rutschen\" um eins nach rechts</li> <li>die bereits sortierten Werte <code>55</code> und <code>78</code> \"rutschen\" um eins nach rechts</li> </ul> <pre><code>07 12 42 55 78\n</code></pre> <ul> <li>Index <code>5</code> gibt es nicht, wir sind am Ende des Arrays angelangt</li> <li>das Array ist sortiert</li> </ul> <p>Hier noch ein Bild, das den Insertion-Sort-Algorithmus an einem anderen Beispiel verdeutlicht: </p> <p></p> <p>Wir n\u00e4hern uns wieder der algorithmischen Idee von Insertion-Sort an. Wir wollen eine Methode <code>insertionsort()</code> schreiben, f\u00fcr die folgendes gilt:</p> <ul> <li>Parameter: unsortiertes Array <code>a</code> </li> <li> <p>R\u00fcckgabe: sortiertes Array <code>b</code> </p> </li> <li> <p>Vorgehen:</p> <ul> <li>gedachte Teilung des Arrays in 2 Teile: <ul> <li>linker Teil: sortiert </li> <li>rechter Teil: unsortiert</li> <li>\u2794 anfangs: linker Teil = <code>b[0]</code> - d.h. nur erstes Element sortiert</li> </ul> </li> <li>erstes unsortiertes Element <code>b[i]</code> f\u00fcr <code>i &gt; 0</code>, betrachten<ul> <li>durch Vergleichen und Verschieben an der richtigen Stelle in das sortierte Array <code>b[0]</code>,\u2026,<code>b[i-1]</code> einf\u00fcgen </li> <li>\u2794 rechter unsortierter Teil des Arrays <code>b[i+1]</code>,\u2026,<code>b[n-1]</code> wird um ein Element kleiner (<code>n</code> ist L\u00e4nge des Arrays), </li> <li>\u2794 linker sortierter Teil w\u00e4chst um ein Element <code>b[j]</code></li> </ul> </li> <li>so verfahren, bis linker Teil das gesamte Array ist und der \"rechte\" Teil leer</li> </ul> </li> </ul> <p>Eine m\u00f6gliche Implementierung von Insertion-Sort:</p> <pre><code>public static int[] insertionsort(int[] a)\n{\n    int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n    for (int index = 1; index &lt; b.length; index++)  // das Element von index soll an die richtige \n    {                                               // Position &lt;= index eingefuegt werden\n        int indexLinks = 0;\n        while(indexLinks &lt; index &amp;&amp; b[indexLinks] &lt; b[index])\n        {\n            indexLinks++;\n        }\n        /*\n         * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden\n         * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben\n         * werden\n         * wir merken uns dazu b[index] und schieben dann alle Elemente:\n         *  b[index-1] nach b[index]\n         *  b[index-2] nach b[index-1]\n         *  ...\n         *  b[indexLinks] nach b[indexLinks+1]\n         */\n        int tmp = b[index];\n        for(int indexInsert = index; indexInsert&gt;indexLinks; indexInsert--)\n        {\n            b[indexInsert] = b[indexInsert-1];\n        }\n        b[indexLinks] = tmp;\n    }\n    return b;\n}\n</code></pre> <ul> <li>die \u00e4u\u00dfere <code>for</code>-Schleife (Zeile <code>5</code>) legt den aktuellen <code>index</code> f\u00fcr das Element fest, das wir betrachten und korrekt links daneben einf\u00fcgen wollen</li> <li>die <code>while</code>-Schleife (Zeilen <code>8-11</code>) sucht im linken Teil (links von <code>index</code>) nach dem ersten Element, das einen gr\u00f6\u00dferen Wert hat, als der aktuell einzuf\u00fcgende Wert <code>b[index]</code>. </li> <li>ist die <code>while</code>-Schleife verlassen (nach Zeile <code>11</code>), gibt der Wert in <code>indexLinks</code> die Position an, an die der einzuf\u00fcgende Wert eingef\u00fcgt werden soll      \u2794 dann m\u00fcssen wir alle Elemente von <code>indexLinks</code>, <code>indexLinks+1</code>, <code>indexLinks+2</code>, ... , <code>index-2</code>, <code>index-1</code> um eins nach rechts verschieben. Dazu schauen wir uns zun\u00e4chst die folgenden Abbildungen an:</li> </ul> <p></p> <p>Angenommen, wir haben das Array aus der Abbildung. Die Elemente <code>3</code>, <code>6</code>, <code>7</code>, <code>8</code> sind bereits sortiert. Der aktuelle <code>index</code> ist <code>4</code> und wir haben ermittelt, dass <code>indexLinks==1</code> ist, dass wir also die <code>4</code> an die zweite Poition im Array einf\u00fcgen wollen. Dazu muss die <code>9</code> auf den <code>index==4</code> geschoben werden, die <code>7</code> auf den Index <code>3</code> und die <code>6</code> auf den Index <code>2</code>. Damit wir den Wert <code>4</code> nicht \u00fcberschreiben, m\u00fcssen wir ihn in einer Variablen zwischenspeichern. </p> <p></p> <p>Jetzt k\u00f6nnen wir die Werte nach rechts verschieben. Angenommen, wir erstellen uns einen <code>indexInsert</code> (siehe Zeile <code>23</code> oben), der initial den Wert <code>index</code> (also <code>4</code>) hat. Dann schieben wir den Wert <code>9</code> mithilfe von <code>b[indexInsert] = b[indexInsert-1];</code> vom Index <code>3</code> nach Index <code>4</code>. Wenn wir dann <code>indexInsert</code> um <code>1</code> reduzieren (Zeile <code>23</code> oben), dann wird durch das n\u00e4chste <code>b[indexInsert] = b[indexInsert-1];</code> der Wert <code>7</code> vom Index <code>2</code> nach Index <code>3</code> geschoben. Zuletzt noch die <code>6</code> von Index <code>2</code> nach Index <code>3</code>. Dann haben wir <code>indexLinks</code> erreicht. </p> <p></p> <p>Jetzt muss nur noch der zwischengespeicherte Wert aus <code>tmp</code> nach <code>b[indexLinks]</code> geschrieben werden (Zeile <code>27</code> oben) und der Wert <code>4</code> wurde korrekt eingef\u00fcgt und es kann mit dem Index <code>5</code> weitergehen. </p> <p></p> <p>Wir f\u00fcgen zum besseren Verst\u00e4ndnis des Algorithmus wieder Ausgaben in unsere Methode ein. Die erste Zeile enth\u00e4lt das Ausgangsarray:</p> <pre><code>--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  1, aktueller Wert= 45, wird eingef\u00fcgt an Index=  1\n--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  2, aktueller Wert= 31, wird eingef\u00fcgt an Index=  1\n--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  3, aktueller Wert= 40, wird eingef\u00fcgt an Index=  2\n--&gt; [ 30, 31, 45, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  4, aktueller Wert= 35, wird eingef\u00fcgt an Index=  2\n--&gt; [ 30, 31, 40, 45, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  5, aktueller Wert= 33, wird eingef\u00fcgt an Index=  2\n--&gt; [ 30, 31, 35, 40, 45, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  6, aktueller Wert=  0, wird eingef\u00fcgt an Index=  0\n--&gt; [ 30, 31, 33, 35, 40, 45,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  7, aktueller Wert= 25, wird eingef\u00fcgt an Index=  1\n--&gt; [  0, 30, 31, 33, 35, 40, 45, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  8, aktueller Wert= 25, wird eingef\u00fcgt an Index=  1\n--&gt; [  0, 25, 30, 31, 33, 35, 40, 45, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index=  9, aktueller Wert= 30, wird eingef\u00fcgt an Index=  3\n--&gt; [  0, 25, 25, 30, 31, 33, 35, 40, 45, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 10, aktueller Wert= 39, wird eingef\u00fcgt an Index=  8\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 40, 45, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 11, aktueller Wert= 41, wird eingef\u00fcgt an Index= 10\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 39, 40, 45, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 12, aktueller Wert=  1, wird eingef\u00fcgt an Index=  1\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 13, aktueller Wert= 18, wird eingef\u00fcgt an Index=  2\n--&gt; [  0,  1, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 14, aktueller Wert=  6, wird eingef\u00fcgt an Index=  2\n--&gt; [  0,  1, 18, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45,  6, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 15, aktueller Wert= 24, wird eingef\u00fcgt an Index=  4\n--&gt; [  0,  1,  6, 18, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 24, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 16, aktueller Wert= 33, wird eingef\u00fcgt an Index= 10\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 33, 30, 27, 36, 30 ]\n\nAktueller Index= 17, aktueller Wert= 30, wird eingef\u00fcgt an Index=  7\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 30, 27, 36, 30 ]\n\nAktueller Index= 18, aktueller Wert= 27, wird eingef\u00fcgt an Index=  7\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 27, 36, 30 ]\n\nAktueller Index= 19, aktueller Wert= 36, wird eingef\u00fcgt an Index= 15\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 27, 30, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 36, 30 ]\n\nAktueller Index= 20, aktueller Wert= 30, wird eingef\u00fcgt an Index=  8\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 27, 30, 30, 30, 31, 33, 33, 35, 36, 39, 40, 41, 45, 30 ]\n</code></pre> <p>Hier noch einmal nur das Array. Man sieht, dass sich, im Gegensatz zu den vorherigen Algorithmen, kein fertig sortierter Teil ausbreitet, da die Elemente auch am Ende noch ganz nach vorne eingef\u00fcgt werden k\u00f6nnen.  </p> <pre><code>--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]\n\n--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 1\n--&gt; [ 30, 45, 31, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 2\n--&gt; [ 30, 31, 45, 40, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 3\n--&gt; [ 30, 31, 40, 45, 35, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 4\n--&gt; [ 30, 31, 35, 40, 45, 33,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 5\n--&gt; [ 30, 31, 33, 35, 40, 45,  0, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 6\n--&gt; [  0, 30, 31, 33, 35, 40, 45, 25, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 7\n--&gt; [  0, 25, 30, 31, 33, 35, 40, 45, 25, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 8\n--&gt; [  0, 25, 25, 30, 31, 33, 35, 40, 45, 30, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 9\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 40, 45, 39, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 10\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 39, 40, 45, 41,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 11\n--&gt; [  0, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45,  1, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 12\n--&gt; [  0,  1, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 18,  6, 24, 33, 30, 27, 36, 30 ]      // Index 13\n--&gt; [  0,  1, 18, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45,  6, 24, 33, 30, 27, 36, 30 ]      // Index 14\n--&gt; [  0,  1,  6, 18, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 24, 33, 30, 27, 36, 30 ]      // Index 15\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 31, 33, 35, 39, 40, 41, 45, 33, 30, 27, 36, 30 ]      // Index 16\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 30, 27, 36, 30 ]      // Index 17\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 30, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 27, 36, 30 ]      // Index 18\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 27, 30, 30, 30, 31, 33, 33, 35, 39, 40, 41, 45, 36, 30 ]      // Index 19\n--&gt; [  0,  1,  6, 18, 24, 25, 25, 27, 30, 30, 30, 31, 33, 33, 35, 36, 39, 40, 41, 45, 30 ]      // Index 20\n</code></pre> <p>Auch f\u00fcr den Insertion-Sort-Algorithmus gibt es Optimierungsvorschl\u00e4ge, von denen wir hier aber keine betrachten wollen. Wir werden uns noch einen letzten Sortier-Algorithmus anschauen, der allerdings ein wenig komplizierter auf den ersten Blick aussieht, der Merge-Sort-Algorithmus. </p>"},{"location":"sortieren/#merge-sort","title":"Merge-Sort","text":"<p>In <code>Merge-Sort</code> kommt ein v\u00f6llig neues Konzept hinzu, das wir noch gar nicht kennen. Es handelt sich um Rekursion. In der Programmierung spricht man von Rekursion, wenn sich eine Methode selbst wieder aufruft. </p>"},{"location":"sortieren/#rekursion","title":"Rekursion","text":"<p>Ruft sich eine Methode selbst wieder auf, sprechen wir von Rekursion (latein\u00a0recurrere\u00a0\u201ezur\u00fccklaufen\u201c). Das Prinzip kennen wir schon aus der Mathematik - das klassische Beispiel ist die Definition der Fakult\u00e4t:</p> <p></p> <p>Diese Funktion ist rekursiv definiert, d.h. in der Definition f\u00fcr Fakult\u00e4t wird selbst wieder die Fakult\u00e4t verwendet (<code>n! = n * (n-1)!</code>). Beachten Sie, dass es eine Abbruchbedingung f\u00fcr die Rekursion gibt, n\u00e4mlich hier <code>1! = 1</code>, d.h. es gibt einen (oder mehrere) Wert(e) (<code>n &lt;= 1</code>), f\u00fcr den kein rekursicher Aufruf (keine rekursive Defintion) verwendet wird. Als Implementierung sieht diese Funktion so aus:</p> <pre><code>public static int fakultaet(int n)\n{\n    int fak = 1;\n    if(n&gt;1)\n    {\n        fak = n * fakultaet(n-1);\n    }\n    return fak;\n}\n</code></pre> <p>F\u00fcr <code>n&gt;1</code> wird also erneut die Methode aufgerufen, wobei der Parameterwert um <code>1</code> rediziert wird und sich somit der Abbruchbedingung (dem Rekursionsende) ann\u00e4hert. </p> <p></p> <p>Wir betrachten einmal den Methodenstack bei der Ausf\u00fchrung der Methode f\u00fcr den Aufruf von <code>fakultaet(5)</code>:</p> <p></p> <p>Beginnend, mit <code>fakultatet(5)</code> (links oben) wird im Ausdruck <code>5 * fakulatet(4)</code> die Methode <code>fakultatet(4)</code> aufgerufen. Darin gibt es den Ausdruck <code>4 * fakulatet(3)</code>, so dass dort <code>fakultaet(3)</code> aufgerufen wird usw. bis zum Aufruf von <code>fakulaet(1)</code>. Dieser Aufruf gibt <code>1</code> zur\u00fcck. Damit wird die Ausf\u00fchrung der Methode <code>fakultaet(1)</code> beendet und wir landen im Stack zur\u00fcck beim Aufruf von <code>fakultaet(2)</code>. Darin wird nun <code>2 * 1</code> zur\u00fcckgegeben, also <code>2</code> und wir landen im Stack zur\u00fcck beim Aufruf von <code>fakultaet(3)</code>. Darin wird nun <code>3 * 2</code> zur\u00fcckgegeben, also <code>6</code> usw. bis der Aufruf von <code>fakultaet(5)</code> die <code>5 * 24</code>, also <code>120</code> zur\u00fcckgibt. Das ist der Wert, dem der Aufruf von <code>fakultaet(5)</code> entspricht. </p> <p>Mit Rekursion kann nicht mehr berechnet werden als mit Iteration, d.h. die Rekursion ist kein m\u00e4chtigeres Konzept als die Iteration. Alles, was mit Iteration geht, geht auch mit Rekursion und umgedreht. Manchmal sind die Algorithmen aber als Rekursion leichter zu implementieren als ohne. Beispiele daf\u00fcr sind </p> <ul> <li> <p><code>gebeOrdnerstrukturAus(ordnerOderDatei)</code></p> <ul> <li>wenn <code>Datei</code>, dann Ende</li> <li>wenn <code>Ordner</code>, dann alle Unterordner ermitteln und f\u00fcr alle Unterordner: <code>gebeOrdnerstrukturAus(unterOrdner)</code> </li> </ul> </li> <li> <p><code>gebeBaumAus(knoten)</code></p> <ul> <li>wenn <code>Blatt</code>, dann Ende</li> <li>sonst:    <ul> <li>ermittle linkes und rechtes Kind des Knotens und rufe auf: </li> <li><code>gebeBaumAus(linkesKind)</code> </li> <li><code>gebeBaumAus(rechtesKind)</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"sortieren/#merge-sort-rekursiv","title":"Merge-Sort rekursiv","text":"<p>Der Merge-Sort-Algorithmus geh\u00f6rt zu den Algorithmen, die rekursiv besser zu implementieren sind, als iterativ. Das liegt daran, dass Merge-Sort auf dem sogenannten Divide-and-Conquer-Prinzip basiert. Dieses Prinzip ist eine rekursive Programmiertechnik, in dem ein gro\u00dfes Problem in gleichartige, aber einfachere Teilprobleme zerlegt wird. Das Grundprinzip bei Divide-and-Conquer ist wie folgt:</p> <ul> <li>Bestimme ein Ma\u00df f\u00fcr die Gr\u00f6\u00dfe des Problems (z.B. Gr\u00f6\u00dfe des Arrays)</li> <li>Finde eine kleinere Gr\u00f6\u00dfe, f\u00fcr das Problem einfach zu l\u00f6sen ist (z.B. kleinere Arrays)</li> <li>L\u00f6se die kleineren Probleme und f\u00fcge die L\u00f6sungen so zusammen, dass sich die L\u00f6sung des gro\u00dfen Problems ergibt</li> </ul> <p>Bei Merge-Sort sieht das so aus:</p> <ul> <li>teile den Datensatz (meistens einfach halbieren)</li> <li>sortiere beide Datens\u00e4tze</li> <li>f\u00fcge sie zusammen (einsortieren der Gr\u00f6\u00dfe nach)</li> <li>das Teilen erfolgt dabei so lange, bis der kleine Datensatz meistens nur noch aus einem einzigen Datum besteht</li> </ul> <p></p> <p>Wir betrachten ein konkretes Beispiel. Angenommen, wir wollen das Array <code>{ 2, 4, 1, 6, 8, 5, 3, 7 }</code> mithilfe von Merge-Sort sortieren:</p> <p></p> <p>Dann zerlegen wir das Ausgangsarray zun\u00e4chst so lange, bis die einzelnen Arrays nur noch jeweils ein Element enthalten:</p> <p></p> <p>Das Teilen ist also einfach, wir ermitteln einfach immer die Mitte (<code>mid</code>) des Ausgangsarrays (<code>a</code>) und zwerlegen das Ausgangsarray dann in einen linken und in einen rechten Teil:</p> <pre><code>public int[] mergesort(int[] a)\n{\n    int[] b = copy(a);\n\n    if(b.length &gt; 1)\n    {\n        int mid = b.length/2;\n\n        /*\n         * linken Teil von b in neues Array left kopieren \n         */ \n        int[] left = new int[mid];\n        for(int index = 0; index &lt; mid; index++)\n        {\n            left[index] = b[index];\n        }\n\n        /*\n         * rechten Teil von b in neues Array rechts kopieren \n         */  \n        int[] right = new int[b.length - mid];\n        for(int index = mid; index &lt; b.length; index++)\n        {\n            right[index - mid] = b[index];\n        }\n\n        /* \n         * jetzt haben wir zwei Arrays: left und right\n         * diese sollen jetzt mithilfe von mergesort()\n         * sortiert werden\n         * dazu rufen wir   mergesort f\u00fcr Array left \n         * und              mergesort f\u00fcr Array right \n         * auf. Wir bekommen sie sortiert zur\u00fcck. \n         * \n         * Die Methode ruft sich selber wieder auf --&gt;\n         * das nennen wir Rekursion\n         * \n         */\n        left = mergesort(left);         // hier der rekursive Aufruf fuer left\n        right = mergesort(right);       // hier der rekursive Aufruf fuer right\n\n        /*\n         * jetzt sind left und right jeweils sortiert\n         * jetzt \"mergen\" wir sie so, dass insgesamt\n         * ein sortiertes Array entsteht, d.h. wir\n         * nehmen immer ein Element aus left und right und\n         * vergleichen sie miteinander; das kleinere kommt\n         * nach b, das gr\u00f6\u00dfere bleibt noch und wir \n         * nehmen aus dem Array, aus dem gerade das Element \n         * einsortiert wurde, ein neues Element\n         */  \n\n         /* kommt gleich - siehe unten */\n</code></pre> <p>Das Zusammenf\u00fcgen (merge) ist bei Merge-Sort komplizierter - deshalb Merge-Sort. Aus dem linken und aus dem rechten Array werden jetzt jeweils die ersten Elemente betrachtet und miteinander verglichen. Das kleinere von beiden kommt in das \"zusammengesetzte\" (merged) Array, das so nach und nach sortiert w\u00e4chst. </p> <p></p> <pre><code>        /*\n         * jetzt sind left und right jeweils sortiert\n         * jetzt \"mergen\" wir sie so, dass insgesamt\n         * ein sortiertes Array entsteht, d.h. wir\n         * nehmen immer ein Element aus left und right und\n         * vergleichen sie miteinander; das kleinere kommt\n         * nach b, das gr\u00f6\u00dfere bleibt noch und wir \n         * nehmen aus dem Array, aus dem gerade das Element \n         * einsortiert wurde, ein neues Element\n         */ \n            int indexLeft = 0;\n            int indexRight = 0;\n            int indexB = 0;\n\n            /*\n             * merge von left und right\n             * solange noch in einem Elemente sind\n             */\n            while(indexLeft &lt; left.length &amp;&amp; indexRight &lt; right.length)\n            {\n                if(left[indexLeft] &lt; right[indexRight])\n                {\n                    b[indexB] = left[indexLeft];\n                    indexLeft++;\n                }\n                else\n                {\n                    b[indexB] = right[indexRight];\n                    indexRight++;\n                }\n                indexB++;\n            }\n\n            /*\n             * jetzt ist left oder right leer, aber in dem \n             * jeweils anderen sind noch Elemente\n             */\n\n            /*\n             * falls noch in left Elemente sind, werden sie\n             * jetzt nach b kopiert\n             */\n            while(indexLeft &lt; left.length)\n            {\n                b[indexB] = left[indexLeft];\n                indexLeft++;\n                indexB++;\n            }\n\n            /*\n             * falls noch in right Elemente sind, werden sie\n             * jetzt nach b kopiert\n             */\n            while(indexRight &lt; right.length)\n            {\n                b[indexB] = right[indexRight];\n                indexRight++;\n                indexB++;\n            }\n        }\n        return b;\n    }   \n</code></pre> <p>Insgesamt sieht die Implementierung von Merge-Sort also so aus:</p> mergesort(int[] a) <pre><code>public static int[] mergesort(int[] a)\n{\n    int[] b = copy(a);\n\n    if(b.length &gt; 1)\n    {\n        int mid = b.length / 2;\n\n        /*\n         * linken Teil von b in neues Array left kopieren \n         */ \n        int[] left = new int[mid];\n        for(int index = 0; index &lt; mid; index++)\n        {\n            left[index] = b[index];\n        }\n\n        /*\n         * rechten Teil von b in neues Array rechts kopieren \n         */  \n        int[] right = new int[b.length - mid];\n        for(int index = mid; index &lt; b.length; index++)\n        {\n            right[index - mid] = b[index];\n        }\n\n        /* \n         * jetzt haben wir zwei Arrays: left und right\n         * diese sollen jetzt mithilfe von mergesort()\n         * sortiert werden\n         * dazu rufen wir   mergesort f\u00fcr Array left \n         * und              mergesort f\u00fcr Array right \n         * auf. Wir bekommen sie sortiert zur\u00fcck. \n         * \n         * Die Methode ruft sich selber wieder auf --&gt;\n         * das nennen wir Rekursion\n         * \n         */\n        left = mergesort(left);\n        right = mergesort(right);\n\n        /*\n         * jetzt sind left und right jeweils sortiert\n         * jetzt \"mergen\" wir sie so, dass insgesamt\n         * ein sortiertes Array entsteht, d.h. wir\n         * nehmen immer ein Element aus left und right und\n         * vergleichen sie miteinander; das kleinere kommt\n         * nach b, das gr\u00f6\u00dfere bleibt noch und wir \n         * nehmen aus dem Array, aus dem gerade das Element \n         * einsortiert wurde, ein neues Element\n         */       \n        int indexLeft = 0;\n        int indexRight = 0;\n        int indexB = 0;\n\n        /*\n         * merge von left und right\n         * solange noch in einem Elemente sind\n         */\n        while(indexLeft &lt; left.length &amp;&amp; indexRight &lt; right.length)\n        {\n            if(left[indexLeft] &lt; right[indexRight])\n            {\n                b[indexB] = left[indexLeft];\n                indexLeft++;\n            }\n            else\n            {\n                b[indexB] = right[indexRight];\n                indexRight++;\n            }\n            indexB++;\n        }\n\n        /*\n         * jetzt ist left oder right leer, aber in dem \n         * jeweils anderen sind noch Elemente\n         */\n\n        /*\n         * falls noch in left Elemente sind, werden sie\n         * jetzt nach b kopiert\n         */\n        while(indexLeft &lt; left.length)\n        {\n            b[indexB] = left[indexLeft];\n            indexLeft++;\n            indexB++;\n        }\n\n        /*\n         * falls noch in right Elemente sind, werden sie\n         * jetzt nach b kopiert\n         */\n        while(indexRight &lt; right.length)\n        {\n            b[indexB] = right[indexRight];\n            indexRight++;\n            indexB++;\n        }\n    }\n    return b;\n}\n</code></pre> Sortieren.java <pre><code>package themen.arrays.sortieren;\n\nimport java.util.Random;\n\npublic class Sortieren\n{\n    /*\n     * aus Skript\n     */\n    public static void printArray(int[] a)\n    {\n        String s = \"[ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + a[index] + \", \";\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + a[a.length-1] + \" ]\";\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * angepasste printArray-Methode\n     * hier wird davon ausgegangen, dass die Zahlen\n     * in dem Array nie gr\u00f6\u00dfer als zweistellig sind\n     * ist haupts\u00e4chlich, damit die Ausgaben der Arrays besser\n     * miteinander verglichen werden k\u00f6nnen auf der Konsole\n     * \n     */\n    public static void print(int[] a)\n    {\n        String s = \"--&gt; [ \"; \n        for(int index=0; index&lt;a.length-1; index++)\n        {\n            s = s + String.format(\"%2d, \", a[index]);\n        }\n        if(a.length &gt; 0)\n        {\n            s = s + String.format(\"%2d ]\", a[a.length-1]);\n        }\n        System.out.println(s);\n    }\n\n    /*\n     * aus Skript\n     */\n    public static int[] createAndFillArray(int length, int bound)\n    {\n        int[] a = new int[length];\n        Random r = new Random();                    \n        for(int i=0; i&lt;a.length; i++)\n        {\n            a[i]=r.nextInt(bound);\n        }\n        return a;\n    }\n\n    public static int[] copy(int[] a)\n    {\n        int[] b = new int[a.length];\n        for (int index = 0; index &lt; b.length; index++)\n        {\n            b[index] = a[index];\n        }\n        return b;\n    }\n\n    public static int[] bubblesortDebug(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = copy(a);\n\n        System.out.print(\"ori-\");\n        print(b);       // Ausgangs-Array\n        System.out.println();\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        boolean swapped = true;\n        for(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n        {\n            System.out.printf(\"%3d. Bubble-Phase : %n----\", bubble);\n            print(b);\n            swapped = false;\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                    swapped = true;\n                    System.out.printf(\"%3d \", index);\n                    print(b);\n                }\n            }\n            System.out.println();\n        }\n        return b;\n    }\n\n\n    public static int[] bubblesort(int[] a)\n    {\n        /*\n         * zuerst a nach b kopieren\n         */\n        int[] b = copy(a);\n\n        /*\n         * jetzt b sortieren\n         * aeussere for-Schleife: Bubble-Phasen\n         * innere for-Schleife: Nachbarn vergleichen und eventuell tauschen\n         */\n        boolean swapped = true;\n        for(int bubble=1; bubble&lt;=b.length-1 &amp;&amp; swapped; bubble++)\n        {\n            swapped = false;\n            for(int index=0; index&lt;b.length-bubble; index++)\n            {\n                if(b[index] &gt; b[index+1])\n                {\n                    int tmp = b[index+1];\n                    b[index+1] = b[index];\n                    b[index] = tmp;\n                    swapped = true;\n                }\n            }\n        }\n        return b;\n    }\n\n    public static int[] selectionsortDebug(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n        System.out.print(\"  original -----\");\n        print(b);       // Ausgangs-Array\n        System.out.println();\n\n        for (int durchlauf = 0; durchlauf &lt; b.length; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n        {\n            System.out.printf(\"%3d. Durchlauf - kleinstes Element soll auf den index %2d %n----&gt; \", durchlauf+1, durchlauf);\n            int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n            int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n            for (int index = durchlauf; index &lt; b.length; index++)  // Suche nach dem kleinsten Wert\n            {\n                if(minValue &gt; b[index])\n                {\n                    minValue = b[index];    // aktuell kleinster Wert\n                    minIndex = index;       // aktueller Index des kleinsten Wertes\n                }\n            }\n            System.out.printf(\"kleinster Wert ist %3d auf dem Index %3d %n\", minValue, minIndex);\n            System.out.printf(\"%13s : \", \"vor Tausch \"); print(b);\n            // jetzt den kleinsten Wert auf den Index durchlauf legen\n            // der Wert, der auf durchlauf lag, kommt nach minIndex\n            int tmp = b[durchlauf];\n            b[durchlauf] = b[minIndex];\n            b[minIndex] = tmp;\n            System.out.printf(\"%13s : \", \"nach Tausch \"); print(b);\n            System.out.println();\n        }\n        return b;\n    }\n\n\n    public static int[] selectionsort(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n        for (int durchlauf = 0; durchlauf &lt; b.length; durchlauf++)  // durchlauf ist in Vorgehen j (siehe oben)\n        {\n            int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n            int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n            for (int index = durchlauf; index &lt; b.length; index++)  // Suche nach dem kleinsten Wert\n            {\n                if(minValue &gt; b[index])\n                {\n                    minValue = b[index];    // aktuell kleinster Wert\n                    minIndex = index;       // aktueller Index des kleinsten Wertes\n                }\n            }\n            // jetzt den kleinsten Wert auf den Index durchlauf legen\n            // der Wert, der auf durchlauf lag, kommt nach minIndex\n            int tmp = b[durchlauf];\n            b[durchlauf] = b[minIndex];\n            b[minIndex] = tmp;\n        }\n        return b;\n    }\n\n    public static int[] insertionsort(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n        for (int index = 1; index &lt; b.length; index++)  // das Element von index soll an die richtige \n        {                                               // Position &lt;= index eingefuegt werden\n            int indexLinks = 0;\n            while(indexLinks &lt; index &amp;&amp; b[indexLinks] &lt; b[index])\n            {\n                indexLinks++;\n            }\n            /*\n             * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden\n             * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben\n             * werden\n             * wir merken uns dazu b[index] und schieben dann alle Elemente:\n             *  b[index-1] nach b[index]\n             *  b[index-2] nach b[index-1]\n             *  ...\n             *  b[indexLinks] nach b[indexLinks+1]\n             */\n            int tmp = b[index];\n            for(int indexInsert = index; indexInsert&gt;indexLinks; indexInsert--)\n            {\n                b[indexInsert] = b[indexInsert-1];\n            }\n            b[indexLinks] = tmp;\n        }\n        return b;\n    }\n\n    public static int[] insertionsortDebug(int[] a)\n    {\n        int[] b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n\n        print(b);       // Ausgangs-Array\n        System.out.println();\n\n        for (int index = 1; index &lt; b.length; index++)  // das Element von index soll an die richtige \n        {                                               // Position &lt;= index eingefuegt werden\n            int indexLinks = 0;\n            while(indexLinks &lt; index &amp;&amp; b[indexLinks] &lt; b[index])\n            {\n                indexLinks++;\n            }\n            System.out.printf(\"Aktueller Index=%3d, aktueller Wert=%3d, wird eingef\u00fcgt an Index=%3d%n\", index, b[index], indexLinks);\n            print(b);\n            System.out.println();\n            /*\n             * jetzt muss der Wert von b[index] an die Stelle von indexLinks eingefuegt werden\n             * dazu muessen alle Elemente von indexLinks bis index-1 um eins nach rechts geschoben\n             * werden\n             * wir merken uns dazu b[index] und schieben dann alle Elemente:\n             *  b[index-1] nach b[index]\n             *  b[index-2] nach b[index-1]\n             *  ...\n             *  b[indexLinks] nach b[indexLinks+1]\n             */\n            int tmp = b[index];\n            for(int indexInsert = index; indexInsert&gt;indexLinks; indexInsert--)\n            {\n                b[indexInsert] = b[indexInsert-1];\n            }\n            b[indexLinks] = tmp;\n        }\n        return b;\n    }\n\n\n    public static int[] selectionsortOptimiert(int[] a)\n    {\n        int[] b = new int[0];\n        if(a.length&gt;1)\n        {\n            b = copy(a);  // copy erzeugt eine Kopie von a und gibt diese zurueck\n            System.out.print(\"                    \");print(b);      // Ausgangs-Array\n\n            for (int durchlauf = 0; durchlauf &lt; b.length/2; durchlauf++)    // durchlauf ist in Vorgehen j (siehe oben)\n            {\n                int minValue = b[durchlauf];    // in minValue merken wir uns den aktuell kleinsten Wert\n                int minIndex = durchlauf;       // in minIndex merken wir uns den Index des aktuell kleinsten Wertes\n                int maxValue = b[b.length-1-durchlauf]; // in maxValue merken wir uns den aktuell groessten Wert\n                int maxIndex = b.length-1-durchlauf;        // in maxIndex merken wir uns den Index des aktuell groessten Wertes\n                System.out.printf(\"%3d %3d %3d %3d %3d %n\", durchlauf, minValue, minIndex, maxValue, maxIndex);\n                for (int index = durchlauf; index &lt; b.length-durchlauf; index++)    // Suche nach dem kleinsten UND groessten Wert\n                {\n                    if(minValue &gt; b[index])\n                    {\n                        minValue = b[index];    // aktuell kleinster Wert\n                        minIndex = index;       // aktueller Index des kleinsten Wertes\n                    }\n                    if(maxValue &lt; b[index])\n                    {\n                        maxValue = b[index];    // aktuell groesster Wert\n                        maxIndex = index;       // aktueller Index des groessten Wertes\n                    }\n                }\n                /* \n                 * jetzt den kleinsten Wert auf den Index durchlauf legen\n                 * der Wert, der auf durchlauf lag, kommt nach minIndex\n                 * UND den groessten Wert auf den Index b.length-1-durchlauf legen\n                 * der Wert, der auf b.length-1-durchlauf lag, kommt nach maxIndex\n                 * wir m\u00fcssen zun\u00e4chst aber beide Werte sichern, sonst kann es zu\n                 * Konflikten beim Tauschen kommen!\n                 * \n                 */\n                System.out.printf(\"%3d %3d %3d %3d %3d \", durchlauf, minValue, minIndex, maxValue, maxIndex);\n                int tmpMin = b[durchlauf];\n                int tmpMax = b[b.length-1-durchlauf];\n                b[durchlauf] = minValue;\n                b[minIndex] = tmpMin;\n                /*\n                 * hier wird es sehr kompliziert\n                 * wenn der MaximumWert dort war, wo das neue Minimum hin kommt (Index durchlauf), \n                 * dann m\u00fcssen wir aufpassen, dass wir den alten Wert tmpMax nicht verlieren\n                 * es sind jetzt nur noch 3 Werte im Spiel\n                 * der alte Wert von durchlauf - ist in tmpMin UND ist gleichzeitig maxValue!\n                 * der alte Wert von length-1-durchlauf - ist in tmpMax\n                 * der alte Wert von minIndex ist minValue und jetzt auf durchlauf\n                 * Versuchen Sie es mal ohne die Bedingung und nur\n                 *  b[b.length-1-durchlauf] = maxValue;\n                 *  b[maxIndex] = tmpMax;\n                 * dann sehen Sie den Fehler\n                 */\n                if(maxIndex == durchlauf)\n                {\n                    b[b.length-1-durchlauf] = b[minIndex];\n                    b[minIndex] = tmpMax;\n                }\n                else\n                {\n                    b[b.length-1-durchlauf] = maxValue;\n                    b[maxIndex] = tmpMax;\n                }   \n\n                print(b);\n            }\n        }\n        return b;\n    }\n\n    public static int[] mergesort(int[] a)\n    {\n        int[] b = copy(a);\n\n        if(b.length &gt; 1)\n        {\n            int mid = b.length / 2;\n\n            /*\n             * linken Teil von b in neues Array left kopieren \n             */ \n            int[] left = new int[mid];\n            for(int index = 0; index &lt; mid; index++)\n            {\n                left[index] = b[index];\n            }\n\n            /*\n             * rechten Teil von b in neues Array rechts kopieren \n             */  \n            int[] right = new int[b.length - mid];\n            for(int index = mid; index &lt; b.length; index++)\n            {\n                right[index - mid] = b[index];\n            }\n\n            /* \n             * jetzt haben wir zwei Arrays: left und right\n             * diese sollen jetzt mithilfe von mergesort()\n             * sortiert werden\n             * dazu rufen wir   mergesort f\u00fcr Array left \n             * und              mergesort f\u00fcr Array right \n             * auf. Wir bekommen sie sortiert zur\u00fcck. \n             * \n             * Die Methode ruft sich selber wieder auf --&gt;\n             * das nennen wir Rekursion\n             * \n             */\n            left = mergesort(left);\n            right = mergesort(right);\n\n            /*\n             * jetzt sind left und right jeweils sortiert\n             * jetzt \"mergen\" wir sie so, dass insgesamt\n             * ein sortiertes Array entsteht, d.h. wir\n             * nehmen immer ein Element aus left und right und\n             * vergleichen sie miteinander; das kleinere kommt\n             * nach b, das gr\u00f6\u00dfere bleibt noch und wir \n             * nehmen aus dem Array, aus dem gerade das Element \n             * einsortiert wurde, ein neues Element\n             */       \n            int indexLeft = 0;\n            int indexRight = 0;\n            int indexB = 0;\n\n            /*\n             * merge von left und right\n             * solange noch in einem Elemente sind\n             */\n            while(indexLeft &lt; left.length &amp;&amp; indexRight &lt; right.length)\n            {\n                if(left[indexLeft] &lt; right[indexRight])\n                {\n                    b[indexB] = left[indexLeft];\n                    indexLeft++;\n                }\n                else\n                {\n                    b[indexB] = right[indexRight];\n                    indexRight++;\n                }\n                indexB++;\n            }\n\n            /*\n             * jetzt ist left oder right leer, aber in dem \n             * jeweils anderen sind noch Elemente\n             */\n\n            /*\n             * falls noch in left Elemente sind, werden sie\n             * jetzt nach b kopiert\n             */\n            while(indexLeft &lt; left.length)\n            {\n                b[indexB] = left[indexLeft];\n                indexLeft++;\n                indexB++;\n            }\n\n            /*\n             * falls noch in right Elemente sind, werden sie\n             * jetzt nach b kopiert\n             */\n            while(indexRight &lt; right.length)\n            {\n                b[indexB] = right[indexRight];\n                indexRight++;\n                indexB++;\n            }\n        }\n        return b;\n    }\n\n    public static int fakultaet(int n)\n    {\n        int fak = 1;\n        if(n&gt;1)\n        {\n            fak = n * fakultaet(n-1);\n        }\n        return fak;\n    }\n\n    public static void main(String[] args)\n    {\n        int[] unsorted = createAndFillArray(21, 50);\n\n        System.out.printf(\"%n%n--------------- bubblesort ----------------------%n%n\");\n        int[] sorted = bubblesort(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n\n        System.out.printf(\"%n%n--------------- selectionsort ----------------------%n%n\");\n        int[] us = { 1, 12, 41, 35, 49,  2, 28, 38, 21, 35, 41, 12, 21, 29, 27, 17,  5,  6, 18,  3 };\n        sorted = selectionsortOptimiert(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n\n        System.out.printf(\"%n%n--------------- insertionsort ----------------------%n%n\");\n        sorted = insertionsortDebug(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n\n\n        System.out.printf(\"%n%n--------------- mergesort ----------------------%n%n\");\n        sorted = mergesort(unsorted);\n        printArray(unsorted);\n        printArray(sorted);\n\n        System.out.println(fakultaet(5));\n    }\n\n}\n</code></pre>"},{"location":"sortieren/#quicksort","title":"Quicksort","text":"<p>Ein Sortier-Algorithmus, der ebenfalls auf dem Divide-and-Conquer-Prinzip berucht, ist Quicksort. Bei Quicksort ist, im Gegensatz zu Merge-Sort, das Teilen kompliziert und das Zusammenf\u00fcgen einfach. Die Methode <code>sort()</code> der Klasse <code>Arrays</code> verwendet Quicksort. Wir gehen hier aber aus Zeitgr\u00fcnden nicht weiter auf den Algroithmus ein. Sie k\u00f6nnen sich aber gerne dar\u00fcber selbst\u00e4ndig informieren. Es gibt viele Implementierungen und Erl\u00e4uterungen davon im Netz, z.B. hier, hier und hier.</p>"},{"location":"start/","title":"Unser erstes Programm","text":"<p>Bevor wir uns mit der Funktionsweise von Java auseinandersetzen, schreiben wir einfach einmal unser erstes Programm. Wir \u00f6ffnen dazu Eclipse und erstellen uns eine Klasse <code>HelloFIW</code>. Dazu </p> <ol> <li> <p>erstellen wir uns ein Java-Projekt (falls noch nicht geschehen): Men\u00fcpunkt <code>File --&gt; New --&gt; Java Project</code>, geben in das Textfeld <code>Project name:</code> z.B. <code>WS24</code> (in den Screenshots steht dort <code>WS22</code>) ein.</p> <p></p> <p>Den <code>module name</code> beim Erstellen der <code>module-info.java</code> k\u00f6nnen Sie genau so lassen, wie vorgeschlagen (<code>WS24</code>). Klicken Sie auf den Button <code>Create</code>.</p> </li> <li> <p>erstellen wir uns ein Paket: Men\u00fcpunkt <code>File --&gt; New --&gt; Package</code> und geben <code>themen.eins.start</code> ein.</p> </li> <li>erstellen wir uns eine Klasse: Wir w\u00e4hlen das Paket <code>themen.eins.start</code> aus und w\u00e4hlen den Men\u00fcpunkt <code>File --&gt; New --&gt; Class</code>, geben in dem Fenster den Klassennamen <code>HelloFIW</code> ein und setzen bei <code>public static void main(Strg[] args)</code> ein H\u00e4kchen:</li> </ol> <p></p> <p>Im Editor-Fenster von Eclipse erscheint:</p> HelloFIW.java <pre><code>package themen.eins.start;\n\npublic class HelloFIW \n{\n\n    public static void main(String[] args) \n    {\n        // TODO Auto-generated method stub\n\n    }\n\n}\n</code></pre> <p>Schauen wir uns diesen Code zun\u00e4chst an:</p> <ul> <li>in Zeile <code>1</code> sehen wir, in welchem Paket sich unsere Klasse befindet. Die Anweisung <code>package themen.eins.start;</code>definiert, dass wir uns im Paket <code>themen.eins.start</code> befinden. Mit Paketen werden wir uns in K\u00fcrze ausf\u00fchrlich auseinandersetzen.</li> <li>in Zeile <code>3</code> steht unsere Klassendefinition. Diese erkennen wir am Schl\u00fcsselwort <code>class</code> gefolgt von dem Namen der Klasse <code>HelloFIW</code>. Das Schl\u00fcsselwort <code>public</code> beschreibt, dass es sich um eine \u00f6ffentliche Klasse handelt, die von allen genutzt werden kann. Dieses Schl\u00fcsselwort ist ein sogenannter Sichtbarkeitsmodifierer (auch Zugriffsmodifizierer). Mit Sichtbarkeitsmodifizierern werden wir uns ebenfalls noch ausf\u00fchrlich auseinandersetzen. Wichtig ist, dass die Klasse nicht nur aus dem Klassenkopf (<code>public class HelloFIW</code>) besteht, sondern aus allem, was diese Klassen enth\u00e4lt (dem Klassenrumpf). Der Klassenrumpf beginnt mit einer \u00f6ffnenden geschweiften Klammer <code>{</code> (Zeile <code>4</code>) und endet mit einer schlie\u00dfenden geschweiften Klammer <code>}</code> (Zeile <code>12</code>).</li> <li>eine Klasse kann beliebig viele Methoden enthalten. Unsere Klasse enth\u00e4lt bis jetzt eine Methode, die Methode namens <code>main()</code>. Methoden erkennen wir an den runden Klammern nach dem Methodennamen. Hier ist der Name <code>main</code> gefolgt von runden Klammern, in denen Parameter (auch Argumente genannt) definiert sein k\u00f6nnen (hier ein Parameter namens <code>args</code> vom Typ String-Array: <code>Strg[] args</code>). Wie bei den Klassen auch, bestehen Methoden aus einem Methodenkopf und einem Methodenrumpf. Wie bei den Klassen auch, beginnt der Methodenrumpf mit einer \u00f6ffnenden geschweiften Klammer (Zeile <code>7</code>) und endet mit einer schlie\u00dfenden geschweiften Klammer (Zeile <code>10</code>). Der Methodenkopf <ul> <li>beginnt erneut mit einem Sichtbarkeitsmodifizierer. Dieser ist hier wieder <code>public</code> und gibt an, dass diese Methode \u00f6ffentlich ist und von allen ausgef\u00fchrt werden kann. </li> <li>Danach kommt das Schl\u00fcsselwort <code>static</code>. Dieses Schl\u00fcsselwort besagt, dass es sich bei dieser Methode um eine Klassenmethode handelt. Das Gegenst\u00fcck zu einer Klassenmethode ist die Objektmethode. Wir werden uns mit der Unterscheidung zwischen Klassen- und Objektmnethoden ausf\u00fchrlich auseinandersetzen. Wir k\u00f6nnen uns aber schon merken (wenn \u00fcberhaupt), dass wir eine Klassenmethode aufrufen k\u00f6nnen ohne ein Objekt der Klasse erstellen zu m\u00fcssen. </li> <li>Danach kommt das Schl\u00fcsselwort <code>void</code>. Dieses Schl\u00fcsslwort gibt an, dass die Methode nichts zur\u00fcckgibt. An dieser Stelle steht der R\u00fcckgabetyp eine Methode - wenn die Methode etwas zur\u00fcckgibt. Unsere Methode gibt nichts zur\u00fcck, deshalb hier <code>void</code>. Wir werden uns mit Methodenr\u00fcckgaben ausf\u00fchrlich besch\u00e4ftigen.</li> <li>Jetzt kommt der Name der Methode, hier <code>main</code>. Die <code>main()</code>-Methode ist eine ganz besondere Methode. Sie existiert in einem Programm genau einmal und wird aufgerufen, wenn das Programm aufgerufen wird - die sogenannte Programmmethode. Wenn wir ein Programm ausf\u00fchren, wird alles das ausgef\u00fchrt, was in dem Rumpf der <code>main()</code>-Methode definiert ist (derzeit noch nichts). </li> <li>In den runden Klammern stehen Parameter (auch Argumente genannt). In unserem Fall ist ein Parameter namens <code>args</code> definiert. Der Datentyp dieses Parameters ist <code>Strg[]</code>, d.h. dass der Parameter einem Array von Zeichenketten Strings entspricht. Wir k\u00fcmmern uns um Parameter sp\u00e4ter ausf\u00fchrlich. </li> </ul> </li> <li>In unserer Methode gibt es derzeit nur einen einzigen Eintrag (Zeile <code>8</code>). Dabei handelt es sich um einen Kommentar, genauer hier um einen Zeilenkommentar. Zeilenkommentare beginnen mit einem Doppelslash <code>//</code>. Hinter diesen Doppelslash k\u00f6nnen Sie schreiben, was Sie m\u00f6chten - bis an das Zeilenende. Kommentare dienen Ihnen dazu, den Code verst\u00e4ndlicher zu gestalten oder Ihnen Hinweise zu geben. Hier steht der Hinweis, dass die Methode automatisch durch Eclipse erstellt wurde und Sie noch das ToDo haben, die Methode zu bef\u00fcllen. Das machen wir jetzt auch!</li> </ul> <p>Wir l\u00f6schen den Kommentar und f\u00fcgen nun die Anweisung <code>System.out.println(\"HelloFIW !\");</code> in unseren Methodenrumpf ein. Unsere Klasse sieht nun so aus (die neuhinzugekommene Zeile ist markiert):</p> HelloFIW.java <pre><code>package themen.eins.start;\n\npublic class HelloFIW\n{\n\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello FIW!\");\n\n    }\n\n}\n</code></pre> <p>Jetzt w\u00e4hlen wir entweder im Men\u00fc <code>Run --&gt; Run</code> oder klicken auf den kleinen gr\u00fcnen Kreis mit dem wei\u00dfen Pfeil in der Mitte in der Werkzeugleiste. Sie werden gefragt, ob Sie Ihr Programm zun\u00e4chst speichern wollen. Bevor Sie das best\u00e4tigen, sollten Sie ein H\u00e4kchen setzen, um zu sagen, dass Sie das gar nicht mehr gefragt werden wollen, sondern das Programm immer gespeichert werden soll, bevor Sie es ausf\u00fchren. In der Konsole erscheint:</p> <p> </p> <p>Success</p> <p>Herzlichen Gl\u00fcckwunsch! Sie haben Ihr erstes Java-Programm geschrieben und ausgef\u00fchrt!</p>"},{"location":"start/#systemoutprintlnhello-fiw","title":"System.out.println(\"Hello FIW!\");","text":"<p>Schauen wir uns <code>System.out.println(\"Hello FIW!\");</code> zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlcih die Klasse <code>System</code>. Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns gesschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket <code>java.lang</code>. Diese Klasse hat eine interssante Klassenvariable, die wir verwenden, n\u00e4mlich <code>out</code>. Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole. Um nun eine Ausgabe auf diese Konsole zu generieren verwenden wir die Methode <code>println()</code>. Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation. Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit <code>System.out</code> auf das Standardausgabeger\u00e4t zu und mit <code>System.out.println()</code> auf die <code>println()</code>-Methode des Ausgabeger\u00e4tes<sup>1</sup>.</p> <p>Die Methode <code>println()</code> erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode eine Zeichenkette (einen String). Eine Zeichenkette erkennt man an den doppelten Anf\u00fchrungsstrichen <code>\"das ist eine Zeichekette\"</code>. Innerhalb dieser Anf\u00fchrungsstriche k\u00f6nnen Sie schreiben, was Sie m\u00f6chten (au\u00dfer <code>\"</code>). Wir haben uns f\u00fcr <code>\"Hello FIW!\"</code>entschieden und genau diese Zeichenkette (ohne die Anf\u00fchrungsstriche) wird ausgegeben. Die Zeichnkette, die wir ausgeben m\u00f6chten, schreiben wir in die runden Klammern der <code>println()</code>-Methode, also <code>println(\"Hello FIW!\")</code>. </p> <p>Bei <code>System.out.println(\"Hello FIW!\");</code> handelt es sich um eine Anweisung. Eine Anweisung endet in Java immer mit einem Semikolon <code>;</code>. Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. </p> <p>Tipp</p> <p>Wir m\u00fcssen <code>System.out.println()</code> von nun an recht h\u00e4ufig schreiben. Deshalb gibt es in Eclipse daf\u00fcr einen Shortcut. Schreiben Sie einfach <code>syso</code> und klicken dann die <code>Control</code> (<code>Strg</code>)-Taste zusammen mit der Leertaste und dann <code>Enter</code>. Aus dem <code>syso</code> macht Eclipse dann automatisch <code>System.out.println()</code>.</p> <p>Das hei\u00dft, dass jede der Ausgaben mithilfe der <code>println()</code>-Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. </p> <p>Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die <code>println()</code>- Methode, sondern <code>print()</code>:</p> main()-Methode mit print() <pre><code>package themen.eins.start;\n\npublic class HelloFIW\n{\n\n    public static void main(String[] args)\n    {\n        System.out.print(\"Hello FIW!\");\n        System.out.print(\"Hello FIW!\");\n        System.out.print(\"Hello FIW!\");\n    }\n\n}\n</code></pre> <p>Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe:</p> <pre><code>Hello FIW!Hello FIW!Hello FIW!\n</code></pre> <p>Die <code>print()</code>-Methode gibt also nur die Zeichenkette aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Zeichenketten werden in der Konsole deshalb hintereinander ausgegeben.</p> <p>\u00dcbung</p> <p>Was m\u00fcssen Sie im Programm \u00e4ndern, damit zwischen <code>!</code> und <code>H</code> jeweils ein Leerzeichen ist, also anstelle von <code>Hello FIW!Hello FIW!Hello FIW!</code> besser <code>Hello FIW! Hello FIW! Hello FIW!</code> ausgegeben wird? </p> <p>Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: <code>System.out.println()</code>. Wir rufen also die <code>println()</code>-Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt.</p> main()-Methode mit print() und println() <pre><code>package themen.eins.start;\n\npublic class HelloFIW\n{\n\n    public static void main(String[] args)\n    {\n        System.out.print(\"Hello FIW!\");\n        System.out.println();\n        System.out.print(\"Hello FIW!\");\n        System.out.println();\n        System.out.print(\"Hello FIW!\");\n        System.out.println();\n    }\n\n}\n</code></pre> <p>Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe:</p> <pre><code>Hello FIW!\nHello FIW!\nHello FIW!\n</code></pre> <p>\u00dcbung</p> <p>Erzeugen Sie folgende Ausgabe auf der Konsole: <pre><code>Hello FIW!\n\nHello FIW!\n\nHello FIW!\n</code></pre></p> Eine m\u00f6gliche L\u00f6sung <pre><code>package themen.eins.start;\n\npublic class HelloFIW\n{\n\n    public static void main(String[] args)\n    {\n        System.out.println(\"Hello FIW!\");\n        System.out.println();\n        System.out.println(\"Hello FIW!\");\n        System.out.println();\n        System.out.println(\"Hello FIW!\");\n        System.out.println();\n    }\n\n}\n</code></pre>"},{"location":"start/#syntaxfehler","title":"Syntaxfehler","text":"<p>Programmieren bedeutet auch, Fehler zu machen. Wichtig ist, dass Sie die Fehlerausschriften lesen und die Fehler analysieren. Haben Sie einen Syntaxfehler, so ist ein Bereich Ihres Programmcodes rot unterstrichen und an der Seite erscheint ein rotes Kreuz. Fahren Sie mit der Maus \u00fcber das rote Kreuz, um die Fehlerausschrift zu erhalten. Bei einem Syntaxfehler l\u00e4sst sich das Programm nicht compilieren. Sie k\u00f6nnen es trotzdem versuchen und erhalten die Fehlerausschrift dann auf der Konsole. Das folgende Bild zeigt einen Fehler:</p> <p></p> <p>Es erscheint die Fehlermeldung <code>Syntax error, insert \";\" to complete BlockStatements</code> - ein Hinweis darauf, dass ein Semikolon fehlt - n\u00e4mlcih am Ende der Anweisung. </p> <p>In vielen F\u00e4llen bietet Eclipse einen sogenannten Quickfix an. Meistens k\u00f6nnen Sie diesen Vorschlag einfach annehmen (durch Mausclick auf den Vorschlag). Die folgende Abbildung zeigt einen solchen Quickfix f\u00fcr den Fehler, dass die Methode <code>prntln()</code> nicht existiert (es fehlt das <code>i</code>).</p> <p></p> <p>Success</p> <p>Wir haben unser erstes Java-Programm geschrieben und ausgef\u00fchrt! Wir haben gelernt, wie wir mithilfe der Methoden <code>println()</code> und <code>print()</code> Zeichenketten auf die Konsole ausgeben k\u00f6nnen und wir haben uns angeschaut, wie wir Fehlerausschriften lesen. Nun schauen wir uns einmal an, was im Hintergrund passiert, wenn wir das Programm ausf\u00fchren.</p>"},{"location":"start/#kommentare","title":"Kommentare","text":"<p>In Ihren Quellcode (Ihr Programm) k\u00f6nnen Sie an allen beliebigen Stellen Kommentare schreiben. Kommentare werden vom Compiler ignoriert, d.h. Sie k\u00f6nnen dort hineinschreiben, was und wie Sie m\u00f6chten. Es gibt drei Arten von Kommentaren in Java:</p> <ul> <li>Zeilenkommentare: Diese beginnen mit <code>//</code> und danach kommt der Kommentar bis zum Zeilenende. Die neue Zeile ist dann wieder \"normaler\" Quellcode     <pre><code>System.out.println(\"Ausgabe1\");     // hier ist ein Zeilenkommentar bis zum Ende der Zeile\nSystem.out.println(\"Ausgabe2\");     // hier ist noch ein Zeilenkommentar\n</code></pre></li> <li>Blockkommentare: Diese beginnen mit <code>/*</code> und danach kommt der Kommentar. Er kann sich \u00fcber mehrere Zeilen erstrecken. Ein Blockkommentar endet mit <code>*/</code>. Nach diesem Ende ist sofort wieder \"normaler\" Quellcode.     <pre><code>System.out.println(\"Ausgabe1\");\n/*\n    hier ist ein Blockkommentar\n    er kann \u00fcber beliebig viele \n    Zeilen gehen\n    Er endet erst mit\n*/  \nSystem.out.println(\"Ausgabe2\");     \n</code></pre></li> <li>Java-Doc-Kommentare: <code>javadoc</code> ist ein Programm aus dem Java Development Kit (JDK). Es wird eingesetzt, um den Code zu dokumentieren. Wir werden <code>javadoc</code> noch ausf\u00fchrlich behandeln. Mit <code>javadoc</code> kommentierte Klassen finden Sie hier. Java-Doc-Kommentare beginnen mit <code>/**</code> und enden mit <code>*/</code>. Java-Doc-Kommentare verhalten sich wie Blockkommentare. Sie erstrecken sich \u00fcber mehrere Zeilen und nach dem <code>*/</code> ist, wie bei Blockkommentaren, wieder \"normaler\" Quellcode.      <pre><code>package uebungen.uebung0;\n/**\n * \n * @author jornfreiheit\n * \n * Das ist die erste Klasse, die wir geschrieben haben.\n * Sie erzeugt einfache Ausgaben von Zeichenketten auf\n * die Konsole.\n *\n */\npublic class MyFirstClass { \n    // Hier die Implementierung unserer Klasse - nicht gezeigt\n}\n</code></pre></li> </ul> <p>&gt;&gt;&gt; Ab hier m\u00fcssen Sie nicht selbst ausprobieren. &gt;&gt;&gt; Es geht darum, ein Verst\u00e4ndnis daf\u00fcr zu erzeugen, dass &gt;&gt;&gt; das Programm immer zun\u00e4chst compiliert und &gt;&gt;&gt; nur wenn dies erfolgreich war, ausgef\u00fchrt wird </p>"},{"location":"start/#compilieren-und-ausfuhren","title":"Compilieren und Ausf\u00fchren","text":"<p>Wir haben nun unser erstes einfaches Programm geschrieben - in der Programmiersprache Java. Wie wir in Werkzeuge -&gt; Java bereits bei der Installation von Java erl\u00e4utert haben, ist Java nicht nur eine Programmiersprache, sondern auch ein Programm, in dem wir Java-Programme ausf\u00fchren k\u00f6nnen - die Laufzeitumgebung von Java. Wir werden zun\u00e4chst erl\u00e4utern, was im Hintergrund passiert, wenn wir ein selbstgeschriebenes Java-Programm ausf\u00fchren. </p> <p>Zum besseren Verst\u00e4ndnis erzeugen wir uns zun\u00e4chst ein Verzeichnis <code>test</code> irgendwo auf unserem Rechner:</p> <pre><code>mkdir test\ncd test\n</code></pre> <p>Dieses Verzeichnis werden wir sp\u00e4ter wieder l\u00f6schen. Nun erzeugen wir uns mithilfe von <code>vi</code>oder <code>vim</code> eine Datei <code>Test.java</code>:</p> <pre><code>vim Test.java\n</code></pre> <p>Die Datei \u00f6ffnet sich zum Schreiben und nach Eingabe von <code>i</code> k\u00f6nnen wir in diese Datei Text einf\u00fcgen. Wir f\u00fcgen folgendes Programm ein (Kopieren Sie das Programm und f\u00fcgen es mit <code>Strg+V</code> in die Datei <code>Test.java</code> ein:</p> Test.java <pre><code>    public class Test\n    {\n\n        public static void main(String[] args)\n        {\n            System.out.print(\"Hello \");\n            for(String s : args)\n            {\n                System.out.print(s + \" \");\n            }\n            System.out.println(\"!\");\n        }\n    }\n</code></pre> <p>Beenden Sie den Einf\u00fcgemodus von <code>vim</code> durch Dr\u00fccken der Taste <code>Esc</code> und speichern die Datei und beenden <code>vim</code> unter Eingabe von <code>ZZ</code>. In unserem Ordner <code>test</code> befindet sich nun die Datei <code>Test.java</code>:</p> <pre><code>ls -la\n</code></pre> <p>zeigt den Inhalt unseres Verzeichnisses <code>test</code> an (z.B.):</p> <pre><code>total 8\ndrwxr-xr-x@  3 jornfreiheit  staff    96  3 Aug 14:17 .\ndrwxr-xr-x@ 39 jornfreiheit  staff  1248  1 Nov  2018 ..\n-rw-r--r--   1 jornfreiheit  staff   189  3 Aug 14:17 Test.java\n</code></pre> <p>Wir haben eine Klasse <code>Test</code> in der Datei erstellt, die genauso hei\u00dft, wie die Klasse, n\u00e4mlich <code>Test.java</code>. Wir werden in Zukunft immer die Klasse in der gleichnamigen Datei speichern, die die Dateiendung <code>.java</code> hat - das macht Eclipse f\u00fcr uns automatisch. </p>"},{"location":"start/#compilieren-der-klasse","title":"Compilieren der Klasse","text":"<p>Ein Computer kann keine Datei ausf\u00fchren, die in einer Programmiersprache geschrieben wurde, egal um welche Programmiersprache es sich handelt. Computer verstehen nur Folgen von Nullen und Einsen, also so etwas wie <code>1000111110101011...</code>. In eine solche Maschinensprache muss unser Programm \u00fcbersetzt werden. Das \u00dcbersetzen erfolgt durch einen Compiler<sup>2</sup>.</p> <p>Der Java-Compiler hei\u00dft <code>javac</code>. Wir haben den Java-Compiler zusammen mit dem Java Development Kit (JDK) installiert (siehe hier). Mithilfe des Compilers \u00fcbersetzen wir nun unsere Klasse:</p> <pre><code>javac Test.java\n</code></pre> <p>Wenn wir uns nun erneut den Inhalt unseres Verzeichnisses ansehen</p> <pre><code>ls -la\n</code></pre> <p>dann entdecken wir, dass eine Datei <code>Test.class</code> erzeugt wurde.</p> <pre><code>total 16\ndrwxr-xr-x@  4 jornfreiheit  staff   128  7 Aug 11:02 .\ndrwxr-xr-x@ 39 jornfreiheit  staff  1248  1 Nov  2018 ..\n-rw-r--r--   1 jornfreiheit  staff  1001  7 Aug 11:02 Test.class\n-rw-r--r--   1 jornfreiheit  staff   189  3 Aug 14:17 Test.java\n</code></pre> <p>Unser Java-Compiler hat unser Programm, das in <code>Test.java</code> enthalten ist, in sogenannten Bytecode \u00fcbersetzt. Das ist ein Zwischenschritt, den es in Java gibt. Das Programm wird nicht direkt in Maschinencode \u00fcbersetzt, sondern in Bytecode. </p>"},{"location":"start/#ausfuhren-des-programms","title":"Ausf\u00fchren des Programms","text":"<p>Dieser Bytecode kann nun von der Java-Laufzeitumgebung (Java Runtime Environment - JRE) ausgef\u00fchrt werden. Diese Laufzeitumgebung ist selbst ein Programm, eine sogenannte Virtuelle Maschine<sup>3</sup>.</p> <p>Die Ausf\u00fchrung unseres Programms erfolgt mithilfe der Java-Laufzeitumgebung <code>java</code>:</p> <pre><code>java Test\n</code></pre> <p>Beachten Sie, dass Sie nicht die Dateiendung <code>.class</code> f\u00fcr Ihr Programm angeben (m\u00fcssen/d\u00fcrfen). Auf unserer Konsole erscheint die Ausgabe </p> <pre><code>Hello !\n</code></pre> <p>Diese Ausgabe erfolgt durch die Anweisung <code>System.out.print(\"Hello \");</code> (in Zeile <code>6</code>), gefolgt von der Anweisung <code>System.out.println(\"!\");</code> (in Zeile <code>11</code>). In den Zeilen <code>7</code>-<code>10</code> stehen Anweisungen, die wir noch nicht verstehen. Das macht nichts, wir kommen sp\u00e4ter darauf zur\u00fcck. Es ist jedoch so, dass wir dadurch unserem Programm Argumente \u00fcbergeben k\u00f6nnen. Betrac hten wir zum Beispiel die Anweisung <code>ls -la</code>. <code>ls</code> w\u00e4re z.B. ein \"Programm\" und <code>-la</code> ein Argument (<code>-l</code> sorgt daf\u00fcr, dass ein langes Listenformat erscheint, also alle Angaben zu den Dateien und Ordnern erscheinen und <code>-a</code> sorgt daf\u00fcr, dass auch die Dateien und Ordner angezeigt werden, die mit <code>.</code> beginnen). Versuchen wir also einmal, umserem Programm <code>Test</code> ein Argument zu \u00fcbergeben (ohne <code>-</code>):</p> <pre><code>java Test FIW\n</code></pre> <p>Es erscheint die Ausgabe:</p> <pre><code>Hello FIW !\n</code></pre> <p>Wir k\u00f6nnen sogar mehrere Argumente \u00fcbergeben:</p> <pre><code>java Test FIW HTW Berlin Welt\n</code></pre> <p>Es erscheint die Ausgabe:</p> <pre><code>Hello FIW HTW Berlin Welt !\n</code></pre> <p>Es erscheint zun\u00e4chst aufwendig, das Programm zun\u00e4chst in Bytecode zu \u00fcbersetzen und dann den Bytecode nochmal interpretieren und ausf\u00fchren zu lassen. Warum wird nicht direkt in Maschinencode \u00fcbersetzt? Die Antwort ist, dass der Java-Compiler so beriebssystemunabh\u00e4ngig arbeiten kann. Alle, egal, ob Windows-, iOS- oder Linux-Nutzerinnen k\u00f6nnen den gleichen Compiler verwenden. Die Programme k\u00f6nnen v\u00f6llig systemunabh\u00e4ngig geschrieben und von allen compiliert werden. Erst die Java-Laufzeitumgebung ist beriebssystemabh\u00e4ngig, d.h. diese wird entsprechend dem Betriebssystem installiert. Alle Java-Programme und auch ihre Compilierung sind jedoch v\u00f6llig losgel\u00f6st vom verwendeten Betriebssystem und k\u00f6nnen deshalb \u00fcberall ausgef\u00fchrt werden.</p> <p>Success</p> <p>Wir haben uns angeschaut, was passiert, wenn wir das Programm \u00fcbersetzen und ausf\u00fchren. Die \u00dcbersetzung erfolgt durch den Java-Compiler <code>javac</code>. Dieser erzeugt Java-Bytecode. Die Ausf\u00fchrung dieses Bytcodes \u00fcbernimmt die Java-Laufzeitumgebung <code>java</code>. Diese interpretiert den Bytecode und f\u00fchrt ihn sequentiell (also nacheinander, Anweisung f\u00fcr Anweisung) aus.</p> <ol> <li> <p>Wenn wir ganz genau sein wollen, dann ist <code>out</code> vom Typ <code>PrintStream</code> und wir greifen auf die Objektmethode <code>println()</code> des <code>PrintStream</code>-Objektes <code>out</code> zu.\u00a0\u21a9</p> </li> <li> <p>Man unterscheidet bei Programmiersprachen, ob die Programme durch einen Compiler oder durch einen Interpreter \u00fcbersetzt werden. Programmiersprachen, bei denen die Programme durch einen Interpreter \u00fcbersetzt werden, werden auch Skriptsprachen genannt. In Skriptsprachen wird jede einzelne Anweisung nach und nach interpretiert, d.h. \u00fcbersetzt, dann ausgef\u00fchrt, dann die n\u00e4chste Anweisung \u00fcbersetzt, ausgef\u00fchrt usw. Java-Programme werden compiliert, d.h. sie werden als Ganzes \u00fcbersetzt und erst dann ausgef\u00fchrt.\u00a0\u21a9</p> </li> <li> <p>Genauer handelt es sich dabei um einen Interpreter. Der Java-Bytecode wird Anweisung f\u00fcr Anweisung interpretiert und ausgef\u00fchrt.\u00a0\u21a9</p> </li> </ol>"},{"location":"tools/","title":"Werkzeuge","text":""},{"location":"tools/#literaturempfehlungen","title":"Literaturempfehlungen","text":"<ul> <li>Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\",  Springer Vieweg</li> <li>Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\", Springer Vieweg</li> <li>Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: \"Grundkurs Programmieren in Java x\", Hanser Verlag</li> <li>Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\", O'Reilly Verlag</li> <li>Joshua Bloch: \"Effective Java. Best practices for the Java platform\", Pearson Education Inc.</li> <li>Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\", Prentice Hall</li> <li>und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...</li> </ul>"},{"location":"tools/#java","title":"Java","text":"<p>Wir verwenden die Programmiersprache Java, um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. </p> <p>Java besteht aus 2 Teilen:</p> <ul> <li>der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung)</li> <li>dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung)</li> </ul> <p>Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. </p> <p>Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - <code>java -version</code> und <code>javac -version</code> - siehe folgend). </p> <p>Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu</p> <pre><code>java -version\n</code></pre> <p>ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her):</p> <pre><code>openjdk version \"22.0.2\" 2024-07-16\nOpenJDK Runtime Environment (build 22.0.2+9-70)\nOpenJDK 64-Bit Server VM (build 22.0.2+9-70, mixed mode, sharing)\n</code></pre> <p>Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler (<code>javac</code>) auf:</p> <pre><code>javac -version\n</code></pre> <p>Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her):</p> <pre><code>javac 22.0.2\n</code></pre> <p>Success</p> <p>Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler, der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.</p>"},{"location":"tools/#ide","title":"IDE","text":"<p>Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE), eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird (Syntx-Highlighting) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden (Intelligent Code Completion). </p>"},{"location":"tools/#eclipse","title":"Eclipse","text":"<p>Sie sind in der Wahl Ihrer IDE frei. Eine sehr gute IDE ist Eclipse. Eclipse ist in Java geschrieben und Open-Source. Das ist auch der Grund, warum wir Eclipse verwenden und nicht IntelliJ. Den Download-Link f\u00fcr Eclipse finden Sie hier. Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers. Installieren Sie Eclipse am besten in ihrem Applications- oder Programme-Ordner. </p> <ol> <li>Starten Sie Eclipse durch Doppelklick auf das Programmsymbol.</li> <li>Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen.</li> <li>Anlegen eines Projektordners:<ul> <li>Auswahl im Men\u00fc <code>File--&gt;New--&gt;Java Project</code>.</li> <li>Eingabe des <code>Project name:</code> Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2). Wenn Sie gefragt werden, ob Sie ein <code>module-info.java</code> erstellen wollen, w\u00e4hlen Sie <code>Don't create</code>.</li> <li>Klicken auf den Button <code>Finish</code>.</li> </ul> </li> <li>Erstellen eines neuen Packages (Paketes):<ul> <li>\u00d6ffnen der Projektmappe im <code>Package Explorer</code>.</li> <li>Auswahl des Ordners <code>src</code> mit der rechten Maustaste.</li> <li>Auswahl des Men\u00fcpunktes <code>New --&gt; Package</code>.</li> <li>Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. <code>themen.start</code>.</li> </ul> </li> <li>Erstellen einer neuen Klasse:<ul> <li>\u00d6ffnen der Projektmappe im Package Explorer.</li> <li>Auswahl des Paketes (z.B. <code>themen.start</code>) mit der rechten Maustaste.</li> <li>Auswahl des Menu\u0308punktes <code>New --&gt; Class</code>.</li> <li>Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. <code>HelloFIW</code>). Klassennamen werden immer gro\u00df geschrieben.</li> <li>Setzen des H\u00e4kchens bei <code>public static void main()</code>.</li> <li>Klicken auf den Button <code>Finish</code>.</li> </ul> </li> </ol> <p>Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:</p> <p></p>"},{"location":"tools/#intellij","title":"IntelliJ","text":"<p>Eine sehr h\u00e4ufig und im Bereich der Java-Entwicklung die derzeit wohl am meisten verwendete IDE ist IntelliJ IDEA. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Ultimate-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Die Download-Seite von IntelliJ IDEA finden Sie hier.</p> <p>Nach dem Start von IntelliJ IDEA klicken Sie auf <code>New project</code>. Es erscheint:</p> <p></p> <p>W\u00e4hlen Sie in der linken Spalte <code>Maven Archetype\" aus. Geben Sie Ihrem Projekt einen</code>Name<code>n (muss mit einem Buchstaben beginnen und darf keine Leerzeichen enthalten, vermeiden Sie auch Umlaute und Sonderzeichen). W\u00e4hlen als</code>Location<code>einen Ordner aus, in dem Sie Ihre selbstgeschriebenen Programme speichern wollen. Ein solcher Ordner k\u00f6nnte bei Ihnen z.B.</code>Documents/HTW/Programmierung/Prog1<code>sein. W\u00e4hlen Sie unter</code>Archetype<code>die Option</code>org.apache.maven.archetypes:maven-archetype-quickstart<code>aus. Klicken Sie dann auf</code>Create`. </p> <p>Es erscheint folgendes Fenster (Informationen, um das Theme in IntelliJ zu \u00e4ndern, finden Sie z.B. hier):</p> <p></p> <p>\u00d6ffnen Sie im Project explorer (linke Spalte) sukzessive die Ordner <code>src/main/java/org.example</code>. Doppelklicken Sie auf <code>App</code>. Im Editorfenster \u00f6ffnet sich unsere erste Java-Klasse <code>App.java</code>. Klicken Sie in der Werkzeugleiste auf den gr\u00fcnen Pfeil neben dem Textfeld, in dem <code>Current file</code> steht. Im unteren Terminalfenster erscheint <code>Hello World!</code>.</p>"},{"location":"tools/#visual-studio-code","title":"Visual Studio Code","text":"<p>Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code (VS Code) arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Sp\u00e4testens im dritten Semster in WebTech werden die meisten von Ihnen entweder auf IntelliJ oder VS Code wechseln. Im Bereich der Web-Entwicklung ist VS Code sicherlich die am meisten verwendete IDE. </p>"},{"location":"tools/#weitere-nutzliche-werkzeuge","title":"Weitere n\u00fctzliche Werkzeuge","text":""},{"location":"tools/#windows-gitbash","title":"Windows: gitBash","text":"<p>Das Terminal (<code>cmd</code>) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows. Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.46.0-64-bit.exe und folgen dann den Installationsanweisungen. </p>"},{"location":"tools/#online-kurse","title":"Online-Kurse","text":"<ul> <li>JetBrains Academy https://lp.jetbrains.com/de-de/academy/learn-java/</li> </ul>"},{"location":"uebungen/","title":"\u00dcbungen","text":""},{"location":"uebungen/#ubungsblatter-wochenweise","title":"\u00dcbungsbl\u00e4tter (wochenweise)","text":"\u00dcbung 0 <ol> <li>Installieren Sie sich - falls noch nicht geschehen - eine Java-Entwicklungsumgebung (siehe Java).</li> <li>Installieren Sie sich die IDE Ihrer Wahl (siehe IDE). In den Vorlesungen und \u00dcbungen verwende ich Eclipse und beschreibe die Schritte auch f\u00fcr Eclipse.</li> <li>Starten Sie Eclipse durch Doppelklick auf das Programmsymbol.</li> <li>Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. <code>Prog1</code>) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen.</li> <li>Anlegen eines Projektordners:<ul> <li>Auswahl im Men\u00fc <code>File--&gt;New--&gt;Java Project</code>.</li> <li>Eingabe des <code>Project name:</code> Name des Projektes (z.B. <code>WiSe24</code>). Klicken auf den Button <code>Finish</code>.</li> <li>Das Fenster <code>New module-info.java</code> k\u00f6nnen Sie einfach mit <code>Create</code> best\u00e4tigen.</li> </ul> </li> <li>Erstellen eines neuen Packages (Paketes):<ul> <li>\u00d6ffnen der Projektmappe im <code>Package Explorer</code>.</li> <li>Auswahl des Ordners <code>src</code> mit der rechten Maustaste.</li> <li>Auswahl des Men\u00fcpunktes <code>New --&gt; Package</code>.</li> <li>Geben Sie folgenden Paketnamen ein (Paketnamen werden kleingeschrieben) <code>uebungen.uebung0</code> (Achten Sie auf den Punkt und dass Sie alles zusammen schreiben).</li> </ul> </li> <li>Erstellen einer neuen Klasse:<ul> <li>\u00d6ffnen der Projektmappe im Package Explorer.</li> <li>Auswahl des Paketes (<code>uebungen.uebung0</code>) mit der rechten Maustaste.</li> <li>Auswahl des Menu\u0308punktes <code>New --&gt; Class</code>.</li> <li>Eingabe des Namens, der gleichzeitig der Klassen- und Dateiname ist: <code>Uebung0</code>. Klassennamen werden immer gro\u00df geschrieben.</li> <li>Setzen des H\u00e4kchens bei <code>public static void main()</code>. (Sollten Sie vergessen haben, das H\u00e4kchen zu setzen, dann ist die Klasse, nachdem Sie <code>Finish</code> gedr\u00fcckt haben, leer. Setzen Sie dann den Cursor zwischen die beiden geschweiften Klammern <code>{ }</code>, geben dann <code>main</code> ein und dr\u00fccken die Ctrl+Leer-Tasten und anschlie\u00dfend Enter. Dann erscheint die <code>main()</code>-Methode)</li> <li>Klicken auf den Button <code>Finish</code>.</li> </ul> </li> <li>In die <code>main()</code>-Methode (zwischen die geschweiften Klammern <code>{</code> und <code>}</code> geben    Sie ein: <code>System.out.println(\"Uebung 0\"));</code>.</li> <li>Dr\u00fccken Sie dann entweder auf den -Button oder         w\u00e4hlen Sie aus dem Men\u00fc <code>Run --&gt; Run</code> oder dr\u00fccken Sie shift+command+f11. In der <code>Console</code> in Ihrer IDE (in Eclipse unten) erscheint <code>Uebung 0</code>. </li> </ol> Uebung0.java <pre><code>package uebungen.uebung0;\n\npublic class Uebung0\n{\n    public static void main(String[] args)\n    {\n        System.out.println(\"Uebung 0\");\n    }\n}\n</code></pre> <p>Success</p> <p>Fertig! Ihre Entwicklungsumgebung ist bereit! Wir k\u00f6nnen loslegen. </p> \u00dcbung 1 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung1</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung1</code> mit <code>main()</code>-Methode.</li> <li>Deklarieren und initialisieren Sie in der <code>main()</code>-Methode jeweils eine Variable mit dem Datentyp <code>int</code>, <code>long</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>boolean</code> und <code>String</code>. Geben Sie alle Werte einzeln durch Aufruf der <code>println()</code>-Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): <pre><code>Wert vom Typ int        :   123\nWert vom Typ long       :   456789\nWert vom Typ char       :   a\nWert vom Typ byte       :   127\nWert vom Typ short      :   32767\nWert vom Typ float      :   4.23\nWert vom Typ double     :   6.98\nWert vom Typ boolean    :   true\nWert vom Typ String     :   Hallo!\n</code></pre></li> <li>Setzen Sie den Wert Ihrer <code>int</code>-Variablen auf <code>2147483647</code>. Geben Sie den Wert auf der Konsole aus, z.B.:   <pre><code>Wert von i  :   2147483647\n</code></pre> Versuchen Sie nun den Wert auf <code>2147483648</code> zu setzen. Was passiert? Warum?</li> <li>Wiederholen Sie das gleiche mit einer <code>long</code>-Variablen.</li> <li>Weisen Sie Ihrer <code>char</code>-Variablen den Wert <code>65</code> zu. Geben Sie den Wert Ihrer <code>char</code>-Variablen aus. Was passiert? Warum?</li> <li> <p>Gegeben ist die folgende Klasse:</p> <pre><code>public class PrinterClass \n{\n\n    public static void main(String[] args) \n    {\n        System.out.print(\"answer=\");\n        System.out.println(42);\n    }\n}\n</code></pre> <p>Was wird auf der Konsole ausgegeben? a) <pre><code>answer=42\n</code></pre> b) <pre><code>answer=\n42\n</code></pre> c) <pre><code>answer\n=\n42\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 1 <pre><code>package uebungen.uebung1;\n\npublic class Uebung1\n{\n    public static void main(String[] args)\n    {\n        int in = 123;\n        long lo = 456789;\n        char ch = 'a';\n        byte by = 127;\n        short sh = 32767;\n        float fl = 4.23f;       // f notwendig\n        double d1 = 6.98;\n        boolean b1 = true;\n        String s1 = \"Hallo!\";\n\n        System.out.println(\" --- Aufgabe 3 -------\");\n        System.out.println();\n        System.out.print(\"Wert vom Typ int     : \");\n        System.out.println(in);\n        System.out.print(\"Wert vom Typ long    : \");\n        System.out.println(lo);\n        System.out.print(\"Wert vom Typ char    : \");\n        System.out.println(ch);\n        System.out.print(\"Wert vom Typ byte    : \");\n        System.out.println(by);\n        System.out.print(\"Wert vom Typ short   : \");\n        System.out.println(sh);\n        System.out.print(\"Wert vom Typ float   : \");\n        System.out.println(fl);\n        System.out.print(\"Wert vom Typ double  : \");\n        System.out.println(d1);\n        System.out.print(\"Wert vom Typ boolean : \");\n        System.out.println(b1);\n        System.out.print(\"Wert vom Typ String  : \");\n        System.out.println(s1);\n\n        System.out.println();\n        System.out.println(\" --- Aufgabe 4 -------\");\n        System.out.println();\n        in = 2147483647;\n        System.out.println(\"Wert vom Typ int     : \" + in );\n        //in = 2147483648;      // Compilerfehler out of range\n\n        System.out.println();\n        System.out.println(\" --- Aufgabe 5 -------\");\n        System.out.println();\n        lo = 2147483647;    \n        System.out.println(\"Wert vom Typ long    : \" + lo );\n        lo = 2147483648L;       // L notwendig, da 2147483648 kein int  \n        System.out.println(\"Wert vom Typ long    : \" + lo );\n\n        System.out.println();\n        System.out.println(\" --- Aufgabe 6 -------\");\n        System.out.println();\n        ch = 65;\n        System.out.println(ch);     // A\n\n        // 7 a)     \n    }\n\n}\n</code></pre> \u00dcbung 2 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung2</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung2</code> mit <code>main()</code>-Methode.</li> <li> <p>Deklarieren Sie in <code>main()</code> 2 <code>int</code>-Variablen und geben Sie Ihnen Werte (die folgenden Werte <code>17</code> und <code>4</code> sind nur Beispiele). Erzeugen Sie nun unter Verwendung dieser Variablen folgende Ausgabe (bei anderen Werten nat\u00fcrlich entsprechend anders): <pre><code>17 geteilt durch 4 ergibt 4. Es bleibt ein Rest von 1\n</code></pre></p> </li> <li> <p>Erzeugen Sie nun stattdessen folgende Ausgabe:  <pre><code>17/4 = 4\n17 mod 4 = 1\n</code></pre></p> </li> <li> <p>Beachten Sie, dass Sie den Wert f\u00fcr den Quotienten und f\u00fcr den Rest f\u00fcr <code>3.</code> und <code>4.</code> nur einmal ermitteln sollen.</p> </li> <li> <p>Deklarieren Sie sich eine <code>boolean</code>-Variable. Der Wert der Variablen soll <code>true</code> sein, wenn das Produkt der beiden <code>int</code>-Variablen aus <code>3.</code> gerade ist und <code>false</code>, wenn es ungerade ist. </p> </li> <li> <p>Probieren Sie die Dvision <code>100/3</code> in den folgenden Datentypen: <code>int</code>, <code>float</code>, <code>double</code>. Was stellen Sie fest? </p> </li> <li> <p>Pr\u00fcfen Sie, ob die letzte Ziffer von 2 <code>int</code>-Variablen gleich ist (dann <code>true</code>, sonst <code>false</code>). </p> </li> <li> <p>Zusatz: Gegeben sei eine Anzahl von Stunden. Geben Sie aus, wieviel ganze Tage in dieser Anzahl enthalten sind, z.B.  <pre><code>In 34567 Stunden sind 1440 ganze Tage enthalten.\n</code></pre> Wieviele Stunden bleiben \u00fcbrig?  <pre><code>Zieht man von den 34567 Stunden die 1440 Tage ab, bleiben 7 Stunden \u00fcbrig.\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 <pre><code>package uebungen.uebung2;\n\npublic class Uebung2\n{\n\n    public static void main(String[] args)\n    {\n        System.out.println();\n        System.out.println(\"-------------------- 3. -------------------------\");\n        System.out.println();\n        int i1 = 77;\n        int i2 = 5;\n        int quotient = i1/i2;\n        int rest = i1%i2;\n\n        System.out.print(i1 + \" geteilt durch \" + i2 + \" ergibt \" + quotient + \". \");\n        System.out.println(\"Es bleibt ein Rest von \" + rest + \".\");\n\n        System.out.println();\n        System.out.println(\"-------------------- 4. -------------------------\");\n        System.out.println();\n\n        System.out.println(i1 + \"/\" + i2 + \" = \" + quotient);\n        System.out.println(i1 + \" mod \" + i2 + \" = \" + rest);\n\n        System.out.println();\n        System.out.println(\"-------------------- 6. -------------------------\");\n        System.out.println();\n\n        int product = i1 * i2;\n        boolean productIsEven = product % 2 == 0;\n        boolean productIsOdd = !productIsEven;      // product % 2 == 1\n\n        System.out.println(product + \" ist gerade   ? \" + productIsEven);\n        System.out.println(product + \" ist ungerade ? \" + productIsOdd);\n\n\n        System.out.println();\n        System.out.println(\"-------------------- 7. -------------------------\");\n        System.out.println();\n\n        System.out.println(\"int    : \" + 100/3);        // int\n\n        System.out.println(\"float  : \" + 100.0f/3.0f);  // float\n        System.out.println(\"float  : \" + 100f/3f);      // float\n\n        System.out.println(\"double : \" + 100.0/3.0);    // double\n        System.out.println(\"double : \" + 100.0/3);      // double\n        System.out.println(\"double : \" + 100/3.0);      // double\n\n        System.out.println();\n        System.out.println(\"-------------------- 8. -------------------------\");\n        System.out.println();\n\n        int lastDigitOfi1 = i1 % 10;\n        int lastDigitOfi2 = i2 % 10;\n        boolean lastDigitsAreEqual = (lastDigitOfi1 == lastDigitOfi2);\n\n        System.out.println();\n        System.out.println(\"-------------------- 9. -------------------------\");\n        System.out.println();\n\n        int hours = 34567;\n        int oneDay = 24;\n        int days = hours/oneDay;\n\n        System.out.println(\"In \" + hours + \" Stunden sind \" + days + \" ganze Tage enthalten.\");\n        System.out.println(\"Zieht man von den \" + hours + \" Stunden die \" + days + \" Tage ab, \"\n                + \"bleiben \" + hours%oneDay + \" Stunden \u00fcbrig.\");\n\n    }\n\n}\n</code></pre> \u00dcbung 2a (1.11.2024) <ol> <li>Verwenden Sie erneut die Klasse <code>Uebung2</code> aus dem Paket <code>uebungen.uebung2</code> (oder Sie erstellen sich ein Paket <code>uebungen.uebung2.a</code> und darin eine Klasse <code>Uebung2a</code>).</li> <li> <p>Schreiben Sie eine Methode  <pre><code>public static void printIntDivision(int nr1, int nr2) \n{\n}\n</code></pre> Diese Methode soll folgende Ausgabe auf die Konsole erzeugen, z.B. f\u00fcr <code>printIntDivision(7, 4);</code> die Ausgabe  <pre><code>7 geteilt durch 4 ergibt 1. Es bleibt ein Rest von 3\n</code></pre> z.B. f\u00fcr <code>printIntDivision(17, 4);</code> die Ausgabe <pre><code>17 geteilt durch 4 ergibt 4. Es bleibt ein Rest von 1\n</code></pre> Falls kein Rest bleibt, soll die Ausgabe sein: <pre><code>16 geteilt durch 4 ergibt 4. Es bleibt kein Rest.\n</code></pre> Rufen Sie die Methode entsprechend in der <code>main()</code>-Methode auf! Zusatz: Pr\u00fcfen Sie, ob der Wert von <code>nr2</code> ungleich <code>0</code> ist. Nur dann ist die Division definiert. Sollte er <code>0</code> sein, geben Sie <code>Division durch 0 ist nicht definiert!</code> auf die Konsole aus. </p> </li> <li> <p>Schreiben Sie zwei Methoden  <pre><code>public static int getQuotient(int nr1, int nr2) {} // und \npublic static int getRemainder(int nr1, int nr2) {}\n</code></pre> Rufen Sie diese Methoden in der <code>main()</code>-Methode auf generieren mit den Aufrufen und unter Verwendung der <code>println()</code>-Methode folgende Ausgaben:  <pre><code>17/4 = 4\n17 mod 4 = 1\n</code></pre></p> </li> <li> <p>Besitzen die folgende Methodenaufrufe einem Wert? Wenn ja, welcher?</p> <ul> <li><code>printIntDivision(17, 4);</code></li> <li><code>getQuotient(17,4);</code></li> <li><code>getRemainder(17,4);</code></li> </ul> </li> <li> <p>K\u00f6nnen wir die Methoden <code>getQuotient(int nr1, int nr2)</code> und <code>getRemainder(int nr1, int nr2)</code> auch in der <code>printIntDivision(int nr1, int nr2)</code>-Methode verwenden/aufrufen? Wenn ja, wie?</p> </li> <li>Schreiben Sie eine Methode <code>lastDigitsAreEqual(int nr1, int nr2)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn <code>nr1</code> und <code>nr2</code> dieselbe letzte Ziffer haben und <code>false</code> sonst.  Zusatz: Schreiben Sie eine Methode <code>last2DigitsAreEqual(int nr1, int nr2)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn <code>nr1</code> und <code>nr2</code> dieselben letzten 2 Ziffern haben. </li> <li>Schreiben Sie eine Methode <code>getDays(int hours)</code>, die f\u00fcr eine gegebene Stundenanzahl <code>hours</code> zur\u00fcckgibt, wieviele ganze Tage diese Studnden entsprechen. Schreiben Sie eine Methode <code>getRemainingHours(int hours)</code>, die f\u00fcr eine gegebene Stundenanzahl <code>hours</code> zur\u00fcckgibt, wieviele Stunden noch verbleiben, wenn man die ganzen Tage darin abzieht. Erstellen Sie in <code>main()</code> mit diesen Methoden und der <code>println()</code>-Methode folgende Ausgaben auf der Konsole (Beispielwerte): <pre><code>In 34567 Stunden sind 1440 ganze Tage enthalten.\n</code></pre> Wieviele Stunden bleiben \u00fcbrig?  <pre><code>Zieht man von den 34567 Stunden die 1440 Tage ab, bleiben 7 Stunden \u00fcbrig.\n</code></pre> Zusatz: \u00c4ndern Sie <code>main()</code> so, dass f\u00fcr den Fall, dass die Gesamtanzahl der Stunden keinen ganzen Tag enth\u00e4lt, folgende Ausgabe erscheint:      <pre><code>In 22 Stunden ist kein ganzer Tag enthalten. \n</code></pre>     Es soll dann auch keine Ausgabe bez\u00fcglich der \u00fcbrig bleibenden Stunden erscheinen.  </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2a <pre><code>package uebungen.uebung2.a;\n\npublic class Uebung2a\n{\n    public static void printIntDivision(int nr1, int nr2) \n    {       \n        if(nr2 == 0)\n        {\n            System.out.println(\"Division durch 0 nicht definiert!\");\n        }\n        else    // nr2 != 0\n        {\n            // int quotient = nr1 / nr2;\n            int quotient = getQuotient(nr1, nr2);\n            // int rest = nr1 % nr2;\n            int rest = getRemainder(nr1, nr2);\n\n            System.out.print(nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \".\");\n\n            if(rest != 0 )\n            {\n                System.out.println(\" Es bleibt ein Rest von \" + rest + \".\");\n            }\n            else    // rest == 0\n            {\n                System.out.println(\" Es bleibt kein Rest.\");\n            }\n        }   // else nr2 != 0\n    }\n\n    public static int getQuotient(int nr1, int nr2)\n    {\n        return nr1 / nr2;\n    }\n\n    public static int getRemainder(int nr1, int nr2)\n    {\n        return nr1 % nr2;\n    }\n\n    public static boolean lastDigitsAreEqual(int nr1, int nr2)\n    {\n        int lastDigitOfNr1 = nr1 % 10;\n        int lastDigitOfNr2 = nr2 % 10;\n        return (lastDigitOfNr1 == lastDigitOfNr2);\n    }\n\n    public static int getDays(int hours)\n    {\n        int oneDay = 24;\n        return hours / oneDay;\n    }\n\n    public static int getRemainingHours(int hours)\n    {\n        int oneDay = 24;\n        return hours % oneDay;\n    }\n\n    public static void printHours2Days(int hours)\n    {\n        int days = getDays(hours);\n        int remainingHours = getRemainingHours(hours);\n\n        if(days &gt; 0)\n        {\n            System.out.println(\"In \" + hours + \" Stunden sind \" + days \n                + \" ganze Tage enthalten.\");\n            System.out.println(\"Zieht man von den \" + hours + \" Stunden die \" \n                + days + \" Tage ab, bleiben \" + remainingHours + \" Stunden \u00fcbrig.\");\n        }\n        else // days == 0\n        {\n            System.out.println(\"In \" + hours + \" Stunden ist kein ganzer Tag enthalten.\");\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.println();\n        System.out.println(\"--------------- 2. ----------------\");\n        System.out.println();\n\n        printIntDivision(17, 4);\n        printIntDivision(16, 4);\n        printIntDivision(16, 0);\n\n        System.out.println();\n        System.out.println(\"--------------- 3. ----------------\");\n        System.out.println();\n\n        int nr1 = 17;\n        int nr2 = 4;\n        System.out.println(nr1 + \"/\" + nr2 + \" = \" + getQuotient(nr1, nr2));\n        System.out.println(nr1 + \" mod \" + nr2 + \" = \" + getRemainder(nr1, nr2));\n\n        nr1 = 15;\n        nr2 = 5;\n        System.out.println(nr1 + \"/\" + nr2 + \" = \" + getQuotient(nr1, nr2));\n        System.out.println(nr1 + \" mod \" + nr2 + \" = \" + getRemainder(nr1, nr2));\n\n\n        System.out.println();\n        System.out.println(\"--------------- 6. ----------------\");\n        System.out.println();\n\n        System.out.println(nr1 + \", \" + nr2 + \" ? \" + lastDigitsAreEqual(nr1, nr2));\n        nr1 = 123;\n        nr2 = 3;\n        System.out.println(nr1 + \", \" + nr2 + \" ? \" + lastDigitsAreEqual(nr1, nr2));\n\n        System.out.println();\n        System.out.println(\"--------------- 7. ----------------\");\n        System.out.println();\n\n        int hours = 34567;\n        // hours = 22;\n        int days = getDays(hours);\n        int remainingHours = getRemainingHours(hours);\n\n        if(days &gt; 0)\n        {\n            System.out.println(\"In \" + hours + \" Stunden sind \" + days \n                + \" ganze Tage enthalten.\");\n            System.out.println(\"Zieht man von den \" + hours + \" Stunden die \" \n                + days + \" Tage ab, bleiben \" + remainingHours + \" Stunden \u00fcbrig.\");\n        }\n        else // days == 0\n        {\n            System.out.println(\"In \" + hours + \" Stunden ist kein ganzer Tag enthalten.\");\n        }\n\n        printHours2Days(34567);\n        printHours2Days(22);\n    }\n\n}\n</code></pre> \u00dcbung 3 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung3</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung3</code> mit <code>main()</code>-Methode.</li> <li> <p>Schreiben Sie eine Methode <code>public static void printTimesTables(int nr1, int nr2)</code>. Bei Aufruf der Methode z.B. f\u00fcr <code>printTimesTables(10,10);</code> soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden:</p> Ausgabe f\u00fcr printTimesTables(10,10); <pre><code>1 * 1 = 1\n1 * 2 = 2\n1 * 3 = 3\n1 * 4 = 4\n1 * 5 = 5\n1 * 6 = 6\n1 * 7 = 7\n1 * 8 = 8\n1 * 9 = 9\n1 * 10 = 10\n\n2 * 1 = 2\n2 * 2 = 4\n2 * 3 = 6\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n2 * 8 = 16\n2 * 9 = 18\n2 * 10 = 20\n\n3 * 1 = 3\n3 * 2 = 6\n3 * 3 = 9\n3 * 4 = 12\n3 * 5 = 15\n3 * 6 = 18\n3 * 7 = 21\n3 * 8 = 24\n3 * 9 = 27\n3 * 10 = 30\n\n4 * 1 = 4\n4 * 2 = 8\n4 * 3 = 12\n4 * 4 = 16\n4 * 5 = 20\n4 * 6 = 24\n4 * 7 = 28\n4 * 8 = 32\n4 * 9 = 36\n4 * 10 = 40\n\n5 * 1 = 5\n5 * 2 = 10\n5 * 3 = 15\n5 * 4 = 20\n5 * 5 = 25\n5 * 6 = 30\n5 * 7 = 35\n5 * 8 = 40\n5 * 9 = 45\n5 * 10 = 50\n\n6 * 1 = 6\n6 * 2 = 12\n6 * 3 = 18\n6 * 4 = 24\n6 * 5 = 30\n6 * 6 = 36\n6 * 7 = 42\n6 * 8 = 48\n6 * 9 = 54\n6 * 10 = 60\n\n7 * 1 = 7\n7 * 2 = 14\n7 * 3 = 21\n7 * 4 = 28\n7 * 5 = 35\n7 * 6 = 42\n7 * 7 = 49\n7 * 8 = 56\n7 * 9 = 63\n7 * 10 = 70\n\n8 * 1 = 8\n8 * 2 = 16\n8 * 3 = 24\n8 * 4 = 32\n8 * 5 = 40\n8 * 6 = 48\n8 * 7 = 56\n8 * 8 = 64\n8 * 9 = 72\n8 * 10 = 80\n\n9 * 1 = 9\n9 * 2 = 18\n9 * 3 = 27\n9 * 4 = 36\n9 * 5 = 45\n9 * 6 = 54\n9 * 7 = 63\n9 * 8 = 72\n9 * 9 = 81\n9 * 10 = 90\n\n10 * 1 = 10\n10 * 2 = 20\n10 * 3 = 30\n10 * 4 = 40\n10 * 5 = 50\n10 * 6 = 60\n10 * 7 = 70\n10 * 8 = 80\n10 * 9 = 90\n10 * 10 = 100\n</code></pre> Ausgabe f\u00fcr printTimesTables(3,7); <pre><code>1 * 1 = 1\n1 * 2 = 2\n1 * 3 = 3\n1 * 4 = 4\n1 * 5 = 5\n1 * 6 = 6\n1 * 7 = 7\n\n2 * 1 = 2\n2 * 2 = 4\n2 * 3 = 6\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n\n3 * 1 = 3\n3 * 2 = 6\n3 * 3 = 9\n3 * 4 = 12\n3 * 5 = 15\n3 * 6 = 18\n3 * 7 = 21\n</code></pre> </li> <li> <p>Schreiben Sie eine Methode <code>public static void printTimesMatrix(int nr1, int nr2)</code>. Bei Aufruf der Methode z.B. f\u00fcr printTimesMatrix(10,10) soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden:</p> Ausgabe f\u00fcr printTimesMatrix(10,10); <pre><code> 1  2  3  4  5  6  7  8  9  10 \n 2  4  6  8  10  12  14  16  18  20 \n 3  6  9  12  15  18  21  24  27  30 \n 4  8  12  16  20  24  28  32  36  40 \n 5  10  15  20  25  30  35  40  45  50 \n 6  12  18  24  30  36  42  48  54  60 \n 7  14  21  28  35  42  49  56  63  70 \n 8  16  24  32  40  48  56  64  72  80 \n 9  18  27  36  45  54  63  72  81  90 \n 10  20  30  40  50  60  70  80  90  100 \n</code></pre> Ausgabe f\u00fcr printTimesMatrix(3,7); <pre><code> 1  2  3  4  5  6  7   \n 2  4  6  8  10  12  14   \n 3  6  9  12  15  18  21  \n</code></pre> </li> <li> <p>Schreiben Sie eine Methode <code>public static void printTriangleUp(int height)</code>. Bei Aufruf der Methode z.B. f\u00fcr <code>printTriangleUp(7)</code> soll folgende Ausgabe erscheinen:     <pre><code>*******\n******\n*****\n****\n***\n**\n*\n</code></pre></p> </li> <li> <p>Geben Sie alle m\u00f6glichen Kombinationen f\u00fcr 3 ganze Zahlen <code>x</code>, <code>y</code> und <code>z</code> aus, f\u00fcr die gilt:     <pre><code>x &lt;= y &lt;= z und\nx * y * z = 36\n</code></pre></p> <p>Gen\u00fcgt bis hierher. Ab hier Zusatz nur f\u00fcr diejenigen, die bereits fr\u00fcher fertig sind.</p> </li> <li> <p>Zusatz Schreiben Sie eine Umrechnung f\u00fcr eine gegebene Anzahl von Sekunden (<code>printSeconds(int seconds)</code>), z.B. <code>printSeconds(3456789)</code>:     <pre><code>3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden.\n</code></pre>     Aber z.B. <code>printSeconds(2345678)</code>:     <pre><code>2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden.\n</code></pre>     Aber z.B. <code>printSeconds(123456)</code>:     <pre><code>123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden.\n</code></pre>     Aber z.B. <code>printSeconds(12345)</code>:     <pre><code>12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden.\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 <pre><code>package uebungen.uebung3;\n\npublic class Uebung3\n{\n    public static void printTimesTables(int nr1, int nr2)\n    {\n        for(int factor1 = 1; factor1 &lt;= nr1; factor1++)\n        {\n            //System.out.println();\n            //System.out.println(\"factor1 : \" + factor1);\n            //System.out.println(\"--&gt; vor innerer Schleife\");\n\n            for(int factor2 = 1; factor2 &lt;= nr2; factor2++)\n            {\n                //System.out.println(\"            factor2 : \" + factor2);\n                int product = factor1 * factor2;\n                System.out.println(factor1 + \" * \" + factor2 + \" = \" + product);\n            }\n\n            //System.out.println(\"--&gt; nach innerer Schleife\");\n            System.out.println();\n        }\n    }\n\n    public static void printTimesMatrix(int nr1, int nr2)\n    {\n        for(int factor1 = 1; factor1 &lt;= nr1; factor1++)\n        {\n            for(int factor2 = 1; factor2 &lt;= nr2; factor2++)\n            {\n                System.out.print(factor1 * factor2 + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void printTriangleUp(int height)\n    {\n        for(int row = 0; row &lt; height; row++)\n        {\n            System.out.print(\" Zeile \" + row + \" : \");\n            for(int stars = 1; stars &lt;= height-row; stars++)\n            {\n                System.out.print(\"* \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        System.out.println();\n        System.out.println(\"----------------- 3. --------------------\");\n        System.out.println();\n        printTimesTables(10,10);\n        printTimesTables(3,7);\n\n        System.out.println();\n        System.out.println(\"----------------- 4. --------------------\");\n        System.out.println();\n        printTimesMatrix(10,10);\n        printTimesMatrix(3,7);\n\n        System.out.println();\n        System.out.println(\"----------------- 5. --------------------\");\n        System.out.println();\n        printTriangleUp(9);\n        printTriangleUp(4);\n\n\n        System.out.println();\n        System.out.println(\"----------------- 6. --------------------\");\n        System.out.println();\n\n        for(int x = -36; x &lt;= 36; x++)\n        {\n            for(int y = x; y &lt;= 36; y++)\n            {\n                for(int z = y; z &lt;= 36; z++)\n                {\n                    int product = x * y * z;\n                    //if(product == 36 &amp;&amp; x &lt;= y &amp;&amp; y &lt;= z)\n                    if(product == 36)\n                    {\n                        System.out.println(x + \" * \" + y + \" * \" + z + \" = \" + product );\n                    }\n                }\n            }\n        }\n    }\n\n}\n</code></pre> \u00dcbung 4 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung4</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung4</code> mit <code>main()</code>-Methode.</li> <li>Implementieren Sie folgende Methoden: <ul> <li><code>public static boolean isPrime(int number)</code> \u2013 diese Methode pr\u00fcft, ob die als Parameter \u00fcbergebene <code>number</code> eine Primzahl ist. Die Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>number</code> eine Primzahl ist und <code>false</code> sonst.</li> <li><code>public static void printPrimeNumbers(int maximum)</code> \u2013 diese Methode gibt alle Primzahlen von 1 bis einschlie\u00dflich <code>maximum</code> wie folgt auf der Konsole aus (Bsp. f\u00fcr <code>maximum=61</code>):     <pre><code>Zahl : 61\n.2 3 .5 .7 ...11 .13 ...17 .19 ...23 .....29 .31 .....37 ...41 .43 ...47 .....53 .....59 .61\n</code></pre>     d.h. es werden die Zahlen, die Primzahlen sind, ausgegeben und f\u00fcr die anderen Zahlen erscheint nur ein Punkt. Verwenden Sie in der Methode <code>printPrimenumbers(int)</code> die Methode <code>isPrime(int)</code>.</li> <li><code>public static int getSmallestDivider(int number)</code> \u2013 diese Methode gibt den kleinsten Teiler zur\u00fcck, der <code>number</code> ganzzahlig teilt. Ist <code>number</code> eine Primzahl, wird <code>number</code> zur\u00fcckgegeben. F\u00fcr den Fall, dass <code>number</code> kleiner als <code>2</code> ist, geben Sie ebenfalls <code>number</code> zur\u00fcck.</li> <li><code>public static String createStringOfPrimeFactorization(int number)</code> \u2013 diese Methode gibt einen String in folgender Form zur\u00fcck (Bsp. f\u00fcr <code>number=632060</code>):     <pre><code>\" 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060 \"\n</code></pre>     d.h. alle kleinsten Teiler werden mit dem Multiplikationszeichen verbunden und am Ende erscheint <code>= Wert von number</code>. </li> <li>Testen Sie alle Methoden. Rufen Sie insbesondere <code>printPrimenumbers(int)</code> und <code>createStringOfPrimeFactorization(int)</code> in der <code>main()</code>-Methode auf.</li> <li>Zusatz Schreiben Sie eine Methode, die f\u00fcr eine nat\u00fcrliche Zahl deren Quersumme ausgibt, z.B.: <code>crossSum(12345678)</code> <pre><code>Die Quersumme von 12345678 ist 36.\n</code></pre></li> </ul> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 4 <pre><code>package uebungen.uebung4;\n\n\npublic class Uebung4\n{\n\n    public static void main(String[] args)\n    {\n        System.out.println();\n        System.out.println(\"------------------ isPrime ------------------\");\n        System.out.println();\n\n        System.out.println(isPrime(17));\n        System.out.println(isPrime(121));\n\n        System.out.println();\n        System.out.println(\"--------------- printPrimeNumbers ----------------\");\n        System.out.println();\n        printPrimeNumbers(1000);\n\n        System.out.println();\n        System.out.println(\"--------------- createStringOfPrimeFactorization ----------------\");\n        System.out.println();\n        System.out.println(createStringOfPrimeFactorization(632030));\n    }\n\n    public static void printPrimeNumbers(int maximum)\n    {\n        for(int i = 1; i &lt;= maximum; i++)\n        {\n            if(isPrime(i))\n            {\n                System.out.print(i + \" \");\n            }\n            else\n            {\n                System.out.print(\".\");\n            }\n            if(i % 50 == 0)     // alle 50 Zahlen ein Zeilenumbruch\n            {\n                System.out.println();\n            }\n        }\n        System.out.println();\n    }\n\n    public static boolean isPrime(int number)\n    {\n        if(number &lt; 2)\n        {\n            return false;       // Methode wird sofort verlassen (keine Primzahl)\n        }\n        else\n        {\n            for(int divider = 2; divider &lt; number; divider++)\n            {\n                if(number % divider == 0)\n                {\n                    return false;   // Methode wird sofort verlassen (keine Primzahl)\n                }\n            }\n            return true;    // number ist Primzahl (kein divider war Teiler)\n        }\n    }\n\n    public static int getSmallestDivider(int number)\n    {\n        if(number &lt; 2 || isPrime(number))\n        {\n            return number;\n        }\n        else\n        {\n            for(int divider = 2; divider &lt; number; divider++)\n            {\n                if(number % divider == 0)\n                {\n                    return divider;     // ist immer eine Primzahl \n                                        // denn falls divider = a * b \n                                        // haetten wir schon a oder b zurueckgegeben\n                }\n            }\n            return number;  // wird gar nicht erreicht, weiss aber der Compiler nicht\n        }\n    }\n\n    public static String createStringOfPrimeFactorization(int number) \n    {\n        /*\n         * 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060\n         * 632060 --&gt; 2         (632060 / 2 --&gt; 316030)\n         * 316030 --&gt; 2         (316030 / 2 --&gt; 158015)\n         * 158015 --&gt; 5         (158015 / 5 --&gt; 31603)\n         * 31603 --&gt; 11         (31603 / 11 --&gt; 2873)\n         * ...\n         * 17 --&gt; 17            ( 17 / 17 --&gt; 1 schluss)\n         * \n         */\n\n        int smallestDivider = getSmallestDivider(number);\n        int quotient = number / smallestDivider;\n        String s = \"\" + smallestDivider;\n\n        // falls number ist Primzahl, wird Schleife gar nicht betreten\n        while(quotient &gt; 1)\n        {\n            smallestDivider = getSmallestDivider(quotient);\n            quotient = quotient / smallestDivider;\n            s = s + \" * \" + smallestDivider;\n        }\n\n        s = s  + \" = \" + number;\n        return s;\n    }\n\n}\n</code></pre> \u00dcbung 5 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung5</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Konto</code> (ohne <code>main()</code>-Methode!)</li> <li>Erstellen Sie in diesem package eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode    </li> <li>Erstellen Sie in der Klasse <code>Konto</code> zwei Objektvariablen<ul> <li><code>guthaben</code> vom Typ <code>double</code> \u2192 nur in der Klasse sichtbar!</li> <li><code>pin</code> vom Typ <code>int</code>   \u2192 ebenfalls nur in der Klasse sichtbar!</li> </ul> </li> <li>Erstellen Sie in der Klasse <code>Konto</code> einen Konstruktor f\u00fcr <code>Konto</code><ul> <li>diesem Konstruktor wird als Parameter <code>int pin</code> \u00fcbergeben</li> <li>mit dem Wert des Parameters wird innerhalb des Konstruktors der Wert von <code>pin</code> initialisiert</li> <li>Initialisieren Sie im Konstruktor auch die Objektvariable <code>guthaben</code>. Sie bekommt den Wert <code>0.0</code> (hierf\u00fcr haben wir also keinen Parameter, wir setzen den initialen Wert einfach generell auf <code>0.0</code>)</li> </ul> </li> <li>Erstellen Sie in der Klasse <code>Konto</code> eine Objektmethode <code>einzahlen(double betrag)</code><ul> <li>diese Objektmethode ist <code>public</code> und gibt nichts zur\u00fcck</li> <li>in dieser Methode wird der Wert der Objektvariablen <code>guthaben</code> um den Wert von <code>betrag</code> erh\u00f6ht</li> <li>erzeugen Sie in dieser Methode au\u00dferdem eine Ausgabe in der Form:     <pre><code>Es wurden 100,00 Euro eingezahlt.\n</code></pre>     falls der <code>betrag</code> den Wert <code>100.0</code> hatte. (Optional: Verwenden Sie am besten die <code>printf()</code>-Methode, um stets genau 2 Stellen nach dem Komma des Betrages auszugeben (siehe hier). </li> </ul> </li> <li>Geben Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein:     <pre><code>Konto k1 = new Konto(1234);\n\nk1.einzahlen(100.0);\nk1.einzahlen(50.0);\nk1.einzahlen(150.0);\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende Ausgaben erzeugt werden (falls <code>printf()</code> verwendet wird, ansonsten ist die Ausgabe z.B. <code>100.0 Euro</code>):     <pre><code>Es wurden 100,00 Euro eingezahlt.\nEs wurden 50,00 Euro eingezahlt.\nEs wurden 150,00 Euro eingezahlt.\n</code></pre></li> <li>Erstellen Sie in der Klasse <code>Konto</code> eine Objektmethode <code>kontoauszug(int pin)</code><ul> <li>diese Objektmethode ist <code>public</code> und gibt nichts zur\u00fcck</li> <li>einen <code>kontoauszug(int pin)</code> k\u00f6nnen Sie nur \"ziehen\", wenn der Parameterwert von <code>pin</code> mit dem Wert der Objektvariablen <code>pin</code> \u00fcbereinstimmt</li> <li>wird der richtige Wert f\u00fcr die <code>pin</code> \u00fcbergeben, geben Sie das <code>guthaben</code> in der folgenden Form aus:     <pre><code>Ihr aktuelles Guthaben betraegt 300,00 Euro.\n</code></pre>     falls <code>guthaben</code> den Wert von <code>300.0</code> hat. </li> <li>wird ein falscher Wert f\u00fcr die <code>pin</code> \u00fcbergeben, geben Sie folgende Ausgabe aus:     <pre><code>Falsche PIN!\n</code></pre></li> </ul> </li> <li>Erweitern Sie die <code>main()</code>-Methode der Testklasse um folgende Anweisungen:     <pre><code>k1.kontoauszug(1235);       // Falsche PIN!\nk1.kontoauszug(1234);   \n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende (weitere) Ausgaben erzeugt werden:     <pre><code>Falsche PIN!\nIhr aktuelles Guthaben betraegt 300,00 Euro.\n</code></pre></li> <li>Erstellen Sie in der Klasse <code>Konto</code> eine Objektmethode <code>auszahlen(int pin, double betrag)</code><ul> <li>diese Objektmethode ist <code>public</code> und gibt nichts zur\u00fcck</li> <li>es kann nur etwas ausgezahlt werden, wenn der Parameterwert von <code>pin</code> mit dem Wert der Objektvariablen <code>pin</code> \u00fcbereinstimmt</li> <li>stimmen die Werte nicht \u00fcberein, geben Sie erneut      <pre><code>Falsche PIN!\n</code></pre>     aus. </li> <li>stimmt der <code>pin</code>-Wert, dann m\u00fcssen Sie pr\u00fcfen, ob das <code>guthaben</code> reicht, um <code>betrag</code> auszuzahlen. Ist nicht genug <code>guthaben</code> vorhanden, dann geben Sie aus     <pre><code>Ihr Guthaben reicht nicht, um 400,00 Euro auszuzahlen.\n</code></pre>     falls <code>betrag</code> den Wert <code>400.0</code> hatte. </li> <li>wenn der <code>pin</code>-Wert stimmt und genug <code>guthaben</code> vorhanden ist, um den <code>betrag</code> auszuzahlen, dann reduzieren Sie <code>guthaben</code> um den entsprechenden <code>betrag</code> und geben aus     <pre><code>Es wurden 100,00 Euro ausgezahlt.\n</code></pre>     falls der <code>betrag</code> den Wert <code>100.0</code> hatte.</li> </ul> </li> <li>Erweitern Sie die <code>main()</code>-Methode der Testklasse um folgende Anweisungen:     <pre><code>k1.auszahlen(1235, 100.0);  // Falsche PIN!\nk1.auszahlen(1234, 100.0);  \nk1.kontoauszug(1234);       \nk1.auszahlen(1234, 300.0);  // Guthaben reicht nicht\nk1.auszahlen(1234, 200.0);  \nk1.kontoauszug(1234);   \n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende (weitere) Ausgaben erzeugt werden:     <pre><code>Falsche PIN!\nEs wurden 100,00 Euro ausgezahlt.\nIhr aktuelles Guthaben betraegt 200,00 Euro.\nIhr Guthaben reicht nicht, um 300,00 Euro auszuzahlen.\nEs wurden 200,00 Euro ausgezahlt.\nIhr aktuelles Guthaben betraegt 0,00 Euro.\n</code></pre></li> <li>Zusatz: <ul> <li>Erweitern Sie die Klasse um eine weitere Objektvariable <code>private double dispogrenze</code></li> <li>Initialisieren Sie diese Variable innerhalb des Konstruktors (ohne weiteren Parmeter) auf den Wert <code>-1000.0</code>. Sie d\u00fcrfen somit Ihr Konto um <code>1000.00 Euro</code> \u00fcberziehen.</li> <li>Passen Sie die <code>auszahlen()</code>-Methode entsprechend an, so dass es auch m\u00f6glich ist, einen <code>betrag</code> auszuzahlen, so lange man nicht unter die <code>dispogrenze</code> f\u00e4llt.</li> <li>Erstellen Sie eine Methode <code>public void zinsenZahlen()</code>.<ul> <li>Erstellen Sie in dieser Methode zwei Konstanten<ul> <li><code>DISPOZINSEN</code> vom Typ <code>double</code> bekommt den Wert <code>12.0</code> (soll <code>12%</code> entsprechen) und</li> <li><code>GUTHABENZINSEN</code> vom Typ <code>double</code> bekommt den Wert <code>0.5</code> (soll <code>0.5%</code> entsprechen) </li> </ul> </li> <li>Berechnen Sie innerhalb der Methode die Zinsen f\u00fcr das Konto<ul> <li><code>DISPOZINSEN</code> werden f\u00e4llig (werden von <code>guthaben</code> abgezogen), falls <code>guthaben</code> negativ ist</li> <li><code>GUTHABENZINSEN</code> werden gew\u00e4hrt (werden zu <code>guthaben</code> addiert), falls <code>guthaben</code> positiv ist</li> <li>passen Sie den Wert von <code>guthaben</code> entsprechend an</li> <li>erzeugen Sie entsprechende Ausgaben, z.B.      <pre><code>Ihnen wurden 18,00 Euro Zinsen abgebucht.\n</code></pre>     bzw.     <pre><code>Ihnen wurden 4,16 Euro Zinsen gutgeschrieben.\n</code></pre></li> </ul> </li> </ul> </li> <li>Angenommen, die gesamte <code>main()</code>-Methode sieht jetzt so aus:     <pre><code>public static void main(String[] args)\n{\n    Konto k1 = new Konto(1234);\n\n    k1.einzahlen(100.0);\n    k1.einzahlen(50.0);\n    k1.einzahlen(150.0);\n\n    k1.kontoauszug(1235);       // Falsche PIN!\n    k1.kontoauszug(1234);       \n\n    k1.auszahlen(1235, 100.0);  // Falsche PIN!\n    k1.auszahlen(1234, 100.0);  \n    k1.kontoauszug(1234);       \n    k1.auszahlen(1234, 300.0);  \n    k1.auszahlen(1234, 200.0);  \n    k1.kontoauszug(1234); \n\n    k1.einzahlen(150.0);\n    k1.kontoauszug(1234);       \n    k1.zinsenZahlen();\n    k1.kontoauszug(1234);       \n    k1.einzahlen(1000.0);\n    k1.kontoauszug(1234);       \n    k1.zinsenZahlen();\n    k1.kontoauszug(1234); \n}\n</code></pre>     dann sollten Sie folgende Ausgabe erzeugen (gilt nur f\u00fcr Zusatz!):     <pre><code>Es wurden 100,00 Euro eingezahlt.\nEs wurden 50,00 Euro eingezahlt.\nEs wurden 150,00 Euro eingezahlt.\nFalsche PIN!\nIhr aktuelles Guthaben betraegt 300,00 Euro.\nFalsche PIN!\nEs wurden 100,00 Euro ausgezahlt.\nIhr aktuelles Guthaben betraegt 200,00 Euro.\nEs wurden 300,00 Euro ausgezahlt.\nEs wurden 200,00 Euro ausgezahlt.\nIhr aktuelles Guthaben betraegt -300,00 Euro.\nEs wurden 150,00 Euro eingezahlt.\nIhr aktuelles Guthaben betraegt -150,00 Euro.\nIhnen wurden 18,00 Euro Zinsen abgebucht.\nIhr aktuelles Guthaben betraegt -168,00 Euro.\nEs wurden 1000,00 Euro eingezahlt.\nIhr aktuelles Guthaben betraegt 832,00 Euro.\nIhnen wurden 4,16 Euro Zinsen gutgeschrieben.\nIhr aktuelles Guthaben betraegt 836,16 Euro.\n</code></pre></li> </ul> </li> </ol> \u00dcbung 6 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung6</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Rectangle</code> (ohne <code>main()</code>-Methode!)</li> <li>Erstellen Sie in diesem package eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode    </li> <li> <p>Erstellen Sie in der Klasse <code>Rectangle</code> zwei Objektvariablen</p> <ul> <li><code>a</code> vom Typ <code>int</code> \u2192 nur in der Klasse sichtbar!</li> <li><code>b</code> vom Typ <code>int</code> \u2192 ebenfalls nur in der Klasse sichtbar!</li> </ul> <p><code>a</code> und <code>b</code> sollen die Seiten des Rechtecks sein. </p> </li> <li> <p>Implementieren Sie einen parameterlosen Konstruktor <code>Rectangle()</code>, der f\u00fcr die Seite <code>a</code> den Wert <code>10</code> und f\u00fcr die Seite <code>b</code> den Wert <code>20</code> setzt. </p> </li> <li>Implementieren Sie einen parametrisierten Konstruktor <code>Rectangle(int a, int b)</code>, der die Parameterwerte zum Initialisieren der Seiten verwendet. </li> <li>Implementieren Sie eine Objektmethode <code>public int area()</code>, die den Fl\u00e4cheninhalt des Rechtecks zur\u00fcckgibt. </li> <li>Implementieren Sie eine Objektmethode <code>public int perimeter()</code>, die den Umfang des Rechtecks zur\u00fcckgibt. </li> <li>Implementieren Sie eine Objektmethode <code>public String toString()</code>, die einen <code>String</code> mit allen Informationen des Rechtecks in der folgenden Form     <pre><code>Rectangle : ( a=10, b=20, area=200, perimeter=60 )\n</code></pre>     zur\u00fcckgibt. </li> <li>Implementieren Sie eine Objektmethode <code>public void print()</code>, die den durch <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</li> <li>Geben Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein:     <pre><code>// Objekte erzeugen\nRectangle r1 = new Rectangle();\nRectangle r2 = new Rectangle(12, 18);\nRectangle r3 = new Rectangle(40, 5);\nRectangle r4 = new Rectangle(20, 10);\nRectangle r5 = new Rectangle(11, 21);\n\nSystem.out.printf(\"%n%n--------------- print()-Methode -----------------%n%n\");\nr1.print();\nr2.print();\nr3.print();\nr4.print();\nr5.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende Ausgaben erzeugt werden:     <pre><code>--------------- print()-Methode -----------------\n\nRectangle : ( a=10, b=20, area=200, perimeter=60 )\nRectangle : ( a=12, b=18, area=216, perimeter=60 )\nRectangle : ( a=40, b= 5, area=200, perimeter=90 )\nRectangle : ( a=20, b=10, area=200, perimeter=60 )\nRectangle : ( a=11, b=21, area=231, perimeter=64 )\n</code></pre></li> <li>Implementieren Sie eine Objektmethode <code>public boolean sidesAreEqual(Rectangle r)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Seiten des aufrufenden Objektes gleich den Seiten des Rectangle <code>r</code> sind. Beachten Sie, dass das Rechteck auch gedreht noch gleiche Seiten haben soll, also <code>a=10, b=20</code> ist nicht nur mit <code>a=10, b=20</code> gleich, sondern auch mit <code>a=20, b=10</code>. Wenn die Seiten ungleich sind, gibt die Methode ein <code>false</code> zur\u00fcck.</li> <li>Implementieren Sie eine Objektmethode <code>public boolean areasAreEqual(Rectangle r)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Fl\u00e4cheninhalte des aufrufenden Objektes und des Rectangle <code>r</code> gleich sind. Ansonsten <code>false</code>.</li> <li>Implementieren Sie eine Objektmethode <code>public boolean perimetersAreEqual(Rectangle r)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Umf\u00e4nge des aufrufenden Objektes und des Rectangle <code>r</code> gleich sind. Ansonsten <code>false</code>.</li> <li>Implementieren Sie eine Objektmethode <code>public void printComparison(Rectangle r)</code>, die die Vergleiche mit <code>r</code> in der unten dargestellten Form ausgibt. Rufen Sie in der Methode die Methoden <code>print()</code> (oder <code>toString()</code>), <code>sidesAreEqual()</code>, <code>areasAreEqual()</code> und <code>perimetersAreEqual()</code> auf. </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n---------- printComparison()-Methode ------------%n%n\");\nr1.printComparison(r2);\nr1.printComparison(r3);\nr1.printComparison(r4);\nr1.printComparison(r5);\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>---------- printComparison()-Methode ------------\n\nthis      Rectangle : ( a=10, b=20, area=200, perimeter=60 ) \nthe other Rectangle : ( a=12, b=18, area=216, perimeter=60 ) \nsides are not equal \nareas are not equal \nperimeters are equal \n\nthis      Rectangle : ( a=10, b=20, area=200, perimeter=60 ) \nthe other Rectangle : ( a=40, b= 5, area=200, perimeter=90 ) \nsides are not equal \nareas are equal \nperimeters are not equal \n\nthis      Rectangle : ( a=10, b=20, area=200, perimeter=60 ) \nthe other Rectangle : ( a=20, b=10, area=200, perimeter=60 ) \nsides are equal \nareas are equal \nperimeters are equal \n\nthis      Rectangle : ( a=10, b=20, area=200, perimeter=60 ) \nthe other Rectangle : ( a=11, b=21, area=231, perimeter=64 ) \nsides are not equal \nareas are not equal \nperimeters are not equal \n</code></pre></p> </li> <li> <p>Zusatz: </p> <ul> <li>Implementieren Sie eine Objektmethode <code>public double diagonal()</code>, die die L\u00e4nge einer Diagonalen des Rechtecks zur\u00fcckgibt. </li> <li> <p>Erweitern Sie die <code>toString()</code>-Methode um die Ausgabe dieser L\u00e4nge wie folgt:     <pre><code>Rectangle : ( a=10, b=20, area=200, perimeter=60, diagonal=22,361 )\nRectangle : ( a=12, b=18, area=216, perimeter=60, diagonal=21,633 )\nRectangle : ( a=40, b= 5, area=200, perimeter=90, diagonal=40,311 )\nRectangle : ( a=20, b=10, area=200, perimeter=60, diagonal=22,361 )\nRectangle : ( a=11, b=21, area=231, perimeter=64, diagonal=23,707 )\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>public void scale(int factor)</code>. Diese Methode \"skaliert\" (vergr\u00f6\u00dfert oder verkleinert) das Rechteck um den Faktor <code>factor</code>, genauer gesagt, wird der Fl\u00e4cheninhalt um diesen Faktor skaliert (vergr\u00f6\u00dfert oder verkleinert). Die neuen Seiten sollen das gleiche Verh\u00e4ltnis zueinander haben, wie die alten Seiten. Geben Sie die neuen Seitenl\u00e4ngen in der folgenden Form auf die Konsole aus (siehe n\u00e4chsten Punkt <code>main()</code>).</p> </li> <li>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu: <pre><code>System.out.printf(\"%n%n--------------- scale()-Methode -----------------%n%n\");\nr1.scale(2);\nr2.scale(2);\nr3.scale(2);\nr4.scale(2);\nr5.scale(2);\nr1.scale(10);\nr2.scale(10);\nr3.scale(10);\nr4.scale(10);\nr5.scale(10);\n</code></pre> und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden: <pre><code>--------------- scale()-Methode -----------------\n\nnewArea=  400,00 newA= 14,14 newB= 28,28 check (newA*newB)= 400,00\nnewArea=  432,00 newA= 16,97 newB= 25,46 check (newA*newB)= 432,00\nnewArea=  400,00 newA= 56,57 newB=  7,07 check (newA*newB)= 400,00\nnewArea=  400,00 newA= 28,28 newB= 14,14 check (newA*newB)= 400,00\nnewArea=  462,00 newA= 15,56 newB= 29,70 check (newA*newB)= 462,00\nnewArea= 2000,00 newA= 31,62 newB= 63,25 check (newA*newB)=2000,00\nnewArea= 2160,00 newA= 37,95 newB= 56,92 check (newA*newB)=2160,00\nnewArea= 2000,00 newA=126,49 newB= 15,81 check (newA*newB)=2000,00\nnewArea= 2000,00 newA= 63,25 newB= 31,62 check (newA*newB)=2000,00\nnewArea= 2310,00 newA= 34,79 newB= 66,41 check (newA*newB)=2310,00\n</code></pre></li> </ul> <p>Sollte die <code>scale()</code>-Methode besser ein neues <code>Rectangle</code>-Objekt zur\u00fcckgeben? Wenn ja, dann implementieren Sie es so.</p> </li> </ol> \u00dcbung 7 <p>Info: Wir erstellen uns zwei neue Datentypen <code>Counter</code> und <code>Clock</code>. Die Idee der Klasse <code>Counter</code> soll sein, einen <code>counter</code> bis zu einem bestimmten <code>limit</code> hochzuz\u00e4hlen. Bevor der <code>counter</code> das <code>limit</code> erreicht, wird er wieder auf <code>0</code> gesetzt. Angenommen also das <code>limit</code> ist <code>60</code> und der <code>counter</code> hat den aktuellen Wert <code>59</code> und soll erh\u00f6ht werden, dann ist der n\u00e4chste Wert von <code>counter</code> wieder <code>0</code>, da das <code>limit</code> erreicht wurde. Die Klasse <code>Clock</code> verwendet zwei <code>Counter</code>-Objekte, eins f\u00fcr <code>hours</code> und das andere f\u00fcr <code>minutes</code>.</p> <ol> <li>Erstellen Sie ein package <code>uebungen.uebung7</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Counter</code> (ohne <code>main()</code>-Methode!)</li> <li>Erstellen Sie in diesem package eine Klasse <code>Programmklasse</code> mit <code>main()</code>-Methode    </li> <li> <p>Erstellen Sie in der Klasse <code>Counter</code> zwei Objektvariablen</p> <ul> <li><code>counter</code> vom Typ <code>int</code> \u2192 nur in der Klasse sichtbar!</li> <li><code>limit</code> vom Typ <code>int</code> \u2192 ebenfalls nur in der Klasse sichtbar!</li> </ul> </li> <li> <p>Erstellen Sie einen parametrisierten Konstruktor <code>public Counter(int limit)</code>, der den <code>counter</code> auf <code>0</code> initialisiert und das <code>limit</code> auf den Parameterwert. </p> </li> <li> <p>Implementieren Sie eine Methode <code>public boolean increase()</code>. Diese Methode soll den Wert von <code>counter</code> um <code>1</code> erh\u00f6hen. Es muss jedoch gepr\u00fcft werden, ob eventuell das <code>limit</code> erreicht wurde. Sollte dies der Fall sein, wird der Wert von <code>counter</code> wieder auf <code>0</code> gesetzt. Wird der <code>counter</code> tats\u00e4chlich um <code>1</code> erh\u00f6ht, gibt die Methode ein <code>true</code> zur\u00fcck, wurde der Wert von <code>counter</code> jedoch auf <code>0</code> gesetzt, gibt die Methode <code>false</code> zur\u00fcck. Beispiel:</p> <ul> <li> <p>Angenommen <code>counter</code> hat den Wert <code>58</code> und das <code>limit</code> ist <code>60</code>. Dann ist der neue Wert von <code>counter</code> <code>59</code> und die Methode gibt <code>true</code> zur\u00fcck. </p> </li> <li> <p>Angenommen <code>counter</code> hat den Wert <code>59</code> und das <code>limit</code> ist <code>60</code>. Dann ist der neue Wert von <code>counter</code> <code>0</code> und die Methode gibt <code>false</code> zur\u00fcck. </p> </li> </ul> </li> <li> <p>Implementieren Sie eine Methode <code>public String toString()</code>. Diese Methode gibt den Wert von <code>counter</code> als zweistelligen String zur\u00fcck. Beachten Sie</p> <ul> <li>Ist der Wert von <code>counter</code> einstellig, z.B. <code>5</code>, dann soll der String <code>\"05\"</code> zur\u00fcckgegeben werden.</li> </ul> </li> <li> <p>Implementieren Sie eine Methode <code>public void print()</code>. Diese Methode gibt den aktuellen Wert von <code>counter</code> unter Verwendung der Methode <code>toString()</code> auf die Konsole aus. </p> </li> <li> <p>Geben Sie in der <code>main()</code>-Methode der <code>Programmklasse</code> ein:     <pre><code>System.out.printf(\"%n---------------- Test Counter -----------%n%n\");\n\nCounter counter = new Counter(60);\nfor(int i=0; i&lt;120; i++)\n{\n    counter.increase();\n    System.out.printf(\"%3d : \", i);\n    counter.print();\n}\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende Ausgaben erzeugt werden:</p> Ausgabe auf der Konsole <pre><code>---------------- Test Counter -----------\n\n  0 : 01\n  1 : 02\n  2 : 03\n  3 : 04\n  4 : 05\n  5 : 06\n  6 : 07\n  7 : 08\n  8 : 09\n  9 : 10\n 10 : 11\n 11 : 12\n 12 : 13\n 13 : 14\n 14 : 15\n 15 : 16\n 16 : 17\n 17 : 18\n 18 : 19\n 19 : 20\n 20 : 21\n 21 : 22\n 22 : 23\n 23 : 24\n 24 : 25\n 25 : 26\n 26 : 27\n 27 : 28\n 28 : 29\n 29 : 30\n 30 : 31\n 31 : 32\n 32 : 33\n 33 : 34\n 34 : 35\n 35 : 36\n 36 : 37\n 37 : 38\n 38 : 39\n 39 : 40\n 40 : 41\n 41 : 42\n 42 : 43\n 43 : 44\n 44 : 45\n 45 : 46\n 46 : 47\n 47 : 48\n 48 : 49\n 49 : 50\n 50 : 51\n 51 : 52\n 52 : 53\n 53 : 54\n 54 : 55\n 55 : 56\n 56 : 57\n 57 : 58\n 58 : 59\n 59 : 00\n 60 : 01\n 61 : 02\n 62 : 03\n 63 : 04\n 64 : 05\n 65 : 06\n 66 : 07\n 67 : 08\n 68 : 09\n 69 : 10\n 70 : 11\n 71 : 12\n 72 : 13\n 73 : 14\n 74 : 15\n 75 : 16\n 76 : 17\n 77 : 18\n 78 : 19\n 79 : 20\n 80 : 21\n 81 : 22\n 82 : 23\n 83 : 24\n 84 : 25\n 85 : 26\n 86 : 27\n 87 : 28\n 88 : 29\n 89 : 30\n 90 : 31\n 91 : 32\n 92 : 33\n 93 : 34\n 94 : 35\n 95 : 36\n 96 : 37\n 97 : 38\n 98 : 39\n 99 : 40\n100 : 41\n101 : 42\n102 : 43\n103 : 44\n104 : 45\n105 : 46\n106 : 47\n107 : 48\n108 : 49\n109 : 50\n110 : 51\n111 : 52\n112 : 53\n113 : 54\n114 : 55\n115 : 56\n116 : 57\n117 : 58\n118 : 59\n119 : 00\n</code></pre> </li> <li> <p>Erstellen Sie im package eine weitere Klasse <code>Clock</code>. In der Klasse <code>Clock</code> verwenden Sie zwei <code>Counter</code>. Der eine <code>Counter</code> z\u00e4hlt die <code>minutes</code> und hat das <code>limit</code> <code>60</code> und der andere <code>Counter</code> z\u00e4hlt die <code>hours</code> und hat das <code>limit</code> <code>24</code>.  </p> </li> <li> <p>In der Klasse <code>Clock</code> erstellen Sie zwei Objektvariablen <code>minutes</code> und <code>hours</code>, jeweils vom Typ <code>Counter</code> (beide nur in der Klasse sichtbar). </p> </li> <li> <p>Erstellen Sie einen parameterlosen Konstruktor <code>public Clock()</code>. Darin erzeugen Sie f\u00fcr <code>minutes</code> das <code>Counter</code>-Objekt mit dem <code>limit</code> <code>60</code> und f\u00fcr <code>hours</code> das <code>Counter</code>-Objekt mit dem <code>limit</code> <code>24</code>.  </p> </li> <li> <p>Implementieren Sie eine Methode <code>public void increase()</code>. Diese Methode soll den Wert von <code>minutes</code> um <code>1</code> erh\u00f6hen. Sollte jedoch das <code>limit</code> von <code>minutes</code> erreicht sein, wird auch <code>hours</code> um <code>1</code> erh\u00f6ht. Nutzen Sie die <code>increase()</code>-Methode von <code>Counter</code>!</p> </li> <li> <p>Implementieren Sie eine Methode <code>public String toString()</code>. Diese Methode gibt die Werte von <code>minutes</code> und <code>hours</code> in der Form <code>hh:mm</code>als String zur\u00fcck, also z.B. <code>\"23:59\"</code> oder <code>\"01:09\"</code>. Nutzen Sie die <code>toString()</code>-Methode von <code>Counter</code>!</p> </li> <li> <p>Implementieren Sie eine Methode <code>public void print()</code>. Diese Methode gibt den aktuellen Wert von <code>Clock</code> unter Verwendung der Methode <code>toString()</code> auf die Konsole aus. </p> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Programmklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n----------------- Test Clock ------------%n%n\");\n\nClock clock = new Clock();\nfor(int i=0; i&lt;1600; i++)\n{\n    clock.increase();\n    if(i%50==0)\n    {\n        System.out.printf(\"%4d : \", i);\n        clock.print();\n    }\n}\n</code></pre>     und f\u00fchren Sie die <code>Programmklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:</p> Ausgabe auf der Konsole <pre><code>----------------- Test Clock ------------\n\n   0 : 00:01\n  50 : 00:51\n 100 : 01:41\n 150 : 02:31\n 200 : 03:21\n 250 : 04:11\n 300 : 05:01\n 350 : 05:51\n 400 : 06:41\n 450 : 07:31\n 500 : 08:21\n 550 : 09:11\n 600 : 10:01\n 650 : 10:51\n 700 : 11:41\n 750 : 12:31\n 800 : 13:21\n 850 : 14:11\n 900 : 15:01\n 950 : 15:51\n1000 : 16:41\n1050 : 17:31\n1100 : 18:21\n1150 : 19:11\n1200 : 20:01\n1250 : 20:51\n1300 : 21:41\n1350 : 22:31\n1400 : 23:21\n1450 : 00:11\n1500 : 01:01\n1550 : 01:51\n</code></pre> </li> </ol> \u00dcbung 8 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung8</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung8</code> mit <code>main()</code>-Methode.</li> <li> <p>Implementieren Sie eine <code>public static void print(char[] ca)</code>-Methode, so dass das <code>char[] ca</code> auf die Konsole ausgegeben wird. Achten Sie darauf, dass hinter dem letzten Element kein Komma steht. Testen Sie Ihre Methode auch f\u00fcr ein leeres Array.     Bsp:  <code>print(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'])</code>      Ausgabe auf Konsole: <code>[a, b, c, a, c, a, b, c]</code></p> </li> <li> <p>Kopieren Sie die <code>print</code>-Methode vollst\u00e4ndig und \u00e4ndern Sie den Typ des Parameters von <code>char[]</code> in <code>int[]</code>. (Die Methode ist jetzt \u00fcberladen und <code>print()</code> kann jetzt entweder ein <code>char[]</code> oder ein <code>int[]</code> \u00fcbergeben werden, welches auf die Konsole ausgegeben wird.)</p> </li> <li> <p>Implementieren Sie eine Methode <code>public static char[] stringToCharArray(String s)</code>. Diese Methode wandelt einen <code>String</code> in ein <code>char[]</code> um, so dass jedes Zeichen des Strings im <code>char[]</code> enthalten ist. Das <code>char[]</code> wird zur\u00fcckgegeben.      Tipps: die L\u00e4nge eines Strings wird mit der Objektmethode <code>length()</code> ermittelt. Die einzelnen Zeichen eines Strings k\u00f6nnen mithilfe der <code>charAt(index)</code>-Objektmethode von Strings ermittelt werden. Siehe String      Bsp.: <code>stringToCharArray(\"hallo!\")</code> \u2192 <code>['h','a','l','l','o','!']</code> </p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int[] minAndMax(int[] iarr)</code>, der ein <code>int</code>-Array als Parameter \u00fcbergeben wird und die ein zweielementiges Array zur\u00fcckgibt. Das erste Element des zur\u00fcckgegeben Arrays ist das Minimum des als Parameter \u00fcbergebenen Arrays und das zweite Element ist das Maximum.      Bsp.:   <code>minAndMax([4,2,8,1,6,2,4,1,8])</code> \u2192 <code>[1,8]</code> <code>minAndMax([4])</code> \u2192 <code>[4,4]</code></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int[] reverse(int[] iarr)</code>, der ein <code>int</code>-Array \u00fcbergeben wird und die die Reihenfolge der Elemente des Arrays umdreht (das letzte zuerst usw.) Das neuerstellte Array wird zur\u00fcckgegeben.      Bsp.: <code>reverse([4,2,8,1,6,2,4,1,8])</code> \u2192 <code>[8,1,4,2,6,1,8,2,4]</code> <code>reverse([4])</code> \u2192 <code>[4]</code></p> </li> <li> <p>Zusatz: </p> <ul> <li>Implementieren Sie eine Methode <code>public static char[] filter(char[] carr, char filter)</code>, der als Parameter ein <code>char</code>-Array und ein <code>char</code> \u00fcbergeben wird. Die Methode soll ein <code>char</code>-Array zur\u00fcckgeben, das dem als Parameter \u00fcbergeben Array entspricht, au\u00dfer dass jedes Vorkommen des als Parameter \u00fcbergeben <code>carr</code> entfernt wurde  Bsp: <code>filter(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'], 'c')</code> \u2192 <code>['a', 'b', 'a', 'a', 'b']</code></li> <li>Implementieren Sie eine Methode <code>public static boolean containsDoublets(char[] ca)</code> die ein <code>true</code> zur\u00fcckgibt, wenn mindestens ein Wert in <code>ca</code> mindestens zwei Mal vorkommt (wenn Sie schon dabei sind, k\u00f6nnen Sie sich auch \u00fcberlegen, wenn genau ein Wert genau zwei Mal vorkommt - oder mindestens ein Wert genau zwei Mal - oder genau ein Wert mindestens zwei Mal) und <code>false</code> sonst.</li> </ul> </li> </ol> \u00dcbung 9 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung9</code>. </li> <li>Erstellen Sie in diesem package eine Klasse <code>Uebung9</code> mit <code>main()</code>-Methode.</li> <li> <p>Vorabinformation: </p> <ul> <li> <p>Wir implementieren W\u00fcrfe eines W\u00fcrfels. Alle W\u00fcrfe werden in einem Array <code>statistics</code> gespeichert. Das Array hat die L\u00e4nge 6 und beschreibt, wie oft eine 1, wie oft eine 2, ..., wie oft eine 6 gew\u00fcrfelt wurde. </p> <p></p> </li> </ul> </li> <li> <p>Erstellen Sie sich in der <code>main()</code>-Methode zun\u00e4chst das <code>statistics</code>-Array. Alle Elemente des Arrays sind vom Typ <code>int</code> und es hat die L\u00e4nge <code>6</code>. </p> </li> <li> <p>Implementieren Sie folgende Methoden: </p> <ul> <li> <p>Implementieren Sie eine <code>public static int throwDice()</code>-Methode, die eine Zufallszahl aus dem Wertebereich <code>[1, ... , 6]</code> erzeugt und zur\u00fcckgibt.</p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void printThrow(int cast)</code>, die den Wert des \u00fcbergebenen Wurfes (<code>cast</code>) wie folgt ausgibt (Beispiel <code>cast==5</code>):     <pre><code>Es wurde eine 5 gewuerfelt\n</code></pre></p> </li> <li> <p>Testen Sie beide Methoden, indem Sie in der <code>main()</code>-Methode eingeben:     <pre><code>System.out.printf(\"%n%n------------------- Test throwDice and printThrow -------------------%n%n\");\nfor(int index=0; index&lt;10; index++)\n{\n    int cast = throwDice();\n    printThrow(cast);\n}\n</code></pre></p> <p>Sie sollten eine Ausgabe in folgender Form bekommen (Zufallszahlen): <pre><code>------------------- Test throwDice and printThrow -------------------\n\nEs wurde eine 5 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 6 gewuerfelt\nEs wurde eine 5 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 5 gewuerfelt\nEs wurde eine 6 gewuerfelt\nEs wurde eine 6 gewuerfelt\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void insertIntoStatistics(int[] statistics, int cast)</code>. Das <code>statistics</code>-Array wird als Parameter \u00fcbergeben und auch der gew\u00fcrfelte <code>cast</code>. Im <code>statistics</code>-Array wird der Wert an der Stelle um <code>1</code> erh\u00f6ht, der dem Wurf <code>cast</code> entspricht. D.h. wurde eine <code>1</code> gew\u00fcrfelt, wird der Wert im Index <code>0</code> um <code>1</code> erh\u00f6ht, wurde eine <code>2</code> gew\u00fcrfelt, der Wert im Index <code>1</code> usw. (siehe auch oben die Abbildung zu <code>statistics</code>)</p> </li> <li> <p>Implementieren Sie eine Methode <code>public static void printStatistics(int[] statistics)</code>, die das <code>statistics</code>-Array wie folgt auf die Konsole ausgibt. </p> <p>Angenommen, das <code>statistics</code>-Array ist so bef\u00fcllt: <code>[ 3,8,4,5,8,2 ]</code>, dann ist die Ausgabe auf der Konsole:</p> <pre><code>[ (3 x 1), (8 x 2), (4 x 3), (5 x 4), (8 x 5), (2 x 6) ]\n</code></pre> </li> <li> <p>Testen Sie beide Methoden, indem Sie in der <code>main()</code>-Methode eingeben:     <pre><code>System.out.printf(\"%n%n------------------ Test insert- and printStatistics -----------------%n%n\");\nfor(int index=0; index&lt;100; index++)\n{\n    int cast = throwDice();\n    insertIntoStatistics(statistics, cast);\n}\nprintStatistics(statistics);    \n</code></pre></p> <p>Es wird angenommen, dass Sie das <code>statistics</code>-Array bereits gleich am Anfang in der <code>main()</code> erzeugt haben - wenn nicht, k\u00f6nnen Sie das auch hier machen.  </p> <p>Sie sollten eine Ausgabe in folgender Form bekommen (Zufallszahlen): <pre><code>------------------ Test insert- and printStatistics -----------------\n\n[  (20 x 1), (13 x 2), (16 x 3), (15 x 4), (19 x 5), (17 x 6) ]\n</code></pre></p> </li> <li> <p>Implementieren Sie eine Methode <code>public static int sumOfStatistics(int[] statistics)</code>, die eine Summe \u00fcber alle Werte im <code>statistics</code>-Array wie folgt berechnet: </p> <p>Beispiel: Angenommen, das Array ist so bef\u00fcllt: <code>[ 3,8,4,5,8,2 ]</code>, dann ist die Summe: <code>3x1 + 8x2 + 4x3 + 5x4 + 8x5 + 2x6 = 3 + 16 + 12 + 20 + 40 + 12 = 103</code>. Die Summe <code>103</code> wird zur\u00fcckgegeben.  </p> </li> <li> <p>Testen Sie die Methode, indem Sie in der <code>main()</code>-Methode eingeben:     <pre><code>System.out.printf(\"%n%n--------------------- Test sumOfStatistics --------------------------%n%n\");\nprintStatistics(statistics);\nint sumTest = sumOfStatistics(statistics);\nSystem.out.println(\"Summe = \" + sumTest);\n</code></pre></p> <p>Das <code>statistics</code>-Array ist ja bereits oben bef\u00fcllt worden, das m\u00fcssen wir hier also nicht mehr machen. Sie sollten eine Ausgabe in folgender Form bekommen (Zufallszahlen): <pre><code>--------------------- Test sumOfStatistics --------------------------\n\n[  (14 x 1), (15 x 2), (11 x 3), (16 x 4), (27 x 5), (17 x 6) ]\nSumme = 378\n</code></pre></p> </li> <li> <p>Zusatz: Implementieren Sie eine Methode <code>public static int throwDiceUntilTarget(int target, int[] statistics)</code>, die so lange einen W\u00fcrfel w\u00fcrfelt, bis als Summe der Augen das <code>target</code> erreicht ist. Die Anzahl der W\u00fcrfe wird zur\u00fcckgegeben. In dieser Methode erfolgen folgende Aufrufe:</p> <ul> <li>nach jedem Wurf (<code>throwDice()</code>) wird der Wurf ausgegeben (<code>printThrow()</code>) </li> <li>jeder Wurf wird in das <code>statistics</code>-Array eingetragen (<code>insertIntoStatistics()</code>)</li> <li>nach jedem Wurf wird die Summme aller Augen aller bisherigen W\u00fcrfe ermittelt (<code>sumOfStatistics()</code>). </li> <li>so lange die Summe kleiner ist als das <code>target</code>, wird weiter gew\u00fcrfelt</li> </ul> </li> <li> <p>Testen Sie die Methode, indem Sie in der <code>main()</code>-Methode eingeben:     <pre><code>System.out.printf(\"%n%n------------------- Test throwDiceUntilTarget -----------------------%n%n\");\nstatistics = new int[6];    // altes Array war schon befuellt \nfinal int TARGET = 100;\nint tries = throwDiceUntilTarget(TARGET, statistics);\nprintStatistics(statistics);\nint sum = sumOfStatistics(statistics);\nSystem.out.println(\"Es wurden \" + tries + \" Versuche ben\u00f6tigt, um \" + sum + \" Punkte zu erzielen.\");\n</code></pre></p> <p>Da das <code>statistics</code>-Array zuvor bereits bef\u00fcllt war, erstellen wir es f\u00fcr das Testen dieser Methode nochmal neu. Sie sollten eine Ausgabe in folgender Form bekommen (Zufallszahlen): <pre><code>------------------- Test throwDiceUntilTarget -----------------------\n\nEs wurde eine 5 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 5 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 5 gewuerfelt\nEs wurde eine 2 gewuerfelt\nEs wurde eine 5 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 2 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 6 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 2 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 2 gewuerfelt\nEs wurde eine 6 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 3 gewuerfelt\nEs wurde eine 4 gewuerfelt\nEs wurde eine 1 gewuerfelt\nEs wurde eine 6 gewuerfelt\n[  (5 x 1), (4 x 2), (11 x 3), (4 x 4), (4 x 5), (3 x 6) ]\nEs wurden 31 Versuche ben\u00f6tigt, um 100 Punkte zu erzielen.\n</code></pre></p> <p>Es muss das <code>target</code> nicht exakt getroffen werden, das ist Zufall. Es stoppt, sobald <code>100</code> oder mehr Punkte erreicht wurden. </p> </li> </ul> </li> </ol> \u00dcbung 10 <ol> <li>Erstellen Sie ein package <code>uebungen.uebung10</code>. </li> <li> <p>Erstellen Sie in diesem package eine Klasse <code>Lottery</code> mit </p> <ul> <li> <p>der privaten Objektvariablen <code>drawingResults</code> vom Typ <code>int[]</code>.  Information: Lottery steht f\u00fcr eine Lotterie, bei der aus 9 Zahlen (1..9) 5 Zahlen zuf\u00e4llig gelost werden (5 aus 9). Das Array <code>drawingResults</code> dient zum Speichern der gezogenen 5 Zahlen.</p> </li> <li> <p>Schreiben Sie f\u00fcr die Klasse <code>Lottery</code> einen parameterlosen Konstruktor. In diesem Konstruktor wird das Array <code>drawingResults</code> mit der L\u00e4nge 5 erzeugt. </p> </li> <li>Schreiben Sie eine Objektmethode <code>contains(int number)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>number</code> in <code>drawingResults</code> enthalten ist und <code>false</code> sonst. </li> <li>Schreiben Sie eine Objektmethode <code>drawing()</code>. In dieser Methode werden die 5 Zufallszahlen gezogen (5 aus 9). Sie ben\u00f6tigen daf\u00fcr ein Objekt der Klasse <code>Random</code> (<code>Random</code> muss aus <code>java.util</code> importiert werden). \u201eZiehen\u201c Sie nun zuf\u00e4llig 5 Zufallszahlen aus dem Bereich <code>1..9</code> (1 und 9 inklusive) und speichern Sie diese im Array <code>drawingResults</code>.  Achtung: Die gleiche Zahl darf nicht doppelt gezogen (gespeichert) werden! D.h. die 5 im Array gespeicherten Zufallszahlen m\u00fcssen sich voneinander unterscheiden!</li> <li> <p>Schreiben Sie eine Objektmethode <code>sort()</code>. Diese Methode sortiert das Array <code>drawingResults</code> aufsteigend (von klein nach gro\u00df).</p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>, die das <code>drawingResult</code>-Array als <code>String</code> in folgender Form zur\u00fcckgibt (Beispielwerte f\u00fcr den Fall, dass <code>1, 3, 5, 6, 7</code> gezogen wurden):     <pre><code>( 1 - 3 - 5 6 7 - - )\n</code></pre></p> <ol> <li>das <code>dawingResult</code>-Array wird zun\u00e4chst sortiert</li> <li>ist die Zahl im Array enthalten, wird sie als Wert angezeigt</li> <li>ist die Zahl nicht enthalten, wird ein <code>-</code> angezeigt</li> <li>d.h. es werden immer die 5 gezogenen Zahlen ausgegeben und 4 Striche.</li> </ol> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>, die den von <code>toString()</code>zur\u00fcckgegebenen <code>String</code> auf der Konsole ausgibt.   </p> </li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Programmklasse</code> mit <code>main()</code>-Methode. </p> <ul> <li>Erzeugen Sie in der <code>main()</code>-Methode in einer Schleife <code>10</code> Objekte der Klasse <code>Lottery</code> und rufen (auch in der Schleife) jeweils die <code>drawing()</code> und die <code>print()</code>-Methode auf. Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!):     <pre><code>( 1 - 3 - 5 6 7 - - )\n( 1 2 3 - 5 - 7 - - )\n( 1 - 3 - - 6 7 8 - )\n( - - 3 4 5 6 - - 9 )\n( 1 2 3 4 - - - - 9 )\n( 1 2 - 4 - 6 - 8 - )\n( - 2 3 - - - 7 8 9 )\n( 1 2 3 - - 6 - - 9 )\n( 1 - - 4 5 - 7 8 - )\n( - 2 3 - 5 - - 8 9 )\n</code></pre></li> </ul> </li> <li> <p>Zusatz::</p> <ul> <li>Implementieren Sie in der Klasse <code>Lottery</code> eine Objektmethode <code>isEqual(Lottery other)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt das gleiche <code>drawingResults</code>-Array enth\u00e4lt, wie <code>other</code> (also die Werte darin jeweils gleich sind).  Tipp: Implementieren Sie die Methode am einfachsten so, dass Sie die beiden drawingResult-Arrays erst sortieren und dann die sortierten Arrays elementweise miteinander vergleichen.</li> <li>Erzeugen Sie ein Objekt von <code>Lottery</code> und rufen f\u00fcr dieses Objekt die <code>drawing()</code>-Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von <code>Lottery</code> und rufen daf\u00fcr die <code>drawing()</code>-Methode auf, bis die beiden Objekte die gleichen gezogenen Zahlen enthalten, d.h. laut <code>isEqual()</code>-Methode gleich sind. Geben Sie dann beide Objekte mithilfe der <code>print()</code>-Methode aus. Es entsteht folgende Ausgabe (zuf\u00e4llige Beispielwerte):     <pre><code>( 1 - 3 - - 6 - 8 9 )\n( 1 - 3 - - 6 - 8 9 )\n</code></pre></li> </ul> </li> </ol> \u00dcbung 11 <p>\u00dcbung 11 (pdf)</p> \u00dcbung 12 <p>Implementieren Sie eine Methode, die \u00fcberpr\u00fcft, ob ein gegebener String doppelte Zeichen enth\u00e4lt. Von der <code>String</code>-Klasse d\u00fcrfen nur die Methoden <code>length()</code> und <code>charAt(int)</code> verwendet werden.</p> <ul> <li>Was ist Ihre algorithmische Idee? </li> <li>Welche Hilfsmethoden ben\u00f6tigen Sie? </li> </ul> <p>Zusatz (Es d\u00fcrfen weiterhin nur die Methoden <code>length()</code> und <code>charAt(int)</code> von der Klasse <code>String</code> verwendet werden)</p> <ul> <li>Wie oben, aber Gro\u00df-und Kleinschreibung wird ignoriert. </li> <li>Implementieren Sie die <code>startsWith()</code>-Methode der Klasse String nach. </li> <li>Implementieren Sie die <code>replace(char, char)</code>-Methode der Klasse String nach. </li> <li>Implementieren Sie die <code>split(char)</code>-Methode der Klasse String nach. </li> </ul>"},{"location":"uebungen/#probeklausuren","title":"Probeklausuren","text":"Produkt <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.produkt</code>. </li> <li> <p>(Teil 1) Erstellen Sie in diesem package eine Klasse <code>Produkt</code> mit </p> <ul> <li> <p>den privaten Objektvariablen </p> <ul> <li><code>nummer</code> vom Typ <code>int</code> (8stellige Produktnummer), </li> <li><code>preis</code> vom Typ <code>double</code> und </li> <li><code>code</code> vom Typ <code>String</code> (4stelliger Namenscode) . </li> </ul> </li> <li> <p>einer Objektmethode <code>erzeuge8stelligeNummer()</code>, welche ein <code>int</code> zuru\u0308ckgibt. Zuru\u0308ckgegeben wird eine zuf\u00e4llig erzeugte 8-stellige Zahl, also im Wertebereich <code>[10 000 000 , \u2026 , 99 999 999]</code>. Es werden also potenziell <code>90 000 000</code> verschiedene Zufallszahlen erzeugt.</p> </li> <li> <p>einer Objektmethode <code>erzeugePreis(int nummer)</code>, welche ein <code>double</code> zuru\u0308ckgibt. Die u\u0308bergebene <code>nummer</code> ist 8-stellig (mu\u0308ssen Sie nicht pru\u0308fen, Sie k\u00f6nnen davon ausgehen). Zuru\u0308ckgegeben wird eine <code>double</code>-Zahl, die sich aus den ersten 4 Ziffern von <code>nummer</code> ergibt und die zwei Nachkommastellen hat.  Beispiel: <code>nummer = 1234 5678</code> \u2192 zuru\u0308ckgegeben wird <code>12,34</code> Tipp: die letzten vier Ziffern der nummer werden einfach \u201eabgeschnitten\u201c.</p> </li> <li> <p>einer Objektmethode <code>erzeugeCode()</code>, welche einen <code>String</code> zuru\u0308ckgibt. Zuru\u0308ckgegeben wird eine 4-stellige Zeichenkette aus Kombinationen der Gro\u00dfbuchstaben <code>A, B, C, D, E, F, G, H, I, J</code>. Die Buchstaben werden jeweils zuf\u00e4llig erzeugt.  Tipp: Der Gro\u00dfbuchstabe <code>A</code> hat den ASCII-Code <code>65</code>, <code>B</code> den ASCII-Code <code>66</code> ... bis <code>J</code> ASCII-Code <code>74</code>. Es werden also potenziell <code>10</code> verschiedene Buchstaben erzeugt.  Beachten Sie: Der zuru\u0308ckgegebene Code muss stets 4-stellig sein.</p> </li> <li> <p>Erstellen Sie eine <code>Programmklasse</code> mit <code>main()</code>-Methode. Rufen Sie in der <code>main()</code>-Methode in einer Schleife alle drei Methoden 5 Mal auf, so dass folgende Ausgabe entsteht (Beispielwerte zuf\u00e4llig):     <pre><code>12181268 12,18 Euro BCGI\n24708077 24,70 Euro IAHH\n60117886 60,11 Euro HIIG\n80346223 80,34 Euro GCCD\n27118770 27,11 Euro IHHA\n</code></pre></p> <p>Beachten Sie, dass die Ausgabe formatiert ist, d.h. ein Preis von z.B. <code>12.3</code> wird als <code>12,30</code> dargestellt.</p> </li> <li> <p>Erstellen Sie in der <code>Produkt</code>-Klasse einen parameterlosen Konstruktor. Initialisieren Sie darin die drei Objektvariablen <code>nummer</code>, <code>preis</code> und <code>code</code> mithilfe der Objektmethoden <code>erzeuge8stelligeNummer()</code>, <code>erzeugePreis(int)</code> und <code>erzeugeCode()</code>.</p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein <code>Produkt</code>-Objekt in der folgenden Form als String zuru\u0308ckgegeben wird (zuf\u00e4llige Beispielwerte):     <pre><code>86163993 86,16 Euro DJJD\n</code></pre></p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>print()</code>, die den von <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>istTeurer(Produkt p)</code>, die ein <code>true</code> zuru\u0308ckgibt, wenn das aufrufende <code>Produkt</code>-Objekt einen h\u00f6heren Preis hat als <code>p</code> und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie fu\u0308r die Objektvariable <code>code</code> einen Getter <code>getCode()</code>.</p> </li> </ul> </li> <li> <p>(Teil 2) Erstellen Sie eine Klasse <code>Produktgruppe</code> mit </p> <ul> <li> <p>den privaten Objektvariablen </p> <ul> <li><code>gruppe</code> vom Typ <code>Produkt[]</code> und</li> <li><code>kennzeichen</code> vom Typ <code>char</code> (Buchstabe mit dem jeder Produktcode beginnt). </li> </ul> </li> <li> <p>Erstellen Sie fu\u0308r die Klasse <code>Produktgruppe</code> einen parametrisierten Konstruktor <code>Produktgruppe(char kennzeichen)</code>. Der Parameterwert wird verwendet, um der Objektvariablen <code>kennzeichen</code> einen Wert zuzuweisen. Au\u00dferdem wird das <code>gruppe</code>-Array mit der L\u00e4nge 0 erzeugt.</p> </li> <li> <p>Erstellen Sie fu\u0308r Klasse <code>Produktgruppe</code> eine Objektmethode <code>enthalten(Produkt p)</code>. Diese gibt ein <code>true</code> zuru\u0308ck, wenn in <code>gruppe</code> bereits ein Produkt enthalten ist, das denselben <code>code</code> wie <code>p</code> hat und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie fu\u0308r Klasse <code>Produktgruppe</code> eine Objektmethode <code>einfuegen(Produkt p)</code>. Diese Methode fu\u0308gt <code>p</code> in das <code>gruppe</code>-Array ein, aber nur, wenn</p> <ul> <li>der <code>code</code> von <code>p</code> mit demselben Buchstaben beginnt, wie <code>kennzeichen</code> und</li> <li><code>p</code> noch nicht in <code>gruppe</code> enthalten ist.</li> </ul> <p>Wird <code>p</code> tats\u00e4chlich in <code>gruppe</code> eingefu\u0308gt, gibt die Methode ein <code>true</code> zuru\u0308ck und <code>false</code> sonst.  Beachten Sie, dass sich die L\u00e4nge von <code>gruppe</code> um 1 erh\u00f6ht, wenn <code>p</code> eingefu\u0308gt wird (sonst nicht).</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>getAnzahl()</code>. Diese Methode gibt die Anzahl der in <code>gruppe</code> befindlichen Produkte zuru\u0308ck.</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>getProdukt(int index)</code>. Diese Methode gibt das Produkt zuru\u0308ck, das sich unter <code>index</code> in <code>gruppe</code> befindet. Ist der Wert von <code>index</code> kein korrekter Index aus dem <code>gruppe</code>-Array, wird <code>null</code> zuru\u0308ckgegeben.</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>print()</code>, so dass alle Produkte aus dem <code>gruppe</code>-Array in der folgenden Form auf der Konsole ausgegeben werden (zuf\u00e4llige Beispielwerte):     <pre><code>-----------------\nProduktgruppe B Anzahl: 5\n73541548 73,54 Euro BFEI\n64251775 64,25 Euro BHHF\n76401485 76,40 Euro BEIF\n37121451 37,12 Euro BEFB\n32961676 32,96 Euro BGHG\n-----------------\n</code></pre></p> <ul> <li>Es erscheint also zun\u00e4chst eine Linie, L\u00e4nge egal,</li> <li>dann <code>Produktgruppe B Anzahl: 5</code>, wobei <code>B</code> dem Wert von <code>kennzeichen</code> entspricht und <code>5</code> der aktuellen Anzahl von Produkten in der Produktgruppe,</li> <li>dann kommen alle Produkte aus dem <code>gruppe</code>-Array,</li> <li>dann wieder eine Linie, L\u00e4nge egal.</li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der Programmklasse zwei Objekte von <code>Produktgruppe</code>. \u00dcbergeben Sie dem einen Objekt den Buchstaben <code>A</code> und dem anderen Objekt dem Buchstaben <code>B</code>.</p> <ul> <li>Erstellen Sie in einer Schleife so lange <code>Produkt</code>-Objekte und fu\u0308gen Sie diese in die Produktgruppen <code>A</code> und <code>B</code> ein, bis beide Produktgruppen jeweils genau <code>10</code> Produkte enthalten.</li> <li>Beachten Sie, dass die meisten Produkt-Objekte, die erzeugt werden, gar nicht eingefu\u0308gt werden. Entweder, weil deren <code>code</code> weder mit <code>A</code> noch mit <code>B</code> beginnt oder weil sie bereits in der Produktgruppe <code>A</code> oder <code>B</code> enthalten sind oder weil die entsprechende Produktgruppe bereits \u201evoll\u201c ist.</li> <li>Die Schleife wird beendet, sobald beide Produktgruppen \u201evoll\u201c sind (jeweils <code>10</code> Produkte enthalten).</li> <li> <p>Geben Sie danach beide Produktgruppen aus (zuf\u00e4llige Beispielwerte):</p> <pre><code>-----------------\nProduktgruppe A Anzahl: 10\n65300097 65,30 Euro AAJH\n47910971 47,91 Euro AJHB\n54670624 54,67 Euro AGCE\n24670796 24,67 Euro AHJG\n88720102 88,72 Euro ABAC\n65710294 65,71 Euro ACJE\n62720994 62,72 Euro AJJE\n85260450 85,26 Euro AEFA\n58780851 58,78 Euro AIFB\n77570265 77,57 Euro ACGF\n-----------------\n-----------------\nProduktgruppe B Anzahl: 10\n73541548 73,54 Euro BFEI\n64251775 64,25 Euro BHHF\n76401485 76,40 Euro BEIF\n37121451 37,12 Euro BEFB\n32961676 32,96 Euro BGHG\n89731572 89,73 Euro BFHC\n70431224 70,43 Euro BCCE\n52921559 52,92 Euro BFFJ\n58991433 58,99 Euro BEDD\n42611284 42,61 Euro BCIE\n-----------------\n</code></pre> </li> </ul> </li> </ul> </li> <li> <p>(Teil 3) Erstellen Sie eine Klasse <code>Lager</code> mit </p> <ul> <li> <p>den privaten Objektvariablen </p> <ul> <li><code>lager</code> vom Typ <code>Produktgruppe[]</code> und</li> <li><code>kapazitaet</code> vom Typ <code>int</code> (gr\u00f6\u00dftm\u00f6gliche Anzahl von Produkten im Lager). </li> </ul> </li> <li> <p>Erstellen Sie fu\u0308r die Klasse Lager einen parametrisierten Konstruktor Lager(int kapazitaet). Der Parameterwert wird verwendet, um der Objektvariablen kapazitaet einen Wert zuzuweisen. Au\u00dferdem wird das lager-Array mit der L\u00e4nge 10 erzeugt. Befu\u0308llen Sie das lager-Array mit den Produktgruppen-Objekten A bis J, d.h. das erste Element im lager-Array zeigt auf das Produktgruppe-Objekt A, das zweite auf das Produktgruppe-Objekt B usw.</p> </li> <li> <p>Erstellen Sie eine Objektmethode fuellen(). Diese Methode gibt nichts zuru\u0308ck. In dieser Methode werden kapazitaet viele Produkt-Objekte erzeugt und diese Produkt-Objekte in die Produktgruppen in lager eingefu\u0308gt. Verwenden Sie zum Einfu\u0308gen die Objektmethode einfuegen(Produkt) aus der Klasse Produktgruppe.  Beachten Sie: am Ende sollen kapazit\u00e4t viele Produkte im Lager sein. Wenn Sie ein Produkt erzeugen, k\u00f6nnen Sie es prinzipiell allen Produktgruppen hinzufu\u0308gen, denn das Hinzufu\u0308gen ist ja nur bei der Produktgruppe erfolgreich, die das passende kennzeichen hat.</p> </li> <li> <p>Erstellen Sie eine Objektmethode print(), die alle Produktgruppen aus dem lager-Array auf die Konsole ausgibt.</p> </li> <li> <p>Erstellen Sie eine Objektmethode produktgruppeMitDenMeistenProdukten(). Diese Methode gibt die Produktgruppe aus dem lager-Array zuru\u0308ck, welche die meisten Produkte enth\u00e4lt.</p> </li> <li> <p>Erstellen Sie eine Objektmethode billigstesProdukt(). Diese Methode gibt das Produkt aus dem gesamten lager-Array zuru\u0308ck, das den geringsten Preis von allen hat.</p> </li> <li> <p>Erzeugen Sie in der main()-Methode der Programmklasse ein Lager-Objekt mit dem Parameterwert 50.</p> <ul> <li> <p>Befu\u0308llen Sie das Lager-Objekt mithilfe der Methode fuellen() und geben Sie es mithilfe von print() aus (zuf\u00e4llige Beispielwerte):</p> <pre><code>-----------------\nProduktgruppe A Anzahl: 5\n81530793 81,53 Euro AHJD\n47370387 47,37 Euro ADIH\n67750984 67,75 Euro AJIE\n82940201 82,94 Euro ACAB\n88270574 88,27 Euro AFHE\n-----------------\n-----------------\nProduktgruppe B Anzahl: 5\n13051709 13,05 Euro BHAJ\n72061661 72,06 Euro BGGB\n60111349 60,11 Euro BDEJ\n51931137 51,93 Euro BBDH\n90881647 90,88 Euro BGEH\n-----------------\n-----------------\nProduktgruppe C Anzahl: 3\n71872170 71,87 Euro CBHA\n26982074 26,98 Euro CAHE\n79032470 79,03 Euro CEHA\n-----------------\n-----------------\nProduktgruppe D Anzahl: 7\n77193585 77,19 Euro DFIF\n35983109 35,98 Euro DBAJ\n20313080 20,31 Euro DAIA\n86093082 86,09 Euro DAIC\n41883886 41,88 Euro DIIG\n51103455 51,10 Euro DEFF\n71353002 71,35 Euro DAAC\n-----------------\n-----------------\nProduktgruppe E Anzahl: 6\n62374914 62,37 Euro EJBE\n95954960 95,95 Euro EJGA\n11804488 11,80 Euro EEII\n79574003 79,57 Euro EAAD\n87084361 87,08 Euro EDGB\n37804191 37,80 Euro EBJB\n-----------------\n-----------------\nProduktgruppe F Anzahl: 4\n41795426 41,79 Euro FECG\n94345512 94,34 Euro FFBC\n16055839 16,05 Euro FIDJ\n96565390 96,56 Euro FDJA\n-----------------\n-----------------\nProduktgruppe G Anzahl: 3\n94946327 94,94 Euro GDCH\n65536904 65,53 Euro GJAE\n31006786 31,00 Euro GHIG\n-----------------\n-----------------\nProduktgruppe H Anzahl: 4\n64707668 64,70 Euro HGGI\n11957550 11,95 Euro HFFA\n79047293 79,04 Euro HCJD\n85057454 85,05 Euro HEFE\n-----------------\n-----------------\nProduktgruppe I Anzahl: 8\n57408724 57,40 Euro IHCE\n26408714 26,40 Euro IHBE\n11118773 11,11 Euro IHHD\n64038221 64,03 Euro ICCB\n20578532 20,57 Euro IFDC\n82238986 82,23 Euro IJIG\n35148126 35,14 Euro IBCG\n73748018 73,74 Euro IABI\n-----------------\n-----------------\nProduktgruppe J Anzahl: 5\n52249267 52,24 Euro JCGH\n15129449 15,12 Euro JEEJ\n21219816 21,21 Euro JIBG\n96469515 96,46 Euro JFBF\n56669411 56,66 Euro JEBB\n-----------------\n</code></pre> </li> <li> <p>Rufen Sie die produktgruppeMitDenMeistenProdukten()-Methode auf und geben Sie die zuru\u0308ckgegebene Produktgruppe aus (Beispielwerte):</p> <pre><code>-----------------\nProduktgruppe I Anzahl: 8\n57408724 57,40 Euro IHCE\n26408714 26,40 Euro IHBE\n11118773 11,11 Euro IHHD\n64038221 64,03 Euro ICCB\n20578532 20,57 Euro IFDC\n82238986 82,23 Euro IJIG\n35148126 35,14 Euro IBCG\n73748018 73,74 Euro IABI\n-----------------\n</code></pre> </li> <li> <p>Rufen Sie die billigstesProdukt ()-Methode auf und geben Sie das zuru\u0308ckgegebene Produkt aus (Beispielwerte):</p> <pre><code>11118773 11,11 Euro IHHD\n</code></pre> </li> </ul> </li> </ul> </li> <li> <p>Zur Kontrolle: Die m\u00f6glichen Ausgaben (Beispielwerte) k\u00f6nnten sein:</p> <pre><code>------------------------- Teil 1 Produkt --------------------------\n12181268 12,18 Euro BCGI\n24708077 24,70 Euro IAHH\n60117886 60,11 Euro HIIG\n80346223 80,34 Euro GCCD\n27118770 27,11 Euro IHHA\n-------------------- Teil 2 Produktgruppe ------------------------\n-----------------\nProduktgruppe A Anzahl: 10\n65300097 65,30 Euro AAJH\n47910971 47,91 Euro AJHB\n54670624 54,67 Euro AGCE\n24670796 24,67 Euro AHJG\n88720102 88,72 Euro ABAC\n65710294 65,71 Euro ACJE\n62720994 62,72 Euro AJJE\n85260450 85,26 Euro AEFA\n58780851 58,78 Euro AIFB\n77570265 77,57 Euro ACGF\n-----------------\n-----------------\nProduktgruppe B Anzahl: 10\n73541548 73,54 Euro BFEI\n64251775 64,25 Euro BHHF\n76401485 76,40 Euro BEIF\n37121451 37,12 Euro BEFB\n32961676 32,96 Euro BGHG\n89731572 89,73 Euro BFHC\n70431224 70,43 Euro BCCE\n52921559 52,92 Euro BFFJ\n58991433 58,99 Euro BEDD\n42611284 42,61 Euro BCIE\n\n----------------------- Teil 3 Lager ------------------------\n-----------------\nProduktgruppe A Anzahl: 5\n81530793 81,53 Euro AHJD\n47370387 47,37 Euro ADIH\n67750984 67,75 Euro AJIE\n82940201 82,94 Euro ACAB\n88270574 88,27 Euro AFHE\n-----------------\n-----------------\nProduktgruppe B Anzahl: 5\n13051709 13,05 Euro BHAJ\n72061661 72,06 Euro BGGB\n60111349 60,11 Euro BDEJ\n51931137 51,93 Euro BBDH\n90881647 90,88 Euro BGEH\n-----------------\n-----------------\nProduktgruppe C Anzahl: 3\n71872170 71,87 Euro CBHA\n26982074 26,98 Euro CAHE\n79032470 79,03 Euro CEHA\n-----------------\n-----------------\nProduktgruppe D Anzahl: 7\n77193585 77,19 Euro DFIF\n35983109 35,98 Euro DBAJ\n20313080 20,31 Euro DAIA\n86093082 86,09 Euro DAIC\n41883886 41,88 Euro DIIG\n51103455 51,10 Euro DEFF\n71353002 71,35 Euro DAAC\n-----------------\n-----------------\nProduktgruppe E Anzahl: 6\n62374914 62,37 Euro EJBE\n95954960 95,95 Euro EJGA\n11804488 11,80 Euro EEII\n79574003 79,57 Euro EAAD\n87084361 87,08 Euro EDGB\n37804191 37,80 Euro EBJB\n-----------------\n-----------------\nProduktgruppe F Anzahl: 4\n41795426 41,79 Euro FECG\n94345512 94,34 Euro FFBC\n16055839 16,05 Euro FIDJ\n96565390 96,56 Euro FDJA\n-----------------\n-----------------\nProduktgruppe G Anzahl: 3\n94946327 94,94 Euro GDCH\n65536904 65,53 Euro GJAE\n31006786 31,00 Euro GHIG\n-----------------\n-----------------\nProduktgruppe H Anzahl: 4\n64707668 64,70 Euro HGGI\n11957550 11,95 Euro HFFA\n79047293 79,04 Euro HCJD\n85057454 85,05 Euro HEFE\n-----------------\n-----------------\nProduktgruppe I Anzahl: 8\n57408724 57,40 Euro IHCE\n26408714 26,40 Euro IHBE\n11118773 11,11 Euro IHHD\n64038221 64,03 Euro ICCB\n20578532 20,57 Euro IFDC\n82238986 82,23 Euro IJIG\n35148126 35,14 Euro IBCG\n73748018 73,74 Euro IABI\n-----------------\n-----------------\nProduktgruppe J Anzahl: 5\n52249267 52,24 Euro JCGH\n15129449 15,12 Euro JEEJ\n21219816 21,21 Euro JIBG\n96469515 96,46 Euro JFBF\n56669411 56,66 Euro JEBB\n-----------------\n\n----------------------- Teil 3 Lager \u2013 Produktgruppe mit den meisten Produkten ------------------------\n-----------------\nProduktgruppe I Anzahl: 8\n57408724 57,40 Euro IHCE\n26408714 26,40 Euro IHBE\n11118773 11,11 Euro IHHD\n64038221 64,03 Euro ICCB\n20578532 20,57 Euro IFDC\n82238986 82,23 Euro IJIG\n35148126 35,14 Euro IBCG\n73748018 73,74 Euro IABI\n-----------------\n\n----------------------- Teil 3 Lager \u2013 billigstes Produkt ------------------------\n11118773 11,11 Euro IHHD\n</code></pre> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Produkt Programmklasse.javaProdukt.javaProduktgruppe.javaLager.java <pre><code>package klausurvorbereitung.produkt;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n----------------------------  Testen von Produkt  --------------------------------%n%n\");\n        Produkt p1 = new Produkt();\n        for(int i = 0; i &lt; 20; i++) {\n            int nummer = p1.erzeuge8stelligeNummer();\n            double preis = p1.erzeugePreis(nummer);\n            String code = p1.erzeugeCode(nummer);\n            System.out.printf(\"%8d %.2f Euro %s %n\", nummer, preis, code);\n        }\n\n        System.out.printf(\"%n%n-------------------------  Testen von Produktgruppe  -----------------------------%n%n\");\n        Produktgruppe pgA = new Produktgruppe('A');\n        Produktgruppe pgB = new Produktgruppe('B');\n        final int LIMIT = 10;\n        boolean pgAVoll = pgA.getAnzahl() == LIMIT;\n        boolean pgBVoll = pgB.getAnzahl() == LIMIT;\n        boolean beideVoll = pgAVoll &amp;&amp; pgBVoll;\n        while(!beideVoll) {\n            Produkt p = new Produkt();\n            // p.print();\n            if(!pgAVoll) {\n                // if(pgA.einfuegen(p)) pgA.print();    // variante mit ausdrucken\n                pgA.einfuegen(p);                       // ohne ausdrucken\n            }\n            if(!pgBVoll) {\n                // if(pgB.einfuegen(p)) pgB.print();    // mit ausdruck zum testen\n                pgB.einfuegen(p);                       // ohne ausdruck\n            }\n            pgAVoll = pgA.getAnzahl() == LIMIT;\n            pgBVoll = pgB.getAnzahl() == LIMIT;\n            beideVoll = pgAVoll &amp;&amp; pgBVoll;\n        }\n        pgA.print();\n        pgB.print();\n\n        /*\n         * nicht in der Klausur verlangt\n         */\n        Produktgruppe pgC = new Produktgruppe('C', 10);\n        //pgC.print();\n\n        System.out.printf(\"%n%n----------------------------   Testen von Lager   --------------------------------%n%n\");\n        Lager l1 = new Lager(50);\n        l1.fuellen();\n        l1.print();\n\n        System.out.printf(\"%n%n----------   Produktgruppe mit den meisten Produkten in Lager   ------------------%n%n\");    \n        Produktgruppe pg = l1.produktgruppeMitDenMeistenProdukten();\n        pg.print();\n\n        System.out.printf(\"%n%n------------------------   billigstes Produkt in Lager   -------------------------%n%n\");    \n        Produkt p = l1.billigstesProdukt();\n        p.print();\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.produkt;\n\nimport java.util.Random;\n\npublic class Produkt\n{\n    private int nummer;\n    private double preis;\n    private String code;\n\n    public int erzeuge8stelligeNummer() {\n        Random r = new Random();\n        int number = r.nextInt(90000000) + 10000000;\n        return number;\n    }\n\n    public double erzeugePreis(int nummer) {\n        double ersten4Ziffern = nummer / 10000;\n        double preis = ersten4Ziffern / 100.0;\n        return preis;\n    }\n\n    public String erzeugeCode(int nummer) {\n        int letzten4Ziffern = nummer % 10000;\n        int nr = letzten4Ziffern;\n        String code = \"\";\n        final int ASCII_A = 65;\n        while(nr &gt; 0) {\n            int rest = nr % 10;\n            int asciiCode = ASCII_A + rest;\n            char buchstabe = (char)asciiCode;\n            code = buchstabe + code;\n            nr = nr / 10;\n        }\n        while(code.length() &lt; 4) {\n            code = \"A\" + code;\n        }\n        return code;\n    }\n\n    public Produkt() {\n        this.nummer = this.erzeuge8stelligeNummer();\n        this.code = this.erzeugeCode(this.nummer);\n        this.preis = this.erzeugePreis(this.nummer);\n    }\n\n    public String toString() {\n        String s = String.format(\"%8d %.2f Euro %s \", this.nummer, this.preis, this.code);\n        return s;\n    }\n\n    public void print() {\n        System.out.println(this.toString());\n    }\n\n    public boolean istTeurer(Produkt p) {\n        return this.preis &gt; p.preis;\n    }\n\n    public String getCode() {\n        return this.code;\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.produkt;\n\npublic class Produktgruppe\n{\n    Produkt[] gruppe;\n    char kennzeichen;\n\n    Produktgruppe(char kennzeichen) {\n        this.gruppe = new Produkt[0];\n        this.kennzeichen = kennzeichen;\n    }\n\n    Produktgruppe(char kennzeichen, int anzahl) {\n        this.gruppe = new Produkt[0];\n        this.kennzeichen = kennzeichen;\n        while(this.gruppe.length &lt; anzahl) {\n            this.einfuegen(new Produkt());\n        }\n    }\n\n    public boolean enthalten(Produkt p) {\n        for(int index = 0; index &lt; this.gruppe.length; index++) {\n            if(this.gruppe[index].getCode().equals(p.getCode())) return true;\n        }\n        return false;\n    }\n\n    public boolean einfuegen(Produkt p) {\n        String code = p.getCode();\n        char pKennzeichen = code.charAt(0);\n        if(pKennzeichen == this.kennzeichen &amp;&amp; !this.enthalten(p)) {\n            Produkt[] neueGruppe = new Produkt[this.gruppe.length + 1];\n            for(int index = 0; index &lt; this.gruppe.length; index++) {\n                neueGruppe[index] = this.gruppe[index];\n            }\n            neueGruppe[this.gruppe.length] = p;\n            this.gruppe = neueGruppe;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public int getAnzahl() {\n        return this.gruppe.length;\n    }\n\n    public Produkt getProdukt(int index) {\n        if(index &lt; 0 || index &gt;= this.getAnzahl()) {\n            return null;\n        } else {\n            return this.gruppe[index];\n        }\n    }\n\n    public void print() {\n        System.out.printf(\"%n-----------------%nProduktgruppe %c Anzahl: %d %n%n\", this.kennzeichen, this.getAnzahl());\n        for(int index = 0; index &lt; this.gruppe.length; index++) {\n            this.gruppe[index].print();\n        }\n        System.out.printf(\"%n-----------------%n\"); \n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.produkt;\n\npublic class Lager\n{\n    int kapazitaet;\n    Produktgruppe[] lager;\n\n    Lager(int kapazitaet) {\n        this.kapazitaet = kapazitaet;\n        this.lager = new Produktgruppe[10];\n        char kennzeichen = 'A';\n        for(int index = 0; index &lt; 10; index++) {\n            this.lager[index] = new Produktgruppe(kennzeichen);\n            kennzeichen++;\n        }\n    }\n\n    public void fuellen() {\n        for(int anzahl = 0; anzahl &lt; this.kapazitaet; anzahl++) {\n            Produkt p = new Produkt();\n            for(int index = 0; index &lt; 10; index++) {\n                this.lager[index].einfuegen(p);\n            }\n        }\n    }\n\n    public void print() {\n        for(int index = 0; index &lt; 10; index++) {\n            this.lager[index].print();\n        }\n    }\n\n    public Produktgruppe produktgruppeMitDenMeistenProdukten() {\n        Produktgruppe pg = this.lager[0];\n        for(int index = 1; index &lt; 10; index++) {\n            if(this.lager[index].getAnzahl() &gt; pg.getAnzahl()) {\n                pg = this.lager[index];\n            }\n        }\n        return pg;\n    }\n\n    public Produkt billigstesProdukt() {\n        Produkt p = this.lager[0].getProdukt(0);\n        for(int indexPG = 0; indexPG &lt; 10; indexPG++) {\n            for(int indexP = 0; indexP &lt; this.lager[indexPG].getAnzahl(); indexP++) {\n                if(p.istTeurer(this.lager[indexPG].getProdukt(indexP))) {\n                    p = this.lager[indexPG].getProdukt(indexP);\n                }\n            }\n        }\n        return p;\n    }\n}\n</code></pre> Fahrzeug <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.fahrzeug</code>. </li> <li> <p>(Teil 1) Erstellen Sie in diesem package eine Klasse <code>Fahrzeug</code> mit </p> <ul> <li> <p>den privaten Objektvariablen <code>marke</code> vom Typ <code>String</code>, <code>kmStand</code> vom Typ <code>int</code> (AKilometerstand des Fahrzeugs), <code>maxV</code> vom Typ <code>int</code> (H\u00f6chstgeschwindigkeit des Fahrzeugs) und <code>verbrauch</code> vom Typ <code>double</code> (AVerbrauch in Litern pro 100km). </p> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Fahrzeug</code> einen parametrisierten Konstruktor, dem die Parameter <code>marke</code>, <code>maxV</code> und <code>verbrauch</code> \u00fcbergeben werden. Mit den Parameterwerten werden die entsprechenden Objektvariablen initialisiert. Die Objektvariable <code>kmStand</code> wird mit dem Wert <code>0</code> initialisiert.</p> </li> <li> <p>Erstellen Sie eine Methode <code>fahren()</code>. Diese Methode gibt nichts zur\u00fcck. In dieser Methode wird eine Zufallszahl aus dem Wertebereich <code>0\u2026999</code> erzeugt, also potenziell <code>1000</code> verschiedene Zahlen. Diese Zufallszahl entspricht einer Reise und wird dem <code>kmStand</code> hinzuaddiert.</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>gesamtverbrauch()</code>, die ein <code>double</code> zur\u00fcckgibt. In dieser Methode wird der bisherige Gesamtverbrauch ermittelt, d.h. es soll mithilfe von <code>verbrauch</code> (Liter auf 100 Kilometer) berechnet werden, wieviel f\u00fcr den bisherigen <code>kmStand</code> insgesamt verbraucht wurde. Beachten Sie, dass Ihnen insbesondere beim Dividieren durch <code>100</code> keine Informationen verloren gehen.</p> </li> <li> <p>Erstellen Sie f\u00fcr alle Objektvariablen Getter, also <code>getMarke()</code>, <code>getKmStand()</code>, <code>getMaxV()</code> und <code>getVerbrauch()</code>.</p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein <code>String</code> in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte):      <pre><code>B    200km/h  8,5l/100km   13157km  1118,35l\n</code></pre></p> <p>Beachten Sie: <code>B</code> ist die marke des Fahrzeugs. Reservieren Sie </p> <ul> <li>f\u00fcr die Marke 4 Zeichen,</li> <li>f\u00fcr die H\u00f6chstgeschwindigkeit 3 Zeichen (dann kommt <code>km/h</code>), </li> <li>f\u00fcr den Verbrauch insgesamt 4 Zeichen, davon 1 Nachkommastelle (dann kommt <code>l/100km</code>),</li> <li>f\u00fcr den Kilometerstand 7 Zeichen (dann kommt <code>km</code>) und</li> <li>f\u00fcr den Gesamtverbrauch insgesamt 8 Zeichen, davon 2 Nachkommastellen (dann kommt <code>l</code>). </li> </ul> </li> <li> <p>Erstellen Sie eine Objektmethode <code>print()</code>, die den von <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>equals(Object o)</code> so, dass zwei Fahrzeuge gleich sind, wenn sie dieselbe <code>marke</code> und denselben <code>kmStand</code> haben.</p> </li> <li> <p>Erstellen Sie eine <code>Programmklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode ein <code>Array</code>, in dem alle Elemente vom Typ <code>Fahrzeug</code> sind. Das <code>Array</code> soll die L\u00e4nge 4 haben. Bef\u00fcllen Sie dieses <code>Array</code> mit vier Fahrzeug-Objekten mit den folgenden Werten f\u00fcr die Objektvariablen (<code>marke</code>, <code>maxV</code>, <code>verbrauch</code>):</p> <pre><code>\"A\", 250, 10.0\n\"B\", 200, 8.5\n\"C\", 160, 6.5\n\"D\", 180, 7.0 \n</code></pre> <p>Geben Sie in einer Schleife alle vier Fahrzeug-Objekte auf die Konsole unter Verwendung der <code>print()</code>-Methode aus. Es entsteht folgende Ausgabe:</p> <pre><code>A    250km/h 10,0l/100km       0km     0,00l\nB    200km/h  8,5l/100km       0km     0,00l\nC    160km/h  6,5l/100km       0km     0,00l\nD    180km/h  7,0l/100km       0km     0,00l\n</code></pre> </li> <li> <p>Erweitern Sie die <code>main()</code>-Methode wie folgt: In einer Schleife sollen insgesamt <code>100</code> Fahrten durchgef\u00fchrt werden. Es wird zuf\u00e4llig ausgew\u00e4hlt, f\u00fcr welches der Fahrzeuge aus dem obigen Array jeweils die Methode <code>fahren()</code> aufgerufen wird. </p> <p>Rufen Sie danach erneut die <code>print()</code>-Methode in einer Schleife f\u00fcr alle Fahrzeuge aus dem Array auf. Es entsteht folgende Ausgabe (Beispielwerte \u2013 zuf\u00e4llig!):</p> <pre><code>A    250km/h 10,0l/100km   11845km  1184,50l\nB    200km/h  8,5l/100km   13157km  1118,35l\nC    160km/h  6,5l/100km   11762km   764,53l\nD    180km/h  7,0l/100km   13465km   942,55l \n</code></pre> </li> </ul> </li> <li> <p>(Teil 2) </p> <ul> <li> <p>Erstellen Sie eine Klasse <code>Auto</code>. Diese Klasse erbt von <code>Fahrzeug</code>. Dem Konstruktor werden die Parameter <code>String marke, int maxV, double verbrauch</code> \u00fcbergeben. </p> </li> <li> <p>Erstellen Sie eine Klasse <code>LKW</code>. Diese Klasse erbt von <code>Fahrzeug</code>. Dem Konstruktor wird nur der Parameter <code>double verbrauch</code> \u00fcbergeben. Die <code>marke</code> ist bei einem <code>LKW</code> stets <code>\"LKW\"</code> und die H\u00f6chstgeschwindigkeit (<code>maxV</code>) ist stets <code>100</code>.</p> </li> <li> <p>Erstellen Sie eine Klasse <code>Fuhrpark</code>. Objektvariablen sind </p> <ul> <li><code>fuhrpark</code> vom Typ <code>Fahrzeug[]</code>,</li> <li><code>anzahl</code> vom Typ <code>int</code> (Anzahl der Fahrzeuge im Fuhrpark ).</li> </ul> <p>Die Objektvariablen sind nur innerhalb der Klasse sichtbar!</p> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Fuhrpark</code> einen parametrisierten Konstruktor, dem ein <code>int</code>-Wert <code>groesse</code> \u00fcbergeben wird. Dieser Wert entspricht der L\u00e4nge des zu erzeugenden Arrays <code>fuhrpark</code>. Der Wert f\u00fcr <code>groesse</code> steht also f\u00fcr die maximal m\u00f6gliche Anzahl von Fahrzeugen im Fuhrpark, w\u00e4hrend der Wert <code>anzahl</code> f\u00fcr die tats\u00e4chliche Anzahl von Fahrzeugen im Fuhrpark steht. Das Array wird innerhalb des Konstruktors erzeugt. Der Wert f\u00fcr <code>anzahl</code> ist bei Objekterzeugung stets 0.</p> </li> <li> <p>Erstellen Sie eine Objektmethode <code>fahrzeugKaufen()</code>. Diese Methode gibt nichts zur\u00fcck. </p> <ul> <li>In der Methode wird eine Zufallszahl aus dem Wertebereich <code>50\u2026449</code> erzeugt (also potenziell <code>400</code> verschiedene Zufallszahlen). </li> <li> <p>Ist die erzeugte Zufallszahl kleiner oder gleich <code>250</code>, dann wird <code>fuhrpark</code> ein <code>Auto</code>-Objekt hinzugef\u00fcgt. </p> <ul> <li>Die <code>marke</code> des <code>Auto</code>-Objektes ergibt sich aus dem Buchstaben <code>A</code> gefolgt vom aktuellen Wert von <code>anzahl</code>, also z.B. <code>A1</code>, <code>A2</code>, <code>A3</code>, \u2026</li> <li>Der Wert f\u00fcr <code>maxV</code> entspricht dem Wert der Zufallszahl, </li> <li>Der Wert f\u00fcr <code>verbrauch</code> entspricht der Zufallszahl geteilt durch <code>10</code> (achten Sie aber darauf, eine <code>double</code>-Divsion durchzuf\u00fchren!)</li> </ul> </li> <li> <p>Ist die erzeugte Zufallszahl gr\u00f6\u00dfer als <code>250</code>, dann wird <code>fuhrpark</code> ein <code>LKW</code>-Objekt hinzugef\u00fcgt.</p> <ul> <li>Der Wert f\u00fcr <code>verbrauch</code> entspricht der Zufallszahl geteilt durch <code>10</code> (achten Sie aber darauf, eine <code>double</code>-Divsion durchzuf\u00fchren!) </li> </ul> </li> <li> <p>Durch das Hinzuf\u00fcgen eines Fahrzeugs (<code>Auto</code> oder <code>LKW</code>) erh\u00f6ht sich der Wert von <code>anzahl</code> immer um <code>1</code>.</p> </li> </ul> </li> <li> <p>Erstellen Sie eine Objektmethode <code>fahrzeugKaufen(Fahrzeug fahrzeug)</code>. Diese Methode gibt nichts zur\u00fcck. In dieser Methode wird das <code>fahrzeug</code> dem <code>fuhrpark</code> hinzugef\u00fcgt. Achten Sie darauf, auch <code>anzahl</code> enstprechend zu erh\u00f6hen. </p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein <code>String</code> in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte \u2013 nach dem Hinzuf\u00fcgen von 15 Fahrzeugen):</p> <pre><code>Im Fuhrpark sind 15 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km       0km     0,00l \nLKW  100km/h 32,9l/100km       0km     0,00l \nA2   201km/h 20,1l/100km       0km     0,00l \nLKW  100km/h 43,6l/100km       0km     0,00l \nLKW  100km/h 39,8l/100km       0km     0,00l \nA5   195km/h 19,5l/100km       0km     0,00l \nLKW  100km/h 39,2l/100km       0km     0,00l \nLKW  100km/h 31,3l/100km       0km     0,00l \nA8   214km/h 21,4l/100km       0km     0,00l \nA9   155km/h 15,5l/100km       0km     0,00l \nA10  241km/h 24,1l/100km       0km     0,00l \nLKW  100km/h 40,2l/100km       0km     0,00l \nLKW  100km/h 28,5l/100km       0km     0,00l \nA13   73km/h  7,3l/100km       0km     0,00l \nLKW  100km/h 35,3l/100km       0km     0,00l \n----------------------------- \n</code></pre> <ul> <li>Es erscheint also zun\u00e4chst <code>Im Fuhrpark sind 15 Fahrzeuge :</code>, wobei <code>15</code> dem aktuellen Wert von <code>anzahl</code> entspricht,</li> <li>dann eine Linie, L\u00e4nge egal, </li> <li>dann kommen alle Fahrzeuge aus dem <code>fuhrpark</code>-Array,</li> <li>dann wieder eine Linie, L\u00e4nge egal.</li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der Programmklasse ein Objekt von Fuhrpark. \u00dcbergeben Sie als Parameterwert die <code>20</code>.</p> <ul> <li>Geben Sie das Fuhrpark-Objekt unter Verwendung der <code>toString()</code>-Methode auf die Konsole aus.</li> <li>Rufen Sie f\u00fcr das Fuhrpark-Objekt die Methode <code>fahrzeugKaufen()</code> in einer Schleife <code>15</code> Mal auf. </li> <li>F\u00fcgen Sie mithilfe der <code>fahrzeugKaufen(Fahrzeug)</code>-Methode ein <code>Auto</code> und einen <code>LKW</code> dem Fuhrpark-Objekt hinzu. </li> <li>Geben Sie danach das Fuhrpark-Objekt erneut auf die Konsole aus. </li> <li> <p>Es entstehen folgende Ausgaben (Beispielwerte): </p> <pre><code>Im Fuhrpark sind 0 Fahrzeuge : \n----------------------------- \n----------------------------- \n\nIm Fuhrpark sind 17 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km       0km     0,00l \nLKW  100km/h 32,9l/100km       0km     0,00l \nA2   201km/h 20,1l/100km       0km     0,00l \nLKW  100km/h 43,6l/100km       0km     0,00l \nLKW  100km/h 39,8l/100km       0km     0,00l \nA5   195km/h 19,5l/100km       0km     0,00l \nLKW  100km/h 39,2l/100km       0km     0,00l \nLKW  100km/h 31,3l/100km       0km     0,00l \nA8   214km/h 21,4l/100km       0km     0,00l \nA9   155km/h 15,5l/100km       0km     0,00l \nA10  241km/h 24,1l/100km       0km     0,00l \nLKW  100km/h 40,2l/100km       0km     0,00l \nLKW  100km/h 28,5l/100km       0km     0,00l \nA13   73km/h  7,3l/100km       0km     0,00l \nLKW  100km/h 35,3l/100km       0km     0,00l \nB    200km/h  8,5l/100km       0km     0,00l \nLKW  100km/h 35,5l/100km       0km     0,00l \n----------------------------- \n</code></pre> </li> </ul> </li> <li> <p>Erstellen Sie in der Klasse <code>Fuhrpark</code> eine Objektmethode <code>reisenImMonat(int anzahlReisen)</code>. Diese Methode gibt nichts zur\u00fcck. Der Wert des Parameters <code>anzahlReisen</code> gibt an, wieviele Fahrten im Fuhrpark durchgef\u00fchrt werden, d.h. wie oft die Methode <code>fahren()</code> insgesamt aufgerufen wird. </p> <p>F\u00fcr welches Fahrzeug aus dem Fuhrpark die Methode <code>fahren()</code> jeweils aufgerufen wird, wird zuf\u00e4llig erzeugt! Achten Sie darauf, die Zufallszahl so zu erzeugen, dass Sie den Wert von <code>anzahl</code> ber\u00fccksichtigen!</p> </li> <li> <p>Rufen Sie in der <code>main()</code>-Methode die Methode <code>reisenImMonat(75)</code> f\u00fcr das <code>Fuhrpark</code>-Objekt auf und geben Sie danach das <code>Fuhrpark</code>-Objekt erneut auf die Konsole aus. Es entstehen folgende Ausgaben (Beispielwerte):</p> <pre><code>Im Fuhrpark sind 17 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nA2   201km/h 20,1l/100km    4792km   963,19l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nA5   195km/h 19,5l/100km    1647km   321,17l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nA8   214km/h 21,4l/100km    1649km   352,89l \nA9   155km/h 15,5l/100km    1863km   288,77l \nA10  241km/h 24,1l/100km    2723km   656,24l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nA13   73km/h  7,3l/100km    1455km   106,22l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nB    200km/h  8,5l/100km    2121km   180,29l \nLKW  100km/h 35,5l/100km     912km   323,76l \n-----------------------------\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>Fuhrpark</code> eine Objektmethode <code>alleLKWs()</code>. Diese Methode gibt ein neues <code>Fuhrpark</code>-Objekt zur\u00fcck. In dem neuen <code>Fuhrpark</code>-Objekt werden alle Fahrzeuge aus dem aufrufenden <code>Fuhrpark</code>-Objekt \u00fcbernommen, die vom (Laufzeit-)Typ <code>LKW</code> sind. Verwenden Sie dazu die Objektmethode <code>fahrzeugKaufen(Fahrzeug)</code>.</p> </li> <li> <p>Rufen Sie in der <code>main()</code>-Methode die Methode <code>alleLKWs()</code> auf und lassen Sie sich zur\u00fcckgegebene <code>Fuhrpark</code>-Objekt auf die Konsole ausgeben. Beispielwerte (zuf\u00e4llig):</p> <pre><code>Im Fuhrpark sind 10 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nLKW  100km/h 35,5l/100km     912km   323,76l \n-----------------------------\n</code></pre> </li> <li> <p>Erstellen Sie in <code>Fuhrpark</code> eine Objektmethode <code>meistenKm()</code>, die das <code>Fahrzeug</code> aus dem <code>fuhrpark</code> zur\u00fcckgibt, das den h\u00f6chsten <code>kmStand</code> hat. Sie k\u00f6nnen davon ausgehen, dass mindestens ein <code>Fahrzeug</code> im <code>fuhrpark</code> ist.</p> <p>Rufen Sie diese Methode in der <code>main()</code>-Methode auf und geben Sie das Fahrzeug auf der Konsole aus. Beispielwerte:</p> <pre><code>LKW  100km/h 31,3l/100km    5086km  1591,92l\n</code></pre> </li> <li> <p>Erstellen Sie in Fuhrpark eine Objektmethode <code>hoechsterGesamtverbrauchAuto()</code>, die das <code>Fahrzeug</code> aus dem <code>fuhrpark</code> zur\u00fcckgibt, das bisher den h\u00f6chsten Gesamtverbrauch hat. Es sollen nur die Objekte vom (Laufzeit-)Typ <code>Auto</code> bewertet werden! Sie k\u00f6nnen davon ausgehen, dass mindestens ein <code>Auto</code> im <code>fuhrpark</code> ist.</p> <p>Rufen Sie diese Methode in der main()-Methode auf und geben Sie das Fahrzeug auf der Konsole aus. Beispielwerte:</p> <pre><code>A2   201km/h 20,1l/100km    4792km   963,19l\n</code></pre> </li> <li> <p>Erstellen Sie in <code>Fuhrpark</code> eine Objektmethode <code>fahrzeugLoeschen(Fahrzeug fahrzeug)</code>. Die Methode gibt <code>true</code> zur\u00fcck, wenn <code>fahrzeug</code> aus dem <code>fuhrpark</code> gel\u00f6scht wurde und <code>false</code> sonst.</p> <p>Beachten Sie f\u00fcr den Fall des L\u00f6schens, dass alle nachfolgenden Fahrzeuge in <code>fuhrpark</code> um eine Stelle im Array nach links r\u00fccken! Vergessen Sie auch nicht, den Wert von <code>anzahl</code> f\u00fcr den L\u00f6schfall zu verringern. </p> <p>Rufen Sie diese Methode in der <code>main()</code>-Methode auf und \u00fcbergeben Sie ein <code>Fahrzeug</code>-Objekt, das in <code>fuhrpark</code> vorkommt (siehe z.B. oben die beiden Objekte, die mithilfe der <code>fahrzeugKaufen(Fahrzeug)</code>-Methode hinzugef\u00fcgt wurden). Geben Sie das <code>Fuhrpark</code>-Objekt erneut aus:</p> <pre><code>Im Fuhrpark sind 16 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nA2   201km/h 20,1l/100km    4792km   963,19l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nA5   195km/h 19,5l/100km    1647km   321,17l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nA8   214km/h 21,4l/100km    1649km   352,89l \nA9   155km/h 15,5l/100km    1863km   288,77l \nA10  241km/h 24,1l/100km    2723km   656,24l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nA13   73km/h  7,3l/100km    1455km   106,22l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nLKW  100km/h 35,5l/100km     912km   323,76l \n-----------------------------\n</code></pre> </li> </ul> </li> <li> <p>Zur Kontrolle: Die m\u00f6glichen Ausgaben (Beispielwerte) k\u00f6nnten sein:</p> <pre><code>-------------------- Teil 1 -------------------------\n\nA    250km/h 10,0l/100km       0km     0,00l\nB    200km/h  8,5l/100km       0km     0,00l\nC    160km/h  6,5l/100km       0km     0,00l\nD    180km/h  7,0l/100km       0km     0,00l\n\n---- fahren ----\n\nA    250km/h 10,0l/100km   11323km  1132,30l\nB    200km/h  8,5l/100km   10202km   867,17l\nC    160km/h  6,5l/100km   10079km   655,14l\nD    180km/h  7,0l/100km   15939km  1115,73l\n\n\n-------------------- Teil 2 -------------------------\n\nIm Fuhrpark sind 0 Fahrzeuge : \n----------------------------- \n----------------------------- \n\n\n---- 15 fahrzeuge kaufen ----\n\nIm Fuhrpark sind 15 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km       0km     0,00l \nLKW  100km/h 32,9l/100km       0km     0,00l \nA2   201km/h 20,1l/100km       0km     0,00l \nLKW  100km/h 43,6l/100km       0km     0,00l \nLKW  100km/h 39,8l/100km       0km     0,00l \nA5   195km/h 19,5l/100km       0km     0,00l \nLKW  100km/h 39,2l/100km       0km     0,00l \nLKW  100km/h 31,3l/100km       0km     0,00l \nA8   214km/h 21,4l/100km       0km     0,00l \nA9   155km/h 15,5l/100km       0km     0,00l \nA10  241km/h 24,1l/100km       0km     0,00l \nLKW  100km/h 40,2l/100km       0km     0,00l \nLKW  100km/h 28,5l/100km       0km     0,00l \nA13   73km/h  7,3l/100km       0km     0,00l \nLKW  100km/h 35,3l/100km       0km     0,00l \n----------------------------- \n\n\n---- 2 weitere fahrzeuge kaufen ----\n\nIm Fuhrpark sind 17 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km       0km     0,00l \nLKW  100km/h 32,9l/100km       0km     0,00l \nA2   201km/h 20,1l/100km       0km     0,00l \nLKW  100km/h 43,6l/100km       0km     0,00l \nLKW  100km/h 39,8l/100km       0km     0,00l \nA5   195km/h 19,5l/100km       0km     0,00l \nLKW  100km/h 39,2l/100km       0km     0,00l \nLKW  100km/h 31,3l/100km       0km     0,00l \nA8   214km/h 21,4l/100km       0km     0,00l \nA9   155km/h 15,5l/100km       0km     0,00l \nA10  241km/h 24,1l/100km       0km     0,00l \nLKW  100km/h 40,2l/100km       0km     0,00l \nLKW  100km/h 28,5l/100km       0km     0,00l \nA13   73km/h  7,3l/100km       0km     0,00l \nLKW  100km/h 35,3l/100km       0km     0,00l \nB    200km/h  8,5l/100km       0km     0,00l \nLKW  100km/h 35,5l/100km       0km     0,00l \n----------------------------- \n\n\n---- reisenImMonat(75) ----\n\nIm Fuhrpark sind 17 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nA2   201km/h 20,1l/100km    4792km   963,19l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nA5   195km/h 19,5l/100km    1647km   321,17l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nA8   214km/h 21,4l/100km    1649km   352,89l \nA9   155km/h 15,5l/100km    1863km   288,77l \nA10  241km/h 24,1l/100km    2723km   656,24l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nA13   73km/h  7,3l/100km    1455km   106,22l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nB    200km/h  8,5l/100km    2121km   180,29l \nLKW  100km/h 35,5l/100km     912km   323,76l \n----------------------------- \n\n\n---- alleLKWs ----\n\nIm Fuhrpark sind 10 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nLKW  100km/h 35,5l/100km     912km   323,76l \n----------------------------- \n\n\n---- meisten kilometer ----\n\nLKW  100km/h 31,3l/100km    5086km  1591,92l\n\n---- hoechster gesamtverbrauch auto ----\n\nA2   201km/h 20,1l/100km    4792km   963,19l\n\n---- fahrzeug loeschen ----\n\nIm Fuhrpark sind 16 Fahrzeuge : \n----------------------------- \nLKW  100km/h 26,0l/100km    1002km   260,52l \nLKW  100km/h 32,9l/100km    3964km  1304,16l \nA2   201km/h 20,1l/100km    4792km   963,19l \nLKW  100km/h 43,6l/100km    1540km   671,44l \nLKW  100km/h 39,8l/100km    2720km  1082,56l \nA5   195km/h 19,5l/100km    1647km   321,17l \nLKW  100km/h 39,2l/100km    1496km   586,43l \nLKW  100km/h 31,3l/100km    5086km  1591,92l \nA8   214km/h 21,4l/100km    1649km   352,89l \nA9   155km/h 15,5l/100km    1863km   288,77l \nA10  241km/h 24,1l/100km    2723km   656,24l \nLKW  100km/h 40,2l/100km    2303km   925,81l \nLKW  100km/h 28,5l/100km    1031km   293,84l \nA13   73km/h  7,3l/100km    1455km   106,22l \nLKW  100km/h 35,3l/100km    2902km  1024,41l \nLKW  100km/h 35,5l/100km     912km   323,76l \n-----------------------------\n</code></pre> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Fahrzeug Programmklasse.javaFahrzaug.javaAuto.javaLKW.javaFuhrpark.java <pre><code>package klausurvorbereitung.fahrzeug;\n\nimport java.util.Random;\n\npublic class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n-------------------- Teil 1 -------------------------%n%n\");\n        Fahrzeug[] fuhrpark1 = new Fahrzeug[4];\n        fuhrpark1[0] = new Fahrzeug(\"A\", 250, 10.0);\n        fuhrpark1[1] = new Fahrzeug(\"B\", 200, 8.5);\n        fuhrpark1[2] = new Fahrzeug(\"C\", 160, 6.5);\n        fuhrpark1[3] = new Fahrzeug(\"D\", 180, 7.0);\n\n        for(int index = 0; index &lt; fuhrpark1.length; index++) {\n            fuhrpark1[index].print();\n        }\n        System.out.printf(\"%n---- fahren ----%n%n\");\n        for(int fahrten = 0; fahrten &lt; 100; fahrten++) {\n            Random r = new Random();\n            int nr = r.nextInt(4);\n            fuhrpark1[nr].fahren();\n        }\n\n        for(int index = 0; index &lt; fuhrpark1.length; index++) {\n            fuhrpark1[index].print();\n        }\n\n        System.out.printf(\"%n%n-------------------- Teil 2 -------------------------%n%n\");\n        Fuhrpark fp1 = new Fuhrpark(20);\n\n        System.out.println(fp1.toString());\n\n        System.out.printf(\"%n---- 15 fahrzeuge kaufen ----%n%n\");\n        for(int fahrzeuge = 0; fahrzeuge &lt; 15; fahrzeuge++) {\n            fp1.fahrzeugKaufen();\n        }\n        System.out.println(fp1.toString());\n\n        System.out.printf(\"%n---- 2 weitere fahrzeuge kaufen ----%n%n\");\n        Fahrzeug f1 = new Auto(\"B\", 200, 8.5);\n        Fahrzeug f2 = new LKW(35.5);\n        fp1.fahrzeugKaufen(f1);\n        fp1.fahrzeugKaufen(f2);\n        System.out.println(fp1.toString());\n\n        System.out.printf(\"%n---- reisenImMonat(75) ----%n%n\");\n        fp1.reisenImMonat(75);\n        System.out.println(fp1.toString());\n\n        System.out.printf(\"%n---- alleLKWs ----%n%n\");\n        Fuhrpark lkws = fp1.alleLKWs();\n        System.out.println(lkws);\n\n        System.out.printf(\"%n---- meisten kilometer ----%n%n\");\n        Fahrzeug meistenKm = fp1.meistenKilometer();\n        meistenKm.print();\n\n        System.out.printf(\"%n---- hoechster gesamtverbrauch auto ----%n%n\");\n        Fahrzeug hoechsterVerbrauch = fp1.hoechsterGesamtverbrauchAuto();\n        hoechsterVerbrauch.print();\n\n        System.out.printf(\"%n---- fahrzeug loeschen ----%n%n\");\n        fp1.fahrzeugLoeschen(f1);\n        System.out.println(fp1.toString());\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.fahrzeug;\n\nimport java.util.Random;\n\npublic class Fahrzeug\n{\n    private String marke;\n    private int kmStand;\n    private int maxV;\n    private double verbrauch;\n\n    public Fahrzeug(String marke, int maxV, double verbrauch) {\n        this.marke = marke;\n        this.maxV = maxV;\n        this.kmStand = 0;\n        this.verbrauch = verbrauch;\n    }\n\n    public void fahren() {\n        Random r = new Random();\n        int reise = r.nextInt(1000);\n        this.kmStand += reise;\n    }\n\n    public double gesamtverbrauch() {\n        return this.kmStand * this.verbrauch / 100;\n    }\n\n    public int getKmStand() {\n        return this.kmStand;\n    }\n\n    public String getMarke()\n    {\n        return this.marke;\n    }\n\n    public int getMaxV()\n    {\n        return this.maxV;\n    }\n\n    public double getVerbrauch()\n    {\n        return this.verbrauch;\n    }\n\n    @Override\n    public String toString() {\n        String s = String.format(\"%-4s %3dkm/h %4.1fl/100km %7dkm %8.2fl\", this.marke, this.maxV, this.verbrauch, this.kmStand, this.gesamtverbrauch());\n        return s;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Fahrzeug other = (Fahrzeug)o;\n        return this.marke.equals(other.marke) &amp;&amp; this.kmStand == other.kmStand;\n    }\n\n    public void print() {\n        System.out.println(this.toString());\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.fahrzeug;\n\npublic class Auto extends Fahrzeug\n{\n\n    public Auto(String marke, int maxV, double verbrauch)\n    {\n        super(marke, maxV, verbrauch);\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.fahrzeug;\n\npublic class LKW extends Fahrzeug\n{\n\n    public LKW(double verbrauch)\n    {\n        super(\"LKW\", 100, verbrauch);\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.fahrzeug;\n\nimport java.util.Random;\n\npublic class Fuhrpark\n{\n    private Fahrzeug[] fuhrpark;\n    private int anzahl;\n\n    public Fuhrpark(int groesse) {\n        this.fuhrpark = new Fahrzeug[groesse];\n        this.anzahl = 0;\n    }\n\n    public void fahrzeugKaufen() {\n        Random r = new Random();\n        int zufzahl = r.nextInt(400) + 50;\n        double verbrauch = zufzahl / 10.0;\n\n        if(zufzahl &lt;= 250) {\n            String marke = \"A\" + this.anzahl;\n            this.fuhrpark[this.anzahl++] = new Auto(marke, zufzahl, verbrauch);\n        } else {\n            this.fuhrpark[this.anzahl++] = new LKW(verbrauch);\n        }\n    }\n\n    public void fahrzeugKaufen(Fahrzeug fahrzeug) {\n\n        this.fuhrpark[this.anzahl++] = fahrzeug;\n    }\n\n    public void reisenImMonat(int anzahlReisen) {\n        for(int reise = 0; reise &lt; anzahlReisen; reise++) {\n            Random r = new Random();\n            int zufIndex = r.nextInt(this.anzahl);\n            this.fuhrpark[zufIndex].fahren();\n        }\n    }\n\n    public Fahrzeug meistenKilometer() {\n        Fahrzeug meistenKm = this.fuhrpark[0];\n        for (int index = 1; index &lt; this.anzahl; index++)\n        {\n            if(this.fuhrpark[index].getKmStand() &gt; meistenKm.getKmStand()) {\n                meistenKm = this.fuhrpark[index];\n            }\n        }\n        return meistenKm;\n    }\n\n    public Fahrzeug hoechsterGesamtverbrauchAuto() {\n        double hoechsterVerbrauch = 0.0;\n        int indexMax = -1;\n        for (int index = 0; index &lt; this.anzahl; index++)\n        {\n            if(this.fuhrpark[index] instanceof Auto) {\n\n                if(this.fuhrpark[index].gesamtverbrauch() &gt; hoechsterVerbrauch) {\n\n                    hoechsterVerbrauch = this.fuhrpark[index].gesamtverbrauch();\n                    indexMax = index;\n                }\n            }\n        }\n        return this.fuhrpark[indexMax];\n    }\n\n    public boolean fahrzeugLoeschen(Fahrzeug fahrzeug) {\n        boolean deleted = false;\n        for (int index = 0; index &lt; this.anzahl &amp;&amp; !deleted; index++)\n        {\n            if(this.fuhrpark[index].equals(fahrzeug)) \n            {\n                deleted = true;\n                for(int i = index; i &lt; this.anzahl - 1; i++) \n                {\n                    this.fuhrpark[index] = this.fuhrpark[index+1];\n                }\n                this.anzahl--;\n            }\n        }\n        return deleted;\n    }\n\n    public int getAnzahl() {\n        return this.anzahl;\n    }\n\n    @Override\n    public String toString() {\n        String s = String.format(\"Im Fuhrpark sind %d Fahrzeuge : %n\", this.anzahl);\n        s += String.format(\"----------------------------- %n\");\n        for(int index = 0; index &lt; this.anzahl; index++) {\n            s += String.format(\"%s %n\", this.fuhrpark[index].toString());\n        }\n        s += String.format(\"----------------------------- %n%n\");\n        return s;\n    }\n\n    public Fuhrpark alleLKWs() {\n        int anzahlLKWs = 0;\n        for (int index = 0; index &lt; this.anzahl; index++)\n        {\n            if(fuhrpark[index] instanceof LKW) anzahlLKWs++;\n        }\n        Fuhrpark fp = new Fuhrpark(anzahlLKWs);\n        for (int index = 0; index &lt; this.anzahl; index++)\n        {\n            if(fuhrpark[index] instanceof LKW) {\n                fp.fahrzeugKaufen(fuhrpark[index]);\n            }\n        }\n        return fp;\n    }\n\n}\n</code></pre> Akku <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.akku</code>. </li> <li> <p>(Teil 1) Erstellen Sie in diesem package eine Klasse <code>Akku</code> mit </p> <ul> <li> <p>den privaten Objektvariablen <code>typ</code> vom Typ <code>String</code> (Typ des Akkus), <code>kapazitaet</code> vom Typ <code>int</code> (Akku-Kapazit\u00e4t) und <code>anzahlLadungen</code> vom Typ <code>int</code> (Anzahl der bisherigen Ladungen des Akkus). </p> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Akku</code> einen parametrisierten Konstruktor, dem die Parameter <code>String typ</code> und <code>int kapazitaet</code> \u00fcbergeben werden. Mit den Parameterwerten werden die entsprechenden Objektvariablen initialisiert. Die Objektvariable <code>anzahlLadungen</code> wird mit dem Wert <code>0</code> initialisiert.</p> </li> <li> <p>Erstellen Sie eine Methode <code>laden()</code>, die den Wert der Objektvariablen <code>anzahlLadungen</code> um <code>1</code> erh\u00f6ht. </p> </li> <li> <p>Erstellen Sie eine Methode <code>getZustand()</code>, die ein <code>int</code> zur\u00fcckgibt. Der Zustand berechnet sich wie folgt:</p> <ul> <li>Ist der Akku neu, ist der Zustand bei 100%.</li> <li>Durch alle 100 Ladungen verringert sich der Zustand um 1%. </li> <li>Der Zustand kann nicht kleiner als 0% werden.</li> </ul> <p>Sie m\u00fcssen also die <code>anzahlLadungen</code> betrachten und durch alle 100 Ladungen reduziert sich der Zustands-Wert <code>100</code> um 1.  Beispiele: </p> <ul> <li><code>anzahlLadungen</code>: 99 \u2192 Zustand 100</li> <li><code>anzahlLadungen</code>: 199 \u2192 Zustand 99</li> <li><code>anzahlLadungen</code>: 1099 \u2192 Zustand 90</li> <li><code>anzahlLadungen</code>: 10099 \u2192 Zustand 0</li> </ul> <p>Tipps: </p> <ul> <li>Nutzen Sie die Integer-Division durch 100, um zu ermitteln, welchen Wert Sie von 100 abziehen m\u00fcssen.</li> <li>Pr\u00fcfen Sie, ob das Ergebnis unter 0 ist, dann geben Sie 0 zur\u00fcck.</li> </ul> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein formatierter String in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte): </p> <pre><code>A1  : 10000mAh   984 Ladungen. Zustand  91%\n</code></pre> <p>Beachten Sie: <code>A1</code> ist der Typ des Akkus.  </p> <ul> <li>reservieren Sie f\u00fcr den Typ 4 Zeichen (dann kommt ein Doppelpunkt <code>:</code>),</li> <li>reservieren Sie f\u00fcr die Kapazit\u00e4t 5 Zeichen (dann kommt <code>mAh</code>),</li> <li>reservieren Sie f\u00fcr die Anzahl der Ladungen 5 Zeichen (dann kommt <code>Ladungen. Zustand</code>),</li> <li>reservieren Sie f\u00fcr den Zustand 3 Zeichen (dann kommt <code>%</code> \u2192 siehe Tipp). </li> </ul> <p>Tipp: </p> <ul> <li>das <code>%</code>-Zeichen in einem formatierten String wird durch <code>%%</code> erzeugt.</li> </ul> </li> <li> <p>Erstellen Sie eine <code>print()</code>-Methode, die den von <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>equals(Object o)</code> so, dass zwei Akkus gleich sind, wenn sie denselben Typ haben. </p> </li> <li> <p>Erstellen Sie eine <code>Testklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode vier <code>Akku</code>-Objekte mit den folgenden Werten f\u00fcr die Objektvariablen:</p> <pre><code>\"A1\", 10000\n\"A2\", 20000\n\"A3\", 30000\n\"A4\", 40000\n</code></pre> <p>Geben Sie alle vier <code>Akku</code>-Objekte auf die Konsole unter Verwendung der <code>print()</code>-Methode aus. Es entsteht folgende Ausgabe:</p> <pre><code>A1  : 10000mAh     0 Ladungen. Zustand 100% \nA2  : 20000mAh     0 Ladungen. Zustand 100% \nA3  : 30000mAh     0 Ladungen. Zustand 100% \nA4  : 40000mAh     0 Ladungen. Zustand 100%\n</code></pre> </li> <li> <p>Erweitern Sie die <code>main()</code>-Methode der <code>Testklasse</code> um eine Schleife, um <code>4000</code> Ladungen durchzuf\u00fchren. Innerhalb dieser Schleife wird eine Zufallszahl aus dem Bereich <code>[0, \u2026, 3]</code> ( <code>3</code> inkl.) erzeugt. Nutzen Sie dazu die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket. </p> <ul> <li>Ist die Zufallszahl <code>0</code>, wird der erste Akku (<code>A1</code>) geladen. </li> <li>Ist die Zufallszahl <code>1</code>, wird der zweite Akku (<code>A2</code>) geladen.</li> <li>Ist die Zufallszahl <code>2</code>, wird der dritte Akku (<code>A3</code>) geladen.</li> <li>Ist die Zufallszahl <code>3</code>, wird der vierte Akku (<code>A4</code>) geladen</li> </ul> <p>Rufen Sie f\u00fcr die vier Akkus jeweils die <code>print()</code>-Methode auf. Es entsteht folgende Ausgabe (Zufallswerte):</p> <pre><code>A1  : 10000mAh   984 Ladungen. Zustand  91% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90% \nA4  : 40000mAh  1039 Ladungen. Zustand  90%\n</code></pre> </li> </ul> </li> <li> <p>(Teil 2) Erstellen Sie eine Klasse <code>AkkuBestand</code> mit </p> <ul> <li> <p>der privaten Objektvariable <code>akkus</code> vom Typ <code>Akku[]</code>. </p> </li> <li> <p>Erstellen Sie einen parameterlosen Konstruktor. In dem Konstruktor wird das <code>akkus</code>-Array mit der L\u00e4nge <code>0</code> erzeugt. </p> </li> <li> <p>Erstellen Sie eine Methode <code>akkuBereitsImBestand(Akku a)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>a</code> bereits in <code>akkus</code> enthalten ist und <code>false</code> sonst.</p> </li> <li> <p>Erstellen Sie eine Methode <code>akkuHinzufuegen(Akku a)</code>. Diese Methode f\u00fcgt den Akku <code>a</code> dem <code>akkus</code>-Array hinzu.  Die Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>a</code> dem <code>akkus</code>-Array hinzugef\u00fcgt wurde und ein <code>false</code>, wenn nicht.  Der Akku <code>a</code> wird genau dann nicht dem <code>akkus</code>-Array hinzugef\u00fcgt, wenn er bereits im <code>akkus</code>-Array enthalten ist! </p> <p>Tipps: </p> <ul> <li>Nutzen Sie die Methode <code>akkuBereitsImBestand(Akku a)</code>, um zu ermitteln, ob <code>a</code> bereits in <code>akkus</code> enthalten ist.</li> <li>Wenn <code>a</code> hinzugef\u00fcgt wird, muss das <code>akkus</code>-Array um <code>1</code> gr\u00f6\u00dfer werden.</li> </ul> </li> <li> <p>Erstellen Sie eine Methode <code>akkuEntfernen(Akku a)</code>. Diese Methode entfernt den Akku <code>a</code> aus dem <code>akkus</code>-Array.  Die Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>a</code> aus dem <code>akkus</code>-Array entfernt wurde und ein <code>false</code>, wenn nicht.  Der Akku <code>a</code> wird genau dann nicht aus dem <code>akkus</code>-Array entfernt, wenn er gar nicht im <code>akkus</code>-Array enthalten ist! </p> <p>Tipps: </p> <ul> <li>Nutzen Sie die Methode <code>akkuBereitsImBestand(Akku a)</code>, um zu ermitteln, ob <code>a</code> \u00fcberhaupt in <code>akkus</code> enthalten ist.</li> <li>Wenn <code>a</code> entfernt wurde, muss das <code>akkus</code>-Array danach um <code>1</code> kleiner sein.</li> </ul> </li> <li> <p>Erstellen Sie eine Methode <code>getLength()</code>, die die L\u00e4nge des <code>akkus</code>-Arrays zur\u00fcckgibt.</p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein <code>String</code> in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte): </p> <pre><code>Bestand (3): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90%\n</code></pre> <p>Die Zahl in Klammern rechts von <code>Bestand</code> gibt die L\u00e4nge des <code>akkus</code>-Arrays an (hier <code>(3)</code>).</p> <p>Beachten Sie! Enth\u00e4lt das <code>akkus</code>-Array keine Akkus, dann soll folgender String zur\u00fcckgegeben werden: </p> <pre><code>Derzeit sind keine Akkus im Bestand.\n</code></pre> </li> <li> <p>Erstellen Sie eine <code>print()</code>-Methode, die den von <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein Objekt von <code>AkkuBestand</code>. Geben Sie das <code>AkkuBestand</code>-Objekt unter Verwendung der <code>print()</code>-Methode auf die Konsole aus. Es entsteht folgende Ausgabe:</p> <pre><code>Derzeit sind keine Akkus im Bestand.\n</code></pre> <ol> <li> <p>F\u00fcgen Sie den Akku <code>A1</code> aus Teil 1 dem <code>AkkuBestand</code>-Objekt hinzu. Beachten Sie dabei die R\u00fcckgabe der <code>akkuHinzufuegen()</code>-Methode. Wird der Akku hinzugef\u00fcgt, soll die Ausgabe </p> <pre><code>Akku hinzugefuegt!\n</code></pre> <p>auf der Konsole erscheinen. Wird er nicht hinzugef\u00fcgt, erscheint</p> <pre><code>Akku nicht hinzugefuegt!\n</code></pre> </li> <li> <p>Rufen Sie die <code>print()</code>-Methode f\u00fcr das <code>AkkuBestand</code>-Objekt auf. Es erscheint:</p> <pre><code>Bestand (1): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91%\n</code></pre> </li> <li> <p>Wiederholen Sie die Schritte <code>a</code> und <code>b</code> f\u00fcr </p> <ul> <li>Akku <code>A2</code> aus Teil 1 (wird tats\u00e4chlich hinzugef\u00fcgt),</li> <li>Akku <code>A3</code> aus Teil 1 (wird tats\u00e4chlich hinzugef\u00fcgt) und</li> <li>nochmal Akku <code>A3</code> aus Teil 1 (wird nicht hinzugef\u00fcgt)</li> </ul> <p>Insgesamt entsteht folgende Ausgabe:</p> <pre><code>Akku hinzugefuegt!\nBestand (1): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \n\nAkku hinzugefuegt!\nBestand (2): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \n\nAkku hinzugefuegt!\nBestand (3): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90% \n\nAkku nicht hinzugefuegt!\nBestand (3): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90%\n</code></pre> </li> <li> <p>Entfernen Sie mithilfe der <code>akkuEntfernen()</code>-Methode den Akku <code>A2</code> zwei Mal (einmal wird er tats\u00e4chlich entfernt und einmal nicht) und ber\u00fccksichtigen Sie die R\u00fcckgabe der Methode, so dass folgende Ausgaben entstehen (jeweils auch <code>print()</code>-Methode von <code>AkkuBestand</code> aufrufen) :</p> <pre><code>Akku entfernt!\nBestand (2): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90% \n\nAkku nicht entfernt!\nBestand (2): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90%\n</code></pre> </li> </ol> </li> </ul> </li> <li> <p>(Teil 3) <code>AkkuBestand</code> - Teil 2 </p> <ul> <li> <p>Erstellen Sie einen weiteren Konstruktor in der <code>AkkuBestand</code>-Klasse. Diesem Konstruktor soll ein <code>AkkuBestand</code>-Objekt als Parameter \u00fcbergeben werden. Das <code>akkus</code>-Array des neu zu erstellenden Objektes soll alle <code>Akku</code>-Objekte des als Parameter \u00fcbergebenen <code>AkkuBestand</code>-Objektes aufnehmen.</p> </li> <li> <p>Testen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> den neuen Konstruktor, indem Sie ein neues <code>AkkuBestand</code>-Objekt erzeugen und dem Konstruktor den alten <code>AkkuBestand</code> aus Teil 2 \u00fcbergeben. Rufen Sie f\u00fcr das neue <code>AkkuBestand</code>-Objekt die <code>print()</code>-Methode auf. Es sollte erscheinen (Zufallswerte):</p> <pre><code>Bestand (2): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90%\n</code></pre> </li> <li> <p>F\u00fcgen Sie nun dem neuen <code>AkkuBestand</code>-Objekt auch noch die <code>Akku</code>-Objekte  <code>A2</code> und <code>A4</code> hinzu und rufen Sie die <code>print()</code>-Methode erneut auf. Es sollte erscheinen (Zufallswerte):</p> <pre><code>Bestand (4): \n\nA1  : 10000mAh   984 Ladungen. Zustand  91% \nA3  : 30000mAh  1032 Ladungen. Zustand  90% \nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA4  : 40000mAh  1039 Ladungen. Zustand  90%\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>AkkuBestand</code> eine Methode <code>fehlendeAkkus(AkkuBestand ab)</code>. Diese Methode gibt ein <code>Akku</code>-Array zur\u00fcck. Das zur\u00fcckgegebene <code>Akku</code>-Array enth\u00e4lt alle <code>Akku</code>-Objekte, die im <code>akkus</code>-Array von <code>ab</code>, nicht aber im <code>akkus</code>-Array des aufrufenden <code>AkkuBestand</code>-Objektes enthalten sind. </p> </li> <li> <p>Testen Sie die <code>fehlendeAkkus()</code>-Methode in der <code>main()</code>-Methode der <code>Testklasse</code>, indem Sie sie f\u00fcr das <code>AkkuBestand</code>-Objekt aus Teil 2 aufrufen und das neue <code>AkkuBestand</code>-Objekt als Parameter \u00fcbergeben, welches alle <code>Akku</code>-Typen enth\u00e4lt. Geben Sie die Akkus des zur\u00fcckgegebenen <code>Akku</code>-Arrays aus  (direkt in der <code>main()</code>-Methode). Es entsteht folgende Ausgabe (Zufallswerte):</p> <pre><code>Fehlende : \n\nA2  : 20000mAh   945 Ladungen. Zustand  91% \nA4  : 40000mAh  1039 Ladungen. Zustand  90%\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>AkkuBestand</code> eine Methode <code>schlechtesterZustand()</code>. Diese Methode gibt das (erste) <code>Akku</code>-Objekt zur\u00fcck, das im <code>akkus</code>-Array den kleinsten <code>Zustands</code>-Wert hat. Sie k\u00f6nnen davon ausgehen, dass mindestens ein Akku im <code>akkus</code>-Array ist.</p> <p>Testen Sie die Methode in der <code>main()</code>-Methode, z.B. </p> <pre><code>Akku mit schlechtestem Zustand : \nA3  : 30000mAh  1032 Ladungen. Zustand  90% \n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>AkkuBestand</code> eine Methode <code>getAkkuAtIndex(int index)</code>. Diese Methode gibt den <code>Akku</code> zur\u00fcck, der im <code>akkus</code>-Array unter dem Index <code>index</code> gespeichert ist. Ist <code>index</code> kein g\u00fcltiger Index (zu klein oder zu gro\u00df) aus dem <code>akkus</code>-Array, dann geben Sie <code>null</code> zur\u00fcck.</p> </li> <li> <p>Testen Sie die <code>getAkkuAtIndex(int index)</code> wie folgt:</p> <ul> <li> <p>Falls Sie einen ung\u00fcltigen Index \u00fcbergeben, dann soll die Ausgabe so sein:</p> <pre><code>Kein gueltiger Index!\n</code></pre> </li> <li> <p>Falls Sie einen korrekten Index \u00fcbergeben, wird das zur\u00fcckgegebene Akku ausgegeben, z.B. </p> <pre><code>A2  : 20000mAh   995 Ladungen. Zustand  91%\n</code></pre> </li> </ul> </li> <li> <p>Erstellen Sie in der Klasse <code>AkkuBestand</code> eine Methode <code>akkusMitSchlechtemZustand()</code>. Diese Methode gibt ein <code>Akku</code>-Array zur\u00fcck. Das zur\u00fcckgegebene <code>Akku</code>-Array enth\u00e4lt alle <code>Akku</code>-Objekte des <code>akkus</code>-Arrays, deren Zustand unter 10% ist.</p> </li> <li> <p>Testen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> die <code>akkusMitSchlechtemZustand()</code>-Methode wie folgt:</p> <ul> <li> <p>in einer Schleife laden Sie alle Akkus aus dem <code>AkkuBestand</code>-Objekt, welches alle <code>Akku</code>-Typen enth\u00e4lt (haben Sie hier in Teil 3 erstellt)</p> </li> <li> <p>Sie laden alle Akkus solange, bis alle Akkus in dem zur\u00fcckgegebenen Array der <code>akkusMitSchlechtemZustand()</code> enthalten sind (reicht zu pr\u00fcfen, dass das zur\u00fcckgegebene Array die L\u00e4nge <code>4</code> hat). Geben Sie dann dieses Array aus. Es erscheint z.B. (Zufallswerte):</p> <pre><code>Bestand (4): \n\nA1  : 10000mAh  9143 Ladungen. Zustand   9% \nA3  : 30000mAh  9158 Ladungen. Zustand   9% \nA2  : 20000mAh  9127 Ladungen. Zustand   9% \nA4  : 40000mAh  9100 Ladungen. Zustand   9%\n</code></pre> </li> </ul> </li> </ul> </li> <li> <p>Zur Kontrolle: Die m\u00f6glichen Ausgaben (Beispielwerte) k\u00f6nnten sein:</p> <pre><code>----------- Teil 1 - Akku: Objekte erzeugen -----------\n\nA1  : 10000mAh     0 Ladungen. Zustand 100% \nA2  : 20000mAh     0 Ladungen. Zustand 100% \nA3  : 30000mAh     0 Ladungen. Zustand 100% \nA4  : 40000mAh     0 Ladungen. Zustand 100% \n\n\n------------ Teil 2 - Akku: 4000 Ladungen ------------\n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA2  : 20000mAh   995 Ladungen. Zustand  91% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \nA4  : 40000mAh   968 Ladungen. Zustand  91% \n\n\n------------ Teil 3 - AkkuBestand ------------\n\nDerzeit sind keine Akkus im Bestand.\n\nAkku hinzugefuegt!\nBestand (1): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \n\nAkku hinzugefuegt!\nBestand (2): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA2  : 20000mAh   995 Ladungen. Zustand  91% \n\nAkku hinzugefuegt!\nBestand (3): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA2  : 20000mAh   995 Ladungen. Zustand  91% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \n\nAkku nicht hinzugefuegt!\nBestand (3): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA2  : 20000mAh   995 Ladungen. Zustand  91% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \n\nAkku entfernt!\nBestand (2): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \n\nAkku nicht entfernt!\nBestand (2): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \n\n\n------------ Teil 4 - AkkuBestand ------------\n\nBestand (2): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \n\nBestand (4): \n\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \nA3  : 30000mAh  1026 Ladungen. Zustand  90% \nA2  : 20000mAh   995 Ladungen. Zustand  91% \nA4  : 40000mAh   968 Ladungen. Zustand  91% \n\nFehlende : \n\nA2  : 20000mAh   995 Ladungen. Zustand  91% \nA4  : 40000mAh   968 Ladungen. Zustand  91% \n\nKein gueltiger Index!\nA2  : 20000mAh   995 Ladungen. Zustand  91% \n\nAkku mit schlechtestem Zustand :\nA1  : 10000mAh  1011 Ladungen. Zustand  90% \n\nBestand (4): \n\nA1  : 10000mAh  9143 Ladungen. Zustand   9% \nA3  : 30000mAh  9158 Ladungen. Zustand   9% \nA2  : 20000mAh  9127 Ladungen. Zustand   9% \nA4  : 40000mAh  9100 Ladungen. Zustand   9%\n</code></pre> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Akku Testklasse.javaAkku.javaAkkuBestand.java <pre><code>package klausurvorbereitung.akku;\n\nimport java.util.Random;\n\npublic class Testklasse {\n\n    public static void main(String[] args) {\n\n        System.out.printf(\"%n%n----------- Teil 1 - Akku: Objekte erzeugen -----------%n%n\");\n        Akku a1 = new Akku(\"A1\", 10000);\n        Akku a2 = new Akku(\"A2\", 20000);\n        Akku a3 = new Akku(\"A3\", 30000);\n        Akku a4 = new Akku(\"A4\", 40000);\n\n        a1.print();\n        a2.print();\n        a3.print();\n        a4.print();\n\n        System.out.printf(\"%n%n------------ Teil 2 - Akku: 4000 Ladungen ------------%n%n\");\n\n        int anzLadungen = 4000;\n        Random r = new Random();\n        for(int i=0; i&lt;anzLadungen; i++)\n        {\n            int zufZahl = r.nextInt(4);\n            if(zufZahl==0)\n            {\n                a1.laden();\n            } \n            else if(zufZahl==1)\n            {\n                a2.laden();\n            }\n            else if(zufZahl==2)\n            {\n                a3.laden();\n            }\n            else if(zufZahl==3)\n            {\n                a4.laden();\n            }\n        }\n\n        a1.print();\n        a2.print();\n        a3.print();\n        a4.print();\n\n\n        System.out.printf(\"%n%n------------ Teil 3 - AkkuBestand ------------%n%n\");\n\n        AkkuBestand ab1 = new AkkuBestand();\n        ab1.print();\n\n        boolean result = false;\n\n        result = ab1.akkuHinzufuegen(a1);\n        if(result)\n        {\n            System.out.println(\"Akku hinzugefuegt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht hinzugefuegt!\");\n        }\n        ab1.print();\n\n        result = ab1.akkuHinzufuegen(a2);\n        if(result)\n        {\n            System.out.println(\"Akku hinzugefuegt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht hinzugefuegt!\");\n        }\n        ab1.print();\n\n        result = ab1.akkuHinzufuegen(a3);\n        if(result)\n        {\n            System.out.println(\"Akku hinzugefuegt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht hinzugefuegt!\");\n        }\n        ab1.print();\n\n        result = ab1.akkuHinzufuegen(a3);\n        if(result)\n        {\n            System.out.println(\"Akku hinzugefuegt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht hinzugefuegt!\");\n        }\n        ab1.print();\n\n        result = ab1.akkuEntfernen(a2);\n        if(result)\n        {\n            System.out.println(\"Akku entfernt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht entfernt!\");\n        }\n        ab1.print();\n\n        result = ab1.akkuEntfernen(a2);\n        if(result)\n        {\n            System.out.println(\"Akku entfernt!\");\n        }\n        else\n        {\n            System.out.println(\"Akku nicht entfernt!\");\n        }\n        ab1.print();\n\n        System.out.printf(\"%n%n------------ Teil 4 - AkkuBestand ------------%n%n\");\n\n        AkkuBestand alle = new AkkuBestand(ab1);\n        alle.print();\n        alle.akkuHinzufuegen(a2);\n        alle.akkuHinzufuegen(a4);\n        alle.print();\n\n        Akku[] fehlende = ab1.fehlendeAkkus(alle);\n        System.out.printf(\"%nFehlende : %n%n\");\n        for (int i = 0; i &lt; fehlende.length; i++) \n        {\n            fehlende[i].print();\n        }\n\n        Akku atIndex = alle.getAkkuAtIndex(-5);\n        if(atIndex == null)\n        {\n            System.out.println(\"Kein gueltiger Index!\");\n        }\n        else\n        {\n            atIndex.print();\n        }\n        atIndex = alle.getAkkuAtIndex(2);\n        if(atIndex == null)\n        {\n            System.out.println(\"Kein gueltiger Index!\");\n        }\n        else\n        {\n            atIndex.print();\n        }\n\n        Akku schlechtesteZustand = ab1.schlechtesterZustand();\n        System.out.println(\"Akku mit schlechtestem Zustand :\");\n        schlechtesteZustand.print();\n        System.out.println();\n\n        Akku[] schlechte = alle.akkusMitSchlechtemZustand();\n        while(schlechte.length &lt; 4)\n        {\n            for (int i = 0; i &lt; alle.getLength(); i++) \n            {\n                alle.getAkkuAtIndex(i).laden();\n            }\n            schlechte = alle.akkusMitSchlechtemZustand();\n        }\n        alle.print();\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.akku;\n\npublic class Akku {\n    private String typ;\n    private int kapazitaet;\n    private int anzahlLadungen;\n\n    public Akku(String typ, int kapazitaet)\n    {\n        this.typ = typ;\n        this.kapazitaet = kapazitaet;\n        this.anzahlLadungen = 0;\n    }\n\n    public void laden()\n    {\n        this.anzahlLadungen++;\n    }\n\n    public int getZustand()\n    {\n        int zustand = 100;\n        zustand = (zustand - (this.anzahlLadungen/100));\n        if(zustand &lt; 0) zustand = 0;\n        return zustand;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%-4s: %5dmAh %5d Ladungen. Zustand %3d%% %n\", this.typ, this.kapazitaet, this.anzahlLadungen, this.getZustand());\n        return s;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(o.getClass() != this.getClass()) return false;\n\n        Akku a = (Akku)o;\n        return a.typ.equals(this.typ);\n    }\n\n    public void print()\n    {\n        System.out.print(this.toString());\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.akku;\n\npublic class AkkuBestand {\n    private Akku[] akkus;\n\n    public AkkuBestand()\n    {\n        this.akkus = new Akku[0];\n    }\n\n    public AkkuBestand(AkkuBestand ab)\n    {\n        this.akkus = new Akku[0];\n        for (int i = 0; i &lt; ab.akkus.length; i++) \n        {\n            this.akkuHinzufuegen(ab.akkus[i]);\n        }\n    }\n\n    public int getLength()\n    {\n        return this.akkus.length;\n    }\n\n    public boolean akkuBereitsImBestand(Akku a)\n    {\n        for(int i=0; i&lt;this.akkus.length; i++)\n        {\n            if(this.akkus[i] != null &amp;&amp; this.akkus[i].equals(a)) return true;\n        }\n        return false;\n    }\n\n    public boolean akkuHinzufuegen(Akku a)\n    {\n        if(akkuBereitsImBestand(a))\n        {\n            return false;\n        }\n        else\n        {\n            Akku[] neu = new Akku[this.akkus.length+1];\n            for(int i=0; i &lt; this.akkus.length; i++)\n            {\n                neu[i] = this.akkus[i];\n            }\n            neu[this.akkus.length] = a;\n            this.akkus = neu;\n            return true;\n        }\n    }\n\n    public boolean akkuEntfernen(Akku a)\n    {\n        if(!akkuBereitsImBestand(a))\n        {\n            return false;\n        }\n        else\n        {\n            Akku[] neu = new Akku[this.akkus.length-1];\n            int indexNeu = 0;\n            for(int i=0; i &lt; this.akkus.length; i++)\n            {\n                if(!this.akkus[i].equals(a))\n                {\n                    neu[indexNeu++] = this.akkus[i];\n                }   \n            }\n            this.akkus = neu;\n            return true;\n        }\n    }\n\n    public Akku schlechtesterZustand()\n    {\n        Akku merke = this.akkus[0];\n        for (int i = 1; i &lt; this.akkus.length; i++) \n        {\n            if(this.akkus[i].getZustand() &lt; merke.getZustand())\n            {\n                merke = this.akkus[i];\n            }\n        }\n        return merke;\n    }\n\n    public Akku[] fehlendeAkkus(AkkuBestand ab)\n    {\n        int anzahlFehlende = 0;\n        for (int i = 0; i &lt; ab.akkus.length; i++) \n        {\n            if(!this.akkuBereitsImBestand(ab.akkus[i]))\n            {\n                anzahlFehlende++;\n            }\n        }\n        Akku[] fehlende = new Akku[anzahlFehlende];\n        int indexFehlende = 0;\n        for (int i = 0; i &lt; ab.akkus.length; i++) \n        {\n            if(!this.akkuBereitsImBestand(ab.akkus[i]))\n            {\n                fehlende[indexFehlende++] = ab.akkus[i];\n            }\n        }\n        return fehlende;\n    }\n\n    public Akku getAkkuAtIndex(int index)\n    {\n        if(index&lt;0 || index &gt;= this.akkus.length)\n        {\n            return null;\n        }\n        else\n        {\n            return this.akkus[index];\n        }\n    }\n\n    public Akku[] akkusMitSchlechtemZustand()\n    {\n        int anzahlSchlechte = 0;\n        for (int i = 0; i &lt; this.akkus.length; i++) \n        {\n            if(this.akkus[i].getZustand() &lt; 10)\n            {\n                anzahlSchlechte++;\n            }\n        }\n        Akku[] schlechte = new Akku[anzahlSchlechte];\n        int indexSchlechte = 0;\n        for (int i = 0; i &lt; this.akkus.length; i++) \n        {\n            if(this.akkus[i].getZustand() &lt; 10)\n            {\n                schlechte[indexSchlechte++] = this.akkus[i];\n            }\n        }\n        return schlechte;\n    }\n\n    @Override\n    public String toString()\n    {\n        if(this.akkus.length == 0)\n        {\n            String s = String.format(\"Derzeit sind keine Akkus im Bestand.%n%n\");\n            return s;\n        }\n        else\n        {\n            String s = String.format(\"Bestand (%d): %n%n\", this.getLength());\n            for(int i=0; i&lt;this.akkus.length; i++)\n            {\n                s += this.akkus[i].toString();\n            }\n            return s;\n        }\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n}\n</code></pre> Buch <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.buch</code>. </li> <li> <p>(Teil 1) Erstellen Sie in diesem package eine Klasse <code>Buch</code> mit </p> <ul> <li> <p>den privaten Objektvariablen <code>titel</code> vom Typ <code>String</code> (Titel des Buches), <code>seiten</code> vom Typ <code>int</code> (Anzahl der Seiten des Buches) und <code>jahr</code> vom Typ <code>int</code> (Erscheinungsjahr des Buches). </p> </li> <li> <p>Erstellen Sie f\u00fcr die Klasse <code>Buch</code> einen parametrisierten Konstruktor, dem f\u00fcr jede der drei Objektvariablen ein Wert als Parameter \u00fcbergeben wird. Mit den Parameterwerten werden die Objektvariablen initialisiert. </p> </li> <li> <p>Erstellen Sie eine Methode <code>getJahr()</code>, die den Wert der Objektvariablen <code>jahr</code> zur\u00fcckgibt. </p> </li> <li> <p>Erstellen Sie eine Methode <code>istDicker(Buch b)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende <code>Buch</code>-Objekt mehr <code>seiten</code> hat, als <code>b</code>. Ansonsten wird <code>false</code> zur\u00fcckgegeben.</p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>, so, dass ein String in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte):      <pre><code>Titel Z   : 133 Seiten, von 1958\n</code></pre> Beachten Sie: <code>Titel Z</code> ist der Titel des Buches. Reservieren Sie f\u00fcr den Titel <code>10</code> Zeichen (dann kommt ein Doppelpunkt <code>:</code>, reservieren Sie f\u00fcr die Seitenzahl <code>3</code> Zeichen und f\u00fcr die Jahreszahl <code>4</code> Zeichen. </p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>equals(Object o)</code> so, dass zwei B\u00fccher gleich sind, wenn sie denselben Titel haben.    </p> </li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. </p> <ul> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode drei <code>Buch</code>-Objekte mit den folgenden Werten f\u00fcr die Objektvariablen:     <pre><code>\"Titel A\", 55, 1999\n\"Titel B\", 66, 2000\n\"Titel C\", 77, 2001 \n</code></pre></p> </li> <li> <p>Geben Sie alle drei <code>Buch</code>-Objekte auf die Konsole unter Verwendung der <code>toString()</code>-Methode aus. Es entsteht folgende Ausgabe:     <pre><code>Titel A   :  55 Seiten, von 1999\nTitel B   :  66 Seiten, von 2000\nTitel C   :  77 Seiten, von 2001\n</code></pre></p> </li> </ul> </li> <li> <p>(Teil 2) Erweitern Sie die Klasse <code>Buch</code> um einen parameterlosen Konstruktor. In diesem Konstruktor werden die Werte f\u00fcr die Objektvariablen zuf\u00e4llig erzeugt. Nutzen Sie dazu die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket.  Beachten Sie:</p> <ul> <li> <p>Nutzen Sie immer die <code>nextInt(bound)</code>-Methode aus der <code>Random</code>-Klasse.</p> </li> <li> <p>Der Wert f\u00fcr <code>jahr</code> soll im Bereich von <code>1900</code> (inkl.) bis <code>2021</code> (inkl.) liegen (<code>122</code> verschiedene Jahreszahlen m\u00f6glich).</p> </li> <li> <p>Der Wert f\u00fcr <code>seiten</code> soll im Bereich <code>20</code> (inkl.) bis <code>199</code> (inkl.) liegen (<code>180</code> verschiedene Seitenzahlen m\u00f6glich).</p> </li> <li> <p>Der Wert f\u00fcr <code>title</code> ergibt sich aus <code>Titel</code> gefolgt von einem Gro\u00dfbuchstaben. Der Gro\u00dfbuchstabe soll zuf\u00e4llig erzeugt werden. Tipp: Der Ascii-Wert von <code>A</code> ist <code>65</code>, der von <code>B</code> ist <code>66</code> usw. und das Alphabet hat <code>26</code> Buchstaben. M\u00f6gliche Titel k\u00f6nnen also z.B. sein:     <pre><code>Titel A\nTitel B\nTitel C\n\u2026\n</code></pre></p> </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein Array von <code>Buch</code>-Objekten. </p> <ul> <li> <p>Das Array hat die L\u00e4nge <code>10</code>.</p> </li> <li> <p>Bef\u00fcllen Sie in einer Schleife das Array mit <code>Buch</code>-Objekten unter Verwendung des parameterlosen Konstruktors. </p> </li> <li> <p>Berechnen Sie f\u00fcr alle erzeugten <code>Buch</code>-Objekte das Alter (ausgehend von aktuellen Jahr <code>2022</code> \u2013 ein Buch von <code>2021</code> ist also <code>1</code> Jahr alt, ein Buch von <code>1950</code> ist <code>72</code> Jahre alt).</p> </li> <li> <p>Geben Sie alle B\u00fccher des Arrays und deren Alter auf der Konsole aus, so dass folgende Ausgabe entsteht (Beispielwerte):</p> <pre><code>Titel E   :  84 Seiten, von 1944 --&gt;  78 Jahre alt \nTitel G   :  55 Seiten, von 1964 --&gt;  58 Jahre alt \nTitel Z   :  52 Seiten, von 1975 --&gt;  47 Jahre alt \nTitel T   :  28 Seiten, von 1937 --&gt;  85 Jahre alt \nTitel H   : 190 Seiten, von 1964 --&gt;  58 Jahre alt \nTitel F   : 145 Seiten, von 1935 --&gt;  87 Jahre alt \nTitel V   :  77 Seiten, von 1989 --&gt;  33 Jahre alt \nTitel O   : 122 Seiten, von 2008 --&gt;  14 Jahre alt \nTitel P   : 143 Seiten, von 2011 --&gt;  11 Jahre alt \nTitel A   : 112 Seiten, von 2010 --&gt;  12 Jahre alt\n</code></pre> </li> </ul> </li> <li> <p>(Teil 3) Erstellen Sie eine Klasse <code>Bibliothek</code>. Objektvariable ist <code>buecher</code> vom Typ <code>Buch[]</code>. Die Objektvariable ist nur innerhalb der Klasse sichtbar!</p> <ul> <li> <p>Erstellen Sie einen parametrisierten Konstruktor, dem als Parameter eine <code>anzBuecher</code> \u00fcbergeben wird. Der Wert von <code>anzBuecher</code> entspricht der L\u00e4nge des <code>buecher</code>-Arrays. Erzeugen Sie das Array im Konstruktor und bef\u00fcllen Sie es mit <code>Buch</code>-Objekten unter Verwendung des parameterlosen Konstruktors von <code>Buch</code>. </p> </li> <li> <p>Erstellen Sie eine Methode <code>sort(boolean vonDuennZuDick)</code>. In dieser Methode wird das <code>buecher</code>-Array sortiert. </p> <ul> <li> <p>Ist der Parameterwert <code>true</code>, dann werden die B\u00fccher aufsteigend vom Buch mit den wenigsten Seiten bis hoch zum Buch mit den meisten Seiten sortiert.</p> </li> <li> <p>Ist der Parameterwert <code>false</code>, dann werden die B\u00fccher absteigend vom Buch mit den meisten Seiten bis hoch zum Buch mit den wenigsten Seiten sortiert.</p> </li> </ul> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code> so, dass ein <code>String</code> in der folgenden Form zur\u00fcckgegeben wird (Beispielwerte):      <pre><code>Bibliothek mit  10 Buechern \n\n 1. Titel Q   :  77 Seiten, von 1963 \n 2. Titel N   :  55 Seiten, von 1982 \n 3. Titel W   : 112 Seiten, von 2017 \n 4. Titel R   :  26 Seiten, von 1989 \n 5. Titel W   : 161 Seiten, von 2002 \n 6. Titel N   : 147 Seiten, von 1949 \n 7. Titel U   :  80 Seiten, von 1955 \n 8. Titel S   : 148 Seiten, von 1948 \n 9. Titel A   :  96 Seiten, von 1980 \n10. Titel S   :  77 Seiten, von 1920 \n</code></pre></p> </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein Objekt von <code>Bibliothek</code>. \u00dcbergeben Sie als Parameterwert die <code>10</code>.   </p> <ul> <li> <p>Geben Sie das <code>Bibliothek</code>-Objekt unter Verwendung der <code>toString()</code>-Methode auf die Konsole aus.</p> </li> <li> <p>Rufen Sie f\u00fcr das <code>Bibliothek</code>-Objekt die Methode <code>sort(true)</code> auf und geben Sie danach das <code>Bibliothek</code>-Objekt erneut auf die Konsole aus. </p> </li> <li> <p>Rufen Sie f\u00fcr das <code>Bibliothek</code>-Objekt die Methode <code>sort(false)</code> auf und geben Sie danach das <code>Bibliothek</code>-Objekt erneut auf die Konsole aus. </p> </li> <li> <p>Es entstehen folgende Ausgaben (Beispielwerte):</p> <pre><code>Bibliothek mit  10 Buechern \n\n 1. Titel Q   :  77 Seiten, von 1963 \n 2. Titel N   :  55 Seiten, von 1982 \n 3. Titel W   : 112 Seiten, von 2017 \n 4. Titel R   :  26 Seiten, von 1989 \n 5. Titel W   : 161 Seiten, von 2002 \n 6. Titel N   : 147 Seiten, von 1949 \n 7. Titel U   :  80 Seiten, von 1955 \n 8. Titel S   : 148 Seiten, von 1948 \n 9. Titel A   :  96 Seiten, von 1980 \n10. Titel S   :  77 Seiten, von 1920 \n\n\nBibliothek mit  10 Buechern \n\n 1. Titel R   :  26 Seiten, von 1989 \n 2. Titel N   :  55 Seiten, von 1982 \n 3. Titel Q   :  77 Seiten, von 1963 \n 4. Titel S   :  77 Seiten, von 1920 \n 5. Titel U   :  80 Seiten, von 1955 \n 6. Titel A   :  96 Seiten, von 1980 \n 7. Titel W   : 112 Seiten, von 2017 \n 8. Titel N   : 147 Seiten, von 1949 \n 9. Titel S   : 148 Seiten, von 1948 \n10. Titel W   : 161 Seiten, von 2002 \n\n\nBibliothek mit  10 Buechern \n\n 1. Titel W   : 161 Seiten, von 2002 \n 2. Titel S   : 148 Seiten, von 1948 \n 3. Titel N   : 147 Seiten, von 1949 \n 4. Titel W   : 112 Seiten, von 2017 \n 5. Titel A   :  96 Seiten, von 1980 \n 6. Titel U   :  80 Seiten, von 1955 \n 7. Titel Q   :  77 Seiten, von 1963 \n 8. Titel S   :  77 Seiten, von 1920 \n 9. Titel N   :  55 Seiten, von 1982 \n10. Titel R   :  26 Seiten, von 1989 \n</code></pre> </li> </ul> </li> <li> <p>(Teil 4) Erstellen Sie in der Klasse <code>Bibliothek</code> eine Methode <code>enthaeltDoppelungen()</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn das <code>buecher</code>-Array B\u00fccher mit demselben Titel enth\u00e4lt (also die <code>equals()</code>-Methode aus Buch f\u00fcr zwei B\u00fccher <code>true</code> ergibt). Ansonsten <code>false</code>.</p> <ul> <li> <p>\u00c4ndern Sie die <code>toString()</code>-Methode von <code>Bibliothek</code> so, dass mit ausgegeben wird, ob das <code>buecher</code>-Array Doppelungen enth\u00e4lt oder nicht. Der zur\u00fcckgegebene String sieht dann so aus (Beispielwerte):     <pre><code>Bibliothek mit   4 Buechern \n\n 1. Titel B   : 151 Seiten, von 1940 \n 2. Titel H   : 126 Seiten, von 1977 \n 3. Titel Z   :  94 Seiten, von 1991 \n 4. Titel H   :  65 Seiten, von 1925 \n\nenthaelt doppelte Eintraege \n</code></pre></p> <p>oder so (Beispielwerte): <pre><code>Bibliothek mit   4 Buechern \n\n 1. Titel M   : 131 Seiten, von 1956 \n 2. Titel L   : 192 Seiten, von 1996 \n 3. Titel G   :  39 Seiten, von 2019 \n 4. Titel A   :  81 Seiten, von 1953 \n\nenthaelt keine doppelten Eintraege \n</code></pre></p> </li> <li> <p>Erstellen Sie in der Klasse <code>Bibliothek</code> eine Methode <code>buecherVonBis(int vonJahr, int bisJahr)</code>. Diese Methode gibt ein <code>Buch</code>-Array zur\u00fcck. Das zur\u00fcckgegebene <code>Buch</code>-Array enth\u00e4lt alle B\u00fccher aus dem <code>buecher</code>-Array, die in der Zeit <code>vonJahr</code> (inkl.) \u2013 <code>bisJahr</code> (inkl.) erschienen sind. </p> <p>Angenommen, das <code>buecher</code>-Array sieht so aus:</p> <pre><code>Bibliothek mit   4 Buechern \n\n 1. Titel B   : 151 Seiten, von 1940 \n 2. Titel H   : 126 Seiten, von 1977 \n 3. Titel Z   :  94 Seiten, von 1991 \n 4. Titel H   :  65 Seiten, von 1925\n</code></pre> <p>und es werden alle B\u00fccher aus dem Zeitraum <code>1950 \u2013 1999</code> gesucht. Dann sieht das zur\u00fcckgegebene <code>Buch</code>-Array so aus:</p> <pre><code>Titel H   : 126 Seiten, von 1977\nTitel Z   :  94 Seiten, von 1991\n</code></pre> </li> <li> <p>Rufen Sie die Methode <code>buecherVonBis(1950,1999)</code> in der <code>main()</code>-Methode f\u00fcr das unter <code>7.</code> erstellte <code>Bibliothek</code>sobjekt auf. Geben Sie das zur\u00fcckgegebene <code>Buch</code>-Array unter Verwendung der <code>toString()</code>-Methode von <code>Buch</code> auf die Konsole aus.</p> </li> <li> <p>Erstellen Sie in der Klasse <code>Bibliothek</code> eine Methode <code>duennstesBuch()</code>. Diese Methode gibt das <code>Buch</code> mit den wenigsten <code>seiten</code> aus dem <code>buecher</code>-Array zur\u00fcck. Sie k\u00f6nnen davon ausgehen, dass das <code>buecher</code>-Array mindestens ein Buch enth\u00e4lt.</p> <p>Rufen Sie die Methode in der <code>main()</code>-Methode auf und geben Sie das d\u00fcnnste Buch in der folgenden Form auf der Konsole aus (Beispielwerte):</p> <pre><code>Das duennste Buch ist [ Titel P   :  37 Seiten, von 1990 ]\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>Bibliothek</code> eine Methode <code>aeltestesBuch()</code>. Diese Methode gibt das <code>Buch</code> mit dem fr\u00fchesten Erscheinungsjahr (<code>jahr</code>) aus dem  <code>buecher</code>-Array zur\u00fcck. Sie k\u00f6nnen davon ausgehen, dass das <code>buecher</code>-Array mindestens ein Buch enth\u00e4lt.</p> <p>Rufen Sie die Methode in der <code>main()</code>-Methode auf und geben Sie das \u00e4lteste Buch in der folgenden Form auf der Konsole aus (Beispielwerte):</p> <pre><code>Das aelteste Buch ist [ Titel D   : 195 Seiten, von 1910 ]\n</code></pre> </li> <li> <p>Erstellen Sie in der Klasse <code>Bibliothek</code> eine Methode <code>durchschnittsalter()</code>. Diese Methode berechnet das Durchschnittsalter aller B\u00fccher aus dem <code>buecher</code>-Array und gibt dieses als <code>double</code> zur\u00fcck. Das Alter eines Buches wird berechnet, indem Sie vom aktuellen Jahr <code>2022</code> das Erscheinungsjahr des Buches abziehen.</p> <p>Rufen Sie die Methode in der <code>main()</code>-Methode auf und geben Sie das Durchschnittsalter in der folgenden Form auf der Konsole aus (Beispielwerte):</p> <pre><code>Das Durchschnittsalter betraegt 62.2 Jahre.\n</code></pre> </li> </ul> </li> <li> <p>Zur Kontrolle: Die m\u00f6glichen Ausgaben (Beispielwerte) k\u00f6nnten sein:</p> <pre><code>----------- Teil 1 -----------------\n\nTitel A   :  55 Seiten, von 1999\nTitel B   :  66 Seiten, von 2000\nTitel C   :  77 Seiten, von 2001\n\n----------- Teil 2 -----------------\n\nTitel V   :  29 Seiten, von 2012 --&gt;  10 Jahre alt \nTitel B   : 129 Seiten, von 2003 --&gt;  19 Jahre alt \nTitel E   :  37 Seiten, von 1940 --&gt;  82 Jahre alt \nTitel F   : 141 Seiten, von 1904 --&gt; 118 Jahre alt \nTitel L   : 118 Seiten, von 1983 --&gt;  39 Jahre alt \nTitel O   : 174 Seiten, von 1998 --&gt;  24 Jahre alt \nTitel U   : 162 Seiten, von 2001 --&gt;  21 Jahre alt \nTitel I   :  29 Seiten, von 1909 --&gt; 113 Jahre alt \nTitel V   : 141 Seiten, von 1944 --&gt;  78 Jahre alt \nTitel O   :  38 Seiten, von 1942 --&gt;  80 Jahre alt \n\n----------- Teil 3 -----------------\n\nBibliothek mit  10 Buechern \n\n 1. Titel P   :  79 Seiten, von 1948 \n 2. Titel U   :  91 Seiten, von 1941 \n 3. Titel J   :  88 Seiten, von 1956 \n 4. Titel H   :  76 Seiten, von 1959 \n 5. Titel Y   :  35 Seiten, von 2002 \n 6. Titel A   :  83 Seiten, von 2020 \n 7. Titel T   :  29 Seiten, von 2010 \n 8. Titel N   : 150 Seiten, von 1936 \n 9. Titel T   :  56 Seiten, von 1956 \n10. Titel W   :  70 Seiten, von 1907 \n\n\nBibliothek mit  10 Buechern \n\n 1. Titel T   :  29 Seiten, von 2010 \n 2. Titel Y   :  35 Seiten, von 2002 \n 3. Titel T   :  56 Seiten, von 1956 \n 4. Titel W   :  70 Seiten, von 1907 \n 5. Titel H   :  76 Seiten, von 1959 \n 6. Titel P   :  79 Seiten, von 1948 \n 7. Titel A   :  83 Seiten, von 2020 \n 8. Titel J   :  88 Seiten, von 1956 \n 9. Titel U   :  91 Seiten, von 1941 \n10. Titel N   : 150 Seiten, von 1936 \n\n\nBibliothek mit  10 Buechern \n\n 1. Titel N   : 150 Seiten, von 1936 \n 2. Titel U   :  91 Seiten, von 1941 \n 3. Titel J   :  88 Seiten, von 1956 \n 4. Titel A   :  83 Seiten, von 2020 \n 5. Titel P   :  79 Seiten, von 1948 \n 6. Titel H   :  76 Seiten, von 1959 \n 7. Titel W   :  70 Seiten, von 1907 \n 8. Titel T   :  56 Seiten, von 1956 \n 9. Titel Y   :  35 Seiten, von 2002 \n10. Titel T   :  29 Seiten, von 2010 \n\n\n----------- Teil 4 -----------------\n\nBibliothek mit  10 Buechern \n\n 1. Titel N   : 150 Seiten, von 1936 \n 2. Titel U   :  91 Seiten, von 1941 \n 3. Titel J   :  88 Seiten, von 1956 \n 4. Titel A   :  83 Seiten, von 2020 \n 5. Titel P   :  79 Seiten, von 1948 \n 6. Titel H   :  76 Seiten, von 1959 \n 7. Titel W   :  70 Seiten, von 1907 \n 8. Titel T   :  56 Seiten, von 1956 \n 9. Titel Y   :  35 Seiten, von 2002 \n10. Titel T   :  29 Seiten, von 2010 \n\nenthaelt doppelte Eintraege \n\n\nTitel J   :  88 Seiten, von 1956\nTitel H   :  76 Seiten, von 1959\nTitel T   :  56 Seiten, von 1956\n\n\n\nDas duennste Buch ist [ Titel T   :  29 Seiten, von 2010 ]\nDas aelteste Buch ist [ Titel W   :  70 Seiten, von 1907 ]\nDas Durchschnittsalter betraegt 58.5 Jahre.\n</code></pre> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Buch Testklasse.javaBuch.javaBibliothek.java <pre><code>package klausurvorbereitung.buch;\n\npublic class Testklasse \n{\n\n    public static void main(String[] args) \n    {\n        System.out.printf(\"%n----------- Teil 1 -----------------%n%n\");\n\n        Buch b1 = new Buch(\"Titel A\", 55, 1999);\n        Buch b2 = new Buch(\"Titel B\", 66, 2000);\n        Buch b3 = new Buch(\"Titel C\", 77, 2001);\n\n        System.out.println(b1);\n        System.out.println(b2);\n        System.out.println(b3);\n\n        System.out.printf(\"%n----------- Teil 2 -----------------%n%n\");\n\n        Buch[] buecher = new Buch[10];\n        for (int index = 0; index &lt; buecher.length; index++) \n        {\n            buecher[index] = new Buch();\n            System.out.print(buecher[index]);\n\n            int alter = 2022 -  buecher[index].getJahr();\n            System.out.printf(\" --&gt; %3d Jahre alt %n\", alter);\n        }\n\n        System.out.printf(\"%n----------- Teil 3 -----------------%n%n\");\n        Bibliothek bib1 = new Bibliothek(10);\n        System.out.println(bib1);\n        bib1.sort(true);\n        System.out.println(bib1);\n        bib1.sort(false);\n        System.out.println(bib1);\n\n        // Bibliothek bib2 = new Bibliothek(4);\n        // System.out.println(bib2);\n\n        System.out.printf(\"%n----------- Teil 4 -----------------%n%n\");\n        System.out.println(bib1);    // nicht gefordert\n        Buch[] bib3 = bib1.buecherVonBis(1950, 1999);\n        for (int index = 0; index &lt; bib3.length; index++) \n        {\n            System.out.println(bib3[index]);\n        }\n\n        System.out.printf(\"%n----------- Teil 5 -----------------%n%n\");\n        Buch duenn = bib1.duennstesBuch();\n        System.out.println(\"Das duennste Buch ist [ \" + duenn.toString() + \" ]\");\n\n        Buch alt = bib1.aeltestesBuch();\n        System.out.println(\"Das aelteste Buch ist [ \" + alt.toString() + \" ]\");\n\n        double average = bib1.durchschnittsalter();\n        System.out.println(\"Das Durchschnittsalter betraegt \" + average + \" Jahre.\");\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.buch;\n\nimport java.util.Random;\n\npublic class Buch \n{\n    private String titel;\n    private int seiten;\n    private int jahr;\n\n    public Buch(String titel, int seiten, int jahr) \n    {\n        this.titel = titel;\n        this.seiten = seiten;\n        this.jahr = jahr;\n    }\n\n    public Buch()\n    {\n        Random r = new Random();\n        int seiten = r.nextInt(180) + 20;\n        int jahr = r.nextInt(122) + 1900;\n        char buchstabe = (char)(r.nextInt(26) + 65);\n        String titel = \"Titel \" + buchstabe;\n\n        this.titel = titel;\n        this.seiten = seiten;\n        this.jahr = jahr;\n    }\n\n    public int getJahr()\n    {\n        return this.jahr;\n    }\n\n    public boolean istDicker(Buch b)\n    {\n        return this.seiten &gt; b.seiten;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%-10s: %3d Seiten, von %4d\", this.titel, this.seiten, this.jahr);\n        return s;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Buch b = (Buch)o;\n        return this.titel.equals(b.titel);\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.buch;\n\npublic class Bibliothek \n{\n    Buch[] buecher;\n\n    public Bibliothek(int anzBuecher)\n    {\n        this.buecher = new Buch[anzBuecher];\n        for (int index = 0; index &lt; buecher.length; index++) \n        {\n            this.buecher[index] = new Buch();\n        }\n    }\n\n    public void sort(boolean vonDuennZuDick)\n    {\n        for(int bubble = 1; bubble &lt;= this.buecher.length; bubble++)\n        {\n            for(int index = 0; index &lt; this.buecher.length - bubble; index++)\n            {\n                if(vonDuennZuDick &amp;&amp; this.buecher[index].istDicker(this.buecher[index+1]))\n                {\n                    Buch tmp = this.buecher[index +1];\n                    this.buecher[index +1] = this.buecher[index];\n                    this.buecher[index] = tmp;\n                }\n                else if(!vonDuennZuDick &amp;&amp; this.buecher[index +1].istDicker(this.buecher[index]))\n                {\n                    Buch tmp = this.buecher[index +1];\n                    this.buecher[index +1] = this.buecher[index];\n                    this.buecher[index] = tmp;\n                }\n            }\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"Bibliothek mit %3d Buechern %n%n\", this.buecher.length);\n        for (int index = 0; index &lt; this.buecher.length; index++) \n        {\n            s = s + String.format(\"%2d. %s %n\", (index + 1), this.buecher[index].toString());\n        }\n        s = s + \"\\n\";\n\n        if(this.enthaeltDoppelungen())\n        {\n            s = s + \"enthaelt doppelte Eintraege \\n\";\n        }\n        else\n        {\n            s = s + \"enthaelt keine doppelten Eintraege \\n\";\n        }   \n        s = s + \"\\n\";\n        return s;\n    }\n\n    private boolean contains(Buch b, int fromIndex)\n    {\n        for (int index = fromIndex; index &lt; buecher.length; index++) \n        {\n            if(this.buecher[index].equals(b))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean enthaeltDoppelungen()\n    {\n        for (int index = 0; index &lt; buecher.length; index++) \n        {\n            if(this.contains(this.buecher[index], index+1))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public Buch[] buecherVonBis(int vonJahr, int bisJahr)\n    {\n        int anzahl = 0;\n        for (int index = 0; index &lt; this.buecher.length; index++) \n        {\n            if(this.buecher[index].getJahr() &gt;= vonJahr &amp;&amp; this.buecher[index].getJahr() &lt;= bisJahr)\n            {\n                anzahl++;\n            }\n        }\n\n        Buch[] books = new Buch[anzahl];\n        int indexBooks = 0;\n        for (int index = 0; index &lt; this.buecher.length; index++) \n        {\n            if(this.buecher[index].getJahr() &gt;= vonJahr &amp;&amp; this.buecher[index].getJahr() &lt;= bisJahr)\n            {\n                books[indexBooks++] = this.buecher[index];\n            }\n        }\n\n        return books;\n    }\n\n    public Buch duennstesBuch()\n    {\n        Buch duennstes = this.buecher[0];\n        for (int index = 1; index &lt; this.buecher.length; index++) \n        {\n            if(duennstes.istDicker(this.buecher[index]))\n            {\n                duennstes = this.buecher[index];\n            }\n        }\n        return duennstes;\n    }\n\n\n    public Buch aeltestesBuch()\n    {\n        Buch aeltestes = this.buecher[0];\n        for (int index = 1; index &lt; this.buecher.length; index++) \n        {\n            if(this.buecher[index].getJahr() &lt; aeltestes.getJahr())\n            {\n                aeltestes = this.buecher[index];\n            }\n        }\n        return aeltestes;\n    }\n\n    public double durchschnittsalter()\n    {\n        final int HEUTE = 2022;\n        double sum = 0.0;\n        for (int index = 0; index &lt; this.buecher.length; index++) \n        {\n            int alter = HEUTE - this.buecher[index].getJahr();\n            sum = sum + alter;\n        }\n\n        if(this.buecher.length &gt; 0)\n        {\n            return (sum/this.buecher.length);\n        } \n        else \n        {\n            return 0.0;\n        }\n    }\n}\n</code></pre> Punkt2D und Punkt3D <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.punkt</code>. </li> <li> <p>Erstellen Sie in diesem package eine Klasse <code>Punkt3D</code> mit </p> <ul> <li>drei privaten Objektvariablen <code>x</code>, <code>y</code> und <code>z</code>, jeweils vom Typ <code>int</code>,</li> <li>einem parametrisierten Konstruktor <code>Punkt3D(int x, int y, int z)</code>. Mit den Parameterwerten werden die Objektvariablen initialisiert. </li> <li>Getter f\u00fcr die drei Objektvariablen (<code>getX()</code>, <code>getY()</code> und <code>getZ()</code>). </li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass folgende textuelle Rer\u00e4sentation als <code>String</code> erzeugt wird (Beispielwerte):     <pre><code>(5,2,3)\n</code></pre>     also in runden Klammern die Werte von <code>x</code>, <code>y</code> und <code>z</code> durch Komma getrennt.</li> <li>Schreiben Sie eine Objektmethode <code>print()</code>, die den durch <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</li> <li>\u00dcberschreiben Sie die Methode <code>equals(Object o)</code> so, dass zwei <code>Punkt3D</code>-Objekte gleich sind, wenn ihre Objektvariablen <code>x</code>, <code>y</code> und <code>z</code> jeweils paarweise den gleichen Wert besitzen. </li> <li>Schreiben Sie eine Objektmethode <code>xIsSmaller(Punkt3D p)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren <code>x</code>-Wert hat als <code>p</code>; <code>false</code> sonst.</li> <li>Schreiben Sie eine Objektmethode <code>yIsSmaller(Punkt3D p)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren <code>y</code>-Wert hat als <code>p</code>; <code>false</code> sonst.</li> <li>Schreiben Sie eine Objektmethode <code>zIsSmaller(Punkt3D p)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt einen kleineren <code>z</code>-Wert hat als <code>p</code>; <code>false</code> sonst.</li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Punkt2D</code>. Diese Klasse erbt von <code>Punkt3D</code>. Bei einem Objekt vom Typ <code>Punkt2D</code> ist der Wert von <code>z</code> stets <code>0</code>! </p> <ul> <li>Schreiben Sie einen parametrisierten Konstruktor <code>Punkt2D(int x, int y)</code>. Verwenden Sie die Parameterwerte, um den entsprechenden Objektvariablen Werte zuzuweisen und setzen Sie den Wert von <code>z</code> auf <code>0</code>.</li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass folgende textuelle Rer\u00e4sentation als <code>String</code> erzeugt wird (Beispielwerte):     <pre><code>(5,2)\n</code></pre>     also in runden Klammern die Werte von <code>x</code> und <code>y</code> durch Komma getrennt. ( der Wert von <code>z</code> wird nicht mehr ausgewertet, er ist ja immer <code>0</code>). </li> </ul> </li> <li> <p>Testen Sie die Klassen <code>Punkt3D</code> und <code>Punkt2D</code> in einer <code>Testklasse</code> mit <code>main()</code>-Methode wie folgt:</p> <ul> <li>Erstellen Sie ein Array vom Typ <code>Punkt2D</code>. Es hat die L\u00e4nge <code>3</code>. </li> <li>Erzeugen Sie ein <code>Random</code>-Objekt. Sie m\u00fcssen dazu die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket importieren. </li> <li> <p>innerhalb einer Schleife soll nun Folgendes passieren:</p> <ul> <li>Sie erzeugen sich f\u00fcr <code>x</code>, <code>y</code> und <code>z</code> jeweils Zufallszahlen aus dem Bereich <code>[0, ... ,9]</code> (<code>0</code> und <code>9</code> inklusive, also <code>10</code> m\u00f6gliche Zufallszahlen). </li> <li>wenn <code>z</code> den Wert <code>0</code> hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von <code>x</code> und <code>y</code> ein Objekt vom Typ <code>Punkt2D</code> und speichern dieses im Array. Rufen Sie daf\u00fcr die <code>print()</code>-Methode auf. </li> <li>wenn <code>z</code> einen Wert ungleich <code>0</code> hat, dann erzeugen Sie mit den zuf\u00e4llig erzeugten Werten von <code>x</code>, <code>y</code> und <code>z</code> ein Objekt vom Typ <code>Punkt3D</code> und rufen daf\u00fcr die <code>print()</code>-Methode auf. Ein solches Objekt wird nicht weiter gespeichert. </li> <li>diesen Prozess wiederholen Sie so lange, bis das <code>Punkt2D[]</code>-Array bef\u00fcllt ist, bis Sie also drei <code>Punkt2D</code>-Objekte erzeugt und im Array gespeichert haben.  </li> </ul> </li> <li> <p>Eine m\u00f6gliche Ausgabe k\u00f6nnte so sein (Zufallswerte):     <pre><code>---------------- Punkt2D und Punkt3D ---------------\n\n(3,8,9)\n(3,3,4)\n(1,2,3)\n(7,6,7)\n(0,4,7)\n(9,0,8)\n(0,3,8)\n(3,3,9)\n(7,2,1)\n(2,4)\n(1,8)\n(6,4,7)\n(2,1,2)\n(7,4,1)\n(7,1,1)\n(0,2,2)\n(6,4,9)\n(1,2,7)\n(3,9,8)\n(2,3)\n</code></pre>     das letzte Objekt ist immer ein <code>Punkt2D</code>-Objekt, denn nach dem dritten <code>Punkt2D</code>-Objekt h\u00f6ren Sie ja auf, Objekte zu erzeugen (Schleifenende).</p> </li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Strecke</code> mit </p> <ul> <li>den privaten Objektvariablen <code>start</code> und <code>ende</code>, jeweils vom Typ <code>Punkt2D</code>,</li> <li>einem parametrisierten Konstruktor <code>Strecke(Punkt2D start, Punkt2D ende)</code>. Mit den Parameterwerten werden die Objektvariablen initialisiert. </li> <li>einem weiteren parametrisierten Konstruktor <code>Strecke(int x1, int y1, int x2, int y2)</code>. Mit den Parameterwerten <code>x1</code> und <code>y1</code> erzeugen Sie sich ein <code>Punkt2D</code>-Objekt, das den <code>start</code>-Punkt bildet und mit den Parameterwerten <code>x2</code> und <code>y2</code> erzeugen Sie sich ein <code>Punkt2D</code>-Objekt, das den <code>ende</code>-Punkt bildet. </li> <li> <p>Schreiben Sie eine Objektmethode <code>laenge()</code>, die die L\u00e4nge der <code>Strecke</code> als <code>double</code> zur\u00fcckgibt. Sie k\u00f6nnen dazu die Methoden <code>Math.abs(number)</code> f\u00fcr den absoluten Betrag von <code>number</code> und <code>Math.sqrt(number)</code> f\u00fcr die Quadratwurzel von <code>number</code> (als <code>double</code>) verwenden. Tipp: </p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass folgende textuelle Rer\u00e4sentation der <code>Strecke</code> als <code>String</code> erzeugt wird (Beispielwerte):     <pre><code>Strecke [start=(2,4), ende=(1,8), Laenge= 4,1231cm]\n</code></pre>     also die Start- und Endpunkte ausgegeben werden und die L\u00e4nge der Strecke in eckigen Klammern nach dem Wort <code>Strecke</code>.  </p> </li> <li>Schreiben Sie eine Objektmethode <code>print()</code>, die den durch <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</li> </ul> </li> <li> <p>Testen Sie die Klasse <code>Strecke</code> in der <code>Testklasse</code> mit <code>main()</code>-Methode wie folgt:</p> <ul> <li> <p>Erzeugen Sie <code>3</code> Objekte der Klasse <code>Strecke</code>. W\u00e4hlen Sie </p> <ul> <li>als <code>start</code>-Punkt der ersten Strecke, den ersten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil der Aufgabe, als <code>ende</code>-Punkt den zweiten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil, </li> <li>als <code>start</code>-Punkt der zweiten Strecke, den zweiten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil der Aufgabe, als <code>ende</code>-Punkt den dritten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil, </li> <li>als <code>start</code>-Punkt der dritten Strecke, den dritten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil der Aufgabe, als <code>ende</code>-Punkt den ersten Punkt aus dem <code>Punkt2D</code>-Array aus dem ersten Teil.</li> </ul> </li> <li> <p>Wenden Sie f\u00fcr alle drei <code>Strecke</code>-Objekte die <code>print()</code>-Methode an. Es sollte folgende Ausgabe erzeugt werden (Beispielwerte):     <pre><code>-------------------- Strecke -----------------------\n\nStrecke [start=(7,1), ende=(6,4), Laenge= 3,1623cm]\nStrecke [start=(6,4), ende=(4,6), Laenge= 2,8284cm]\nStrecke [start=(4,6), ende=(7,1), Laenge= 5,8310cm]\n</code></pre></p> </li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>PunkteArray</code> mit </p> <ul> <li>der privaten Objektvariablen <code>punkte</code> vom Typ <code>Punkt2D[]</code>,</li> <li>dem parametrisierten Konstruktor <code>PunkteArray(int anzahl)</code>, dem die Anzahl der Punkte, also die L\u00e4nge des <code>punkte</code>-Arrays \u00fcbergeben wird. Erzeugen Sie unter Verwendung dieser <code>anzahl</code> das <code>punkte</code>-Array.</li> <li>Schreiben Sie eine Objektmethode <code>contains(Punkt2D p)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>p</code> im <code>punkte</code>-Array enthalten ist und <code>false</code> sonst. Tipp: Beachten Sie, dass es sein kann, dass nicht alle Elemente im <code>punkte</code>-Array tats\u00e4chlich ein Objekt enthalten. Es kann also sein, dass manche Referenzvariablen <code>this.punkte[index]</code> den Wert <code>null</code> haben. Mithilfe von <code>this.punkte[index] != null</code> k\u00f6nnen Sie pr\u00fcfen, ob <code>this.punkte[index]</code> nicht auf <code>null</code> zeigt. </li> <li> <p>Schreiben Sie eine Objektmethode <code>fillArray()</code>. Diese Methode bef\u00fcllt das <code>punkte</code>-Array vollst\u00e4ndig mit <code>Punkte2D</code>-Objekten. Beachten Sie:</p> <ul> <li>die Werte f\u00fcr <code>x</code> und <code>y</code> aller Objekte sollen jeweils zuf\u00e4llig mithilfe von <code>Random</code> erzeugt werden. Der Wertebereich ist dabei jeweils <code>[0, ... ,9]</code> (also <code>0</code> und <code>9</code> inklusive, insgesamt <code>10</code> verschiedene Zufallszahlen),</li> <li><code>Punkt2D</code>-Objekte d\u00fcrfen nicht doppelt im <code>punkte</code>-Array vorkommen, d.h. es gibt keine zwei Punkte <code>p1</code> und <code>p2</code> im <code>punkte</code>-Array f\u00fcr die <code>p1.equals(p2)</code> den Wert <code>true</code> hat. </li> </ul> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass folgende textuelle Rer\u00e4sentation des <code>PunkteArray</code> als <code>String</code> erzeugt wird (Beispielwerte):     <pre><code>[ (6,7), (3,2), (1,4), (5,0), (4,6), (9,5), (1,5), (0,3), (4,9), (6,9), (5,2), (1,9), (7,6), (2,3), (4,4) ]\n</code></pre>     also alle Punkte in eckigen Klammern durch Komma getrennt.  </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>, die den durch <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>Hinweis: (f\u00fcr die folgenden Methoden) Ein Polygon ist ein geschlossener Linienezug aus Strecken. Die folgende Abbildung zeigt ein Polygon, das aus den Strecken <code>(p1, p2)</code>, <code>(p2, p3)</code>, <code>(p3, p4)</code>, <code>(p4, p5)</code> und <code>(p5, p1)</code> besteht. Es gibt darin also <code>5</code> Punkte und <code>5</code>Strecken:     </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>createPolygon()</code>, die ein <code>Strecke[]</code> zur\u00fcckgibt. Das <code>Strecke[]</code> ist genau so lang wie das <code>punkte</code>-Array. Das <code>Strecke[]</code> wird mit Objekten vom Typ <code>Strecke</code> vollst\u00e4ndig bef\u00fcllt. Dabei sind die <code>start</code>- und <code>ende</code>-Punkte immer die Nachbarpunkte aus dem <code>punkte</code>-Array. Jeder Punkt aus dem <code>punkte</code>-Array wird also zwei Mal verwendet, einmal als <code>ende</code>-Punkt einer Strecke und einmal als <code>start</code>-Punkt der n\u00e4chsten Strecke im <code>Strecke[]</code>. Beachten Sie, dass der <code>start</code>-Punkt der letzten Strecke im <code>Strecke[]</code> der letzte Punkte im <code>punkte</code>-Array und der <code>ende</code>-Punkt dieser Strecke der erste Punkt im <code>punkte</code>-Array ist - siehe Skizze:     </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>gesamtLaenge()</code>, die die Gesamtl\u00e4nge aller Strecken im Polygon ermittelt und diese als <code>double</code> zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der <code>createPolygon()</code>-Methode das Polygon erzeugen. </p> </li> <li>Schreiben Sie eine Objektmethode <code>amWeitestenLinks()</code>, die den <code>Punkt2D</code> aus dem <code>punkte</code>-Array zur\u00fcckgibt, der am weitesten links von allen ist (den kleinsten <code>x</code>-Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck.  </li> <li>Schreiben Sie eine Objektmethode <code>amWeitestenOben()</code>, die den <code>Punkt2D</code> aus dem <code>punkte</code>-Array zur\u00fcckgibt, der am weitesten oben von allen ist (den kleinsten <code>y</code>-Wert von allen hat). Geben Sie diesen Punkt zur\u00fcck. </li> <li>Schreiben Sie eine Objektmethode <code>laengsteStrecke()</code>, die die l\u00e4ngste <code>Strecke</code> aller Strecken im Polygon ermittelt und diese zur\u00fcckgibt. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der <code>createPolygon()</code>-Methode das Polygon erzeugen.  </li> <li>Schreiben Sie eine Objektmethode <code>printStrecken()</code>. Diese Methode gibt alle Strecken aus dem Polygon auf die Konsole aus. Au\u00dferdem wird die Gesamtl\u00e4nge aller Strecken aus dem Polygon, der am weitesten links stehende Punkt aus dem <code>punkte</code>-Array und der am weitesten oben stehende Punkt aus dem <code>punkte</code>-Array ausgegeben. Tipp: Sie m\u00fcssen sich in der Methode erst mithilfe der <code>createPolygon()</code>-Methode das Polygon erzeugen. Es sollte folgende Ausgabe erfolgen (Beispielwerte):     <pre><code>Strecke [start=(0,1), ende=(2,1), Laenge= 2,0000cm]\nStrecke [start=(2,1), ende=(5,7), Laenge= 6,7082cm]\nStrecke [start=(5,7), ende=(8,7), Laenge= 3,0000cm]\nStrecke [start=(8,7), ende=(7,4), Laenge= 3,1623cm]\nStrecke [start=(7,4), ende=(8,1), Laenge= 3,1623cm]\nStrecke [start=(8,1), ende=(1,1), Laenge= 7,0000cm]\nStrecke [start=(1,1), ende=(4,6), Laenge= 5,8310cm]\nStrecke [start=(4,6), ende=(2,9), Laenge= 3,6056cm]\nStrecke [start=(2,9), ende=(9,4), Laenge= 8,6023cm]\nStrecke [start=(9,4), ende=(6,8), Laenge= 5,0000cm]\nStrecke [start=(6,8), ende=(9,8), Laenge= 3,0000cm]\nStrecke [start=(9,8), ende=(5,6), Laenge= 4,4721cm]\nStrecke [start=(5,6), ende=(8,4), Laenge= 3,6056cm]\nStrecke [start=(8,4), ende=(6,5), Laenge= 2,2361cm]\nStrecke [start=(6,5), ende=(0,1), Laenge= 7,2111cm]\nGesamtlaenge der Strecken : 68,5964cm \nam weitesten links        : (0,1) \nam weitesten oben         : (0,1) \nlaengste                  : Strecke [start=(2,9), ende=(9,4), Laenge= 8,6023cm] \n</code></pre></li> </ul> </li> <li> <p>Testen Sie die Klasse <code>PunkteArray</code> in der <code>Testklasse</code> mit <code>main()</code>-Methode wie folgt:</p> <ul> <li>Erzeugen Sie ein Objekt der Klasse <code>PunkteArray</code> und \u00fcbergeben Sie als Anzahl der <code>punkte</code> den Wert <code>15</code>.</li> <li>Rufen Sie f\u00fcr diese Objekt die Methoden <code>fillArray()</code>, <code>print()</code> und <code>printStrecken()</code> auf. </li> <li>Es sollten folgende Ausgaben erzeugt werden (Beispielwerte):     <pre><code>------------------ PunkteArray ---------------------\n\n[ (0,1), (2,1), (5,7), (8,7), (7,4), (8,1), (1,1), (4,6), (2,9), (9,4), (6,8), (9,8), (5,6), (8,4), (6,5) ]\nStrecke [start=(0,1), ende=(2,1), Laenge= 2,0000cm]\nStrecke [start=(2,1), ende=(5,7), Laenge= 6,7082cm]\nStrecke [start=(5,7), ende=(8,7), Laenge= 3,0000cm]\nStrecke [start=(8,7), ende=(7,4), Laenge= 3,1623cm]\nStrecke [start=(7,4), ende=(8,1), Laenge= 3,1623cm]\nStrecke [start=(8,1), ende=(1,1), Laenge= 7,0000cm]\nStrecke [start=(1,1), ende=(4,6), Laenge= 5,8310cm]\nStrecke [start=(4,6), ende=(2,9), Laenge= 3,6056cm]\nStrecke [start=(2,9), ende=(9,4), Laenge= 8,6023cm]\nStrecke [start=(9,4), ende=(6,8), Laenge= 5,0000cm]\nStrecke [start=(6,8), ende=(9,8), Laenge= 3,0000cm]\nStrecke [start=(9,8), ende=(5,6), Laenge= 4,4721cm]\nStrecke [start=(5,6), ende=(8,4), Laenge= 3,6056cm]\nStrecke [start=(8,4), ende=(6,5), Laenge= 2,2361cm]\nStrecke [start=(6,5), ende=(0,1), Laenge= 7,2111cm]\nGesamtlaenge der Strecken : 68,5964cm \nam weitesten links        : (0,1) \nam weitesten oben         : (0,1) \nlaengste                  : Strecke [start=(2,9), ende=(9,4), Laenge= 8,6023cm] \n</code></pre></li> </ul> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Punkt2D und Punkt3D Punkt3D.javaPunkt2D.javaStrecke.javaPunkteArray.javaTestklasse.java <pre><code>package klausurvorbereitung.punkte;\n\npublic class Punkt3D\n{\n    private int x;\n    private int y;\n    private int z;\n\n    public Punkt3D(int x, int y, int z)\n    {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    public int getX()\n    {\n        return this.x;\n    }\n\n    public int getY()\n    {\n        return this.y;\n    }\n\n    public int getZ()\n    {\n        return this.z;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"(%d,%d,%d)\", this.x, this.y, this.z);\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Punkt3D p = (Punkt3D)o;\n        return this.x == p.x &amp;&amp; this.y == p.y &amp;&amp; this.z == p.z;\n    }\n\n    public boolean xIsSmaller(Punkt3D p)\n    {\n        return this.x &lt; p.x;\n    }   \n\n    public boolean yIsSmaller(Punkt3D p)\n    {\n        return this.y &lt; p.y;\n    }\n\n    public boolean zIsSmaller(Punkt3D p)\n    {\n        return this.z &lt; p.z;\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.punkte;\n\npublic class Punkt2D extends Punkt3D\n{\n    public Punkt2D(int x, int y)\n    {\n        super(x,y,0);\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"(%d,%d)\", this.getX(), this.getY());\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.punkte;\n\npublic class Strecke\n{\n    private Punkt2D start;\n    private Punkt2D ende;\n\n    public Strecke(Punkt2D start, Punkt2D ende)\n    {\n        this.start = start;\n        this.ende = ende;\n    }\n\n    public Strecke(int x1, int y1, int x2, int y2)\n    {\n        this.start = new Punkt2D(x1, y1);\n        this.ende = new Punkt2D(x2, y2);\n    }\n\n    public double laenge()\n    {\n        int diffX = Math.abs(start.getX() - ende.getX());\n        int diffY = Math.abs(start.getY() - ende.getY());\n        int diffX2 = diffX * diffX;\n        int diffY2 = diffY * diffY;\n        double laenge = Math.sqrt(diffX2 + diffY2);\n        return laenge;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"Strecke [start=%s, ende=%s, Laenge=%7.4fcm]\", start.toString(), ende.toString(), this.laenge());\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.punkte;\n\nimport java.util.Random;\n\npublic class PunkteArray\n{\n    private Punkt2D[] punkte;\n\n    public PunkteArray(int anzahl)\n    {\n        this.punkte = new Punkt2D[anzahl];\n    }\n\n    public boolean contains(Punkt2D p)\n    {\n        for (int index = 0; index &lt; this.punkte.length; index++)\n        {\n            if(this.punkte[index] != null &amp;&amp; this.punkte[index].equals(p)) \n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void fillArray()\n    {\n        Random r = new Random();\n        for(int index=0; index &lt; this.punkte.length; index++)\n        {\n            int x = r.nextInt(10);\n            int y = r.nextInt(10);\n            Punkt2D p = new Punkt2D(x,y);\n            while(this.contains(p))\n            {\n                x = r.nextInt(10);\n                y = r.nextInt(10);\n                p = new Punkt2D(x,y);\n            }\n            this.punkte[index] = p;\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"[ \";\n        for(int index=0; index &lt; this.punkte.length; index++)\n        {\n            if(index&lt;this.punkte.length-1)\n            {\n                s += this.punkte[index].toString() + \", \";\n            }\n            else\n            {\n                s += this.punkte[index].toString();\n            }\n        }\n        s += \" ]\";\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public Strecke[] createPolygon()\n    {\n        Strecke[] polygon = new Strecke[this.punkte.length];\n        for(int index=0; index &lt; this.punkte.length-1; index++)\n        {\n            polygon[index] = new Strecke(this.punkte[index], this.punkte[index+1]);\n        }\n        int index = this.punkte.length-1;\n        polygon[index] = new Strecke(this.punkte[index], this.punkte[0]);\n        return polygon;\n    }\n\n    public void printStrecken()\n    {\n        Strecke[] polygon = this.createPolygon();\n        for(int index=0; index &lt; polygon.length; index++)\n        {\n            polygon[index].print();\n        }\n        System.out.printf(\"Gesamtlaenge der Strecken : %7.4fcm %n\", this.gesamtLaenge());\n        System.out.printf(\"am weitesten links        : %s %n\", this.amWeitestenLinks().toString());\n        System.out.printf(\"am weitesten oben         : %s %n\", this.amWeitestenOben().toString());\n        System.out.printf(\"laengste                  : %s %n\", this.laengsteStrecke().toString());\n\n    }\n\n    public double gesamtLaenge()\n    {\n        Strecke[] polygon = this.createPolygon();\n        double gesamtLaenge = 0.0;\n        for(int index=0; index &lt; polygon.length; index++)\n        {\n            gesamtLaenge += polygon[index].laenge();\n        }\n        return gesamtLaenge;\n    }\n\n    public Punkt2D amWeitestenLinks()\n    {\n        int indexLinks = 0;\n        for(int index=0; index &lt; this.punkte.length-1; index++)\n        {\n            if(this.punkte[index].xIsSmaller(this.punkte[indexLinks]))\n            {\n                indexLinks = index;\n            }\n        }\n        return this.punkte[indexLinks];\n    }\n\n    public Punkt2D amWeitestenOben()\n    {\n        int indexOben = 0;\n        for(int index=0; index &lt; this.punkte.length-1; index++)\n        {\n            if(this.punkte[index].yIsSmaller(this.punkte[indexOben]))\n            {\n                indexOben = index;\n            }\n        }\n        return this.punkte[indexOben];\n    }\n\n    public Strecke laengsteStrecke()\n    {\n        Strecke[] polygon = this.createPolygon();\n        int indexLaengste = 0;\n        for(int index=0; index &lt; polygon.length; index++)\n        {\n            if(polygon[index].laenge() &gt; polygon[indexLaengste].laenge())\n            {\n                indexLaengste = index;\n            }\n        }\n        return polygon[indexLaengste];\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.punkte;\n\nimport java.util.Random;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n---------------- Punkt2D und Punkt3D ---------------%n%n\");\n        Random r = new Random();\n        Punkt2D[] pa = new Punkt2D[3];\n        int anz2D = 0;\n        while(anz2D &lt; 3)\n        {\n            int x = r.nextInt(10);\n            int y = r.nextInt(10);\n            int z = r.nextInt(10);\n            Punkt3D p;\n            if(z==0)\n            {\n                pa[anz2D] = new Punkt2D(x,y);\n                pa[anz2D].print();\n                anz2D++;\n            }\n            else\n            {\n                p = new Punkt3D(x,y,z);\n                p.print();\n            }\n        }\n\n        System.out.printf(\"%n%n-------------------- Strecke -----------------------%n%n\");\n        Strecke s1 = new Strecke(pa[0], pa[1]);\n        Strecke s2 = new Strecke(pa[1], pa[2]);\n        Strecke s3 = new Strecke(pa[2], pa[0]);\n        s1.print();\n        s2.print();\n        s3.print();\n\n        System.out.printf(\"%n%n------------------ PunkteArray ---------------------%n%n\");\n        PunkteArray parr = new PunkteArray(15);\n        parr.fillArray();\n        parr.print();\n        parr.printStrecken();\n    }\n\n}\n</code></pre> Wohnung <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.wohnung</code>. </li> <li> <p>Erstellen Sie in diesem package eine Klasse <code>Wohnung</code> mit</p> <ul> <li>den privaten Objektvariablen <ul> <li><code>qm</code> vom Typ <code>int</code>, (entspricht der Gr\u00f6\u00dfe der Wohnung in m^2)</li> <li><code>anzZimmer</code> vom Typ <code>int</code>,</li> <li><code>etage</code> vom Typ <code>int</code> und </li> <li><code>qmMiete</code> vom Typ <code>double</code> (entspricht dem Mietpreis pro m^2). </li> </ul> </li> <li>einem parametrisierten Konstruktor Wohnung(int qm, int anzZimmer, int etage, double qmMiete). Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen.</li> <li>Gettern f\u00fcr alle Objektvariablen (<code>getQm()</code>, <code>getAnzZimmer()</code>, <code>getEtage()</code>, <code>getQmMiete()</code>)</li> <li>einer Objektmethode <code>gesamtMiete()</code>, die die Gesamtmiete der Wohnung berechnet (<code>qm</code> * <code>qmMiete</code>) und diesen <code>double</code>-Wert zur\u00fcckgibt. </li> <li>einer Objektmethode <code>billiger(Wohnung w)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes kleiner ist als die Gesamtmiete von <code>w</code>; <code>false</code> sonst.</li> <li>einer Objektmethode <code>teurer(Wohnung w)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Gesamtmiete des aufrufenden Objektes gr\u00f6\u00dfer ist als die Gesamtmiete von <code>w</code>; <code>false</code> sonst.</li> <li> <p>einer Objektmethode <code>toString()</code> die Details der Wohnung in folgender Form (ab inkl. 1. Etage aufw\u00e4rts) als <code>String</code> zur\u00fcckgibt (Beispielwerte):     <pre><code>2-Zimmer Wohnung mit 40 qm in der 4. Etage. Monatliche Miete: 360.00 Euro\n</code></pre>     Achtung! Sollte sich die Wohnung in der 0.Etage befinden, geben Sie die Details bitte wie folgt zur\u00fcck (Beispielwerte):     <pre><code>1-Zimmer Wohnung mit 60 qm im Erdgeschoss. Monatliche Miete: 750.00 Euro`\n</code></pre></p> </li> <li> <p>und einer Objektmethode <code>print()</code>, die den von <code>toString()</code>zur\u00fcckgegebenen <code>String</code> auf der Konsole ausgibt</p> </li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Geben Sie in der <code>main()</code>-Methode Folgendes ein:     <pre><code>System.out.printf(\"%n%n--------------------- Test Wohnung -------------------------%n%n\");\nWohnung w1 = new Wohnung(70, 3, 4, 12.50);\nWohnung w2 = new Wohnung(40, 1, 0, 9.50);\nWohnung w3 = new Wohnung(90, 4, 2, 11.10);\nWohnung w4 = new Wohnung(60, 2, 0, 9.00);\n\nw1.print();\nw2.print();\nw3.print();\nw4.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>--------------------- Test Wohnung -------------------------\n\n3-Zimmer Wohnung mit 70qm in der 4. Etage. Monatliche Miete: 875,00 Euro\n1-Zimmer Wohnung mit 40qm im Erdgeschoss. Monatliche Miete: 380,00 Euro\n4-Zimmer Wohnung mit 90qm in der 2. Etage. Monatliche Miete: 999,00 Euro\n2-Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 540,00 Euro\n</code></pre></p> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Dachgeschosswohnung</code>. Diese erbt von <code>Wohnung</code>. </p> <ul> <li>Implementieren Sie einen parametrisierten Konstruktor <code>Dachgeschosswohnung(int qm, int anzZimmer, double qmMiete)</code>. Bei Aufruf des Konstruktors werden die entsprechenden Objektvariablen mit den Parameterwerten initialisiert. Die Objektvariable <code>etage</code> bekommt stets den Wert <code>5</code>. </li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass eine Zeichenkette der Form (Beispielwerte)     <pre><code>4-Zimmer DG-Wohnung mit 100 qm in der 5. Etage. Monatliche Miete: 1250.00 Euro\n</code></pre>     zur\u00fcckgegeben wird.  </li> </ul> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\");\nDachgeschosswohnung dg1 = new Dachgeschosswohnung(70, 3, 15.50);\nDachgeschosswohnung dg2 = new Dachgeschosswohnung(100, 4, 17.25);\n\ndg1.print();\ndg2.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>--------------- Test Dachgeschosswohnung -------------------\n\n3-Zimmer DG-Wohnung mit 70qm in der 5. Etage. Monatliche Miete: 1085,00 Euro\n4-Zimmer DG-Wohnung mit 100qm in der 5. Etage. Monatliche Miete: 1725,00 Euro\n</code></pre></p> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Haus</code>.  </p> <ul> <li>Objektvariable ist <code>wohnungen</code> vom Typ <code>Wohnung[]</code> und nur in der Klasse sichtbar. </li> <li> <p>Implementieren Sie eine Objektmethode <code>neueWohnung()</code>. Diese Methode gibt ein Objekt vom Typ <code>Wohnung</code> zur\u00fcck. In dieser Methode wird zun\u00e4chst ein <code>Random</code>-Objekt erzeugt. Mithilfe dieses <code>Random</code>-Objektes und der Objektmethode <code>nextInt(int bound)</code> der Klasse <code>Random</code> sollen zun\u00e4chst nacheinander folgende Werte zuf\u00e4llig erzeugt werden:</p> <ul> <li>Ein Wert f\u00fcr eine Quadratmeteranzahl <code>qm</code> aus dem Wertebereich <code>[20, 40, 60, 80, 100]</code> ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen),</li> <li>Ein Wert f\u00fcr die Anzahl der Zimmer <code>anzZimmer</code> aus dem Wertebereich <code>[1, 2, 3, 4, 5]</code> ( \u2192 also zuf\u00e4llig eine dieser 5 Zahlen),</li> <li>Ein Wert f\u00fcr die Etage <code>etage</code> aus dem Wertebereich <code>[0, 1, 2, 3, 4, 5]</code> ( \u2192 also zuf\u00e4llig eine dieser 6 Zahlen),</li> <li>Ein Wert f\u00fcr den Mietpreis pro Quadratmeter <code>qmMiete</code> aus dem Wertebereich <code>[8.0, 8.5, 9.0, 9.5, 10.0, 10.5, 11.0, 11.5, 12.0, 12.5]</code> ( \u2192 also zuf\u00e4llig eine dieser 10 Zahlen \u2013 Achtung hier <code>double</code>, Sie k\u00f6nnen aber trotzdem <code>nextInt(int bound)</code> verwenden, m\u00fcssen dann aber geeignet multiplizieren und addieren). Erzeugen Sie mit diesen Werten ein neues <code>Wohnung</code>-Objekt und geben Sie dieses Objekt zur\u00fcck.</li> </ul> </li> <li> <p>Implementieren Sie einen parametrisierten Konstruktor <code>Haus(int anzWohnungen)</code>. Darin wird das <code>wohnungen</code>-Array erzeugt. Die L\u00e4nge von <code>wohnungen</code> entspricht dem Wert von <code>anzWohnungen</code>. Bef\u00fcllen Sie das <code>wohnungen</code>-Array vollst\u00e4ndig mit Objekten vom Typ <code>Wohnungen</code>. Rufen Sie dazu f\u00fcr jedes Element des <code>wohnungen</code>-Arrays die Objektmethode <code>neueWohnung()</code> auf. Tipp : Jedes Element des <code>wohnungen</code>-Arrays ist nach dem Bef\u00fcllen mit Objekten vom Typ <code>Wohnung</code> eine Referenzvariable auf ein <code>Wohnung</code>-Objekt, d.h. z.B. ist <code>this.wohnungen[0]</code> vom Typ <code>Wohnung</code> und zeigt auf ein <code>Wohnung</code>-Objekt. Die folgende Abbildung verdeutlicht das f\u00fcr den Fall, dass das <code>wohnungen</code>-Array die L\u00e4nge <code>10</code> hat:      </p> </li> <li> <p>Implementieren Sie eine Objektmethode <code>print()</code>. Bei Aufruf der Methode soll das <code>wohnungen</code>-Array wie folgt ausgegeben werden (Beispielwerte f\u00fcr Array-L\u00e4nge <code>5</code>:)     <pre><code>Das Haus besteht aus : \n  5-Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 1000,00 Euro\n  4-Zimmer Wohnung mit 60qm in der 5. Etage. Monatliche Miete: 480,00 Euro\n  2-Zimmer Wohnung mit 80qm in der 5. Etage. Monatliche Miete: 880,00 Euro\n  5-Zimmer Wohnung mit 100qm in der 2. Etage. Monatliche Miete: 1100,00 Euro\n  3-Zimmer Wohnung mit 80qm im Erdgeschoss. Monatliche Miete: 920,00 Euro\n</code></pre></p> </li> </ul> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n---------------------- Test Haus ---------------------------%n%n\");\nHaus h1 = new Haus(10);\nh1.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte!):     <pre><code>---------------------- Test Haus ---------------------------\n\nDas Haus besteht aus : \n  1-Zimmer Wohnung mit 80qm in der 4. Etage. Monatliche Miete: 840,00 Euro\n  3-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n  4-Zimmer Wohnung mit 80qm in der 3. Etage. Monatliche Miete: 1000,00 Euro\n  5-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n  2-Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510,00 Euro\n  3-Zimmer Wohnung mit 60qm in der 4. Etage. Monatliche Miete: 600,00 Euro\n  4-Zimmer Wohnung mit 20qm in der 3. Etage. Monatliche Miete: 250,00 Euro\n  4-Zimmer Wohnung mit 100qm in der 5. Etage. Monatliche Miete: 850,00 Euro\n  5-Zimmer Wohnung mit 20qm in der 2. Etage. Monatliche Miete: 160,00 Euro\n  2-Zimmer Wohnung mit 40qm in der 2. Etage. Monatliche Miete: 400,00 Euro\n</code></pre></p> </li> <li> <p>Zusatz: Erweitern Sie die Klasse <code>Haus</code> um folgende Objektmethoden:</p> <ul> <li>eine Objektmethode <code>wohnungenInEtage(int etage)</code>. Diese Methode gibt ein <code>Wohnung[]</code>-Array zur\u00fcck. Das zur\u00fcckgegebene <code>Wohnung[]</code>-Array soll alle Wohnungen aus dem <code>wohnungen</code>-Array enthalten, die in der Etage liegen, die der Methode als Parameter \u00fcbergeben wird (<code>etage</code>). Befindet sich keine Wohnung in der als Parameter \u00fcbergeben Etage, so wird ein <code>Wohnung[]</code>-Array der L\u00e4nge <code>0</code> zur\u00fcckgegeben.</li> <li>eine Objektmethode <code>print(Wohnung[] warr)</code>. Diese Methode gibt das als Parameter \u00fcbergebene <code>warr</code>-Array auf der Konsole aus, in der Form (Bsp.:):     <pre><code>2-Zimmer Wohnung mit 100 qm in der 2. Etage. Monatliche Miete: 1250.00 Euro\n5-Zimmer Wohnung mit 100 qm in der 2. Etage. Monatliche Miete: 1000.00 Euro\n</code></pre></li> <li> <p>Testen der beiden Methoden in <code>main()</code>:     <pre><code>System.out.printf(\"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\");\nfor(int etage=0; etage&lt;6; etage++)\n{\n    System.out.println(\"Etage \" + etage + \" ---------------------------------------\");\n    h1.print(h1.wohnungenInEtage(etage));\n    System.out.println();\n}\n</code></pre>     sollte folgende Ausgbabe erzeugen (Zufallswerte):     <pre><code>----- Test wohnungenInEtage() und print(Wohnung[]) ---------\n\nEtage 0 ---------------------------------------\n2-Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510,00 Euro\n\nEtage 1 ---------------------------------------\n\nEtage 2 ---------------------------------------\n5-Zimmer Wohnung mit 20qm in der 2. Etage. Monatliche Miete: 160,00 Euro\n2-Zimmer Wohnung mit 40qm in der 2. Etage. Monatliche Miete: 400,00 Euro\n\nEtage 3 ---------------------------------------\n3-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n4-Zimmer Wohnung mit 80qm in der 3. Etage. Monatliche Miete: 1000,00 Euro\n5-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n4-Zimmer Wohnung mit 20qm in der 3. Etage. Monatliche Miete: 250,00 Euro\n\nEtage 4 ---------------------------------------\n1-Zimmer Wohnung mit 80qm in der 4. Etage. Monatliche Miete: 840,00 Euro\n3-Zimmer Wohnung mit 60qm in der 4. Etage. Monatliche Miete: 600,00 Euro\n\nEtage 5 ---------------------------------------\n4-Zimmer Wohnung mit 100qm in der 5. Etage. Monatliche Miete: 850,00 Euro\n</code></pre></p> </li> <li> <p>eine Objektmethode <code>teuersteWohnung()</code>. Diese Methode gibt die Wohnung aus dem <code>wohnungen</code>-Array zur\u00fcck, die die h\u00f6chste Gesamtmiete von allen Wohnungen aus dem <code>wohnungen</code>-Array hat.</p> </li> <li> <p>Testen der Methode in <code>main()</code>:     <pre><code>System.out.printf(\"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\");\nWohnung teuerste = h1.teuersteWohnung();\nteuerste.print();\n</code></pre>     sollte folgende Ausgbabe erzeugen (Zufallswerte):     <pre><code>--------------- Test teuersteWohnung() ---------------------\n\n4-Zimmer Wohnung mit 80qm in der 3. Etage. Monatliche Miete: 1000,00 Euro\n</code></pre></p> </li> <li> <p>eine Objektmethode <code>gesamtMieteHaus()</code>. Diese Methode gibt die Summe der Mieten aller Wohnungen im <code>wohnungen</code>-Array als <code>double</code> zur\u00fcck. </p> </li> <li> <p>Testen der Methode in <code>main()</code>:     <pre><code>System.out.printf(\"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\");\nSystem.out.printf(\"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\", h1.gesamtMieteHaus());\n</code></pre>     sollte folgende Ausgbabe erzeugen (Zufallswerte):     <pre><code>---------------- Test gesamtMieteHaus() --------------------\n\nDie Gesamtmiete fuer das Haus betraegt 5690,00 Euro.\n</code></pre></p> </li> <li> <p>eine Objektmethode <code>sortieren()</code>. Diese Methode sortiert das <code>wohnungen</code>-Array nach Gesamtmieten aufsteigend (beginnend mit der billigsten Wohnung und endend mit der teuersten).</p> </li> <li>Testen der Methode in <code>main()</code>:     <pre><code>System.out.printf(\"%n%n------------------- Test sortieren() -----------------------%n%n\");\nh1.sortieren();\nh1.print();\n</code></pre>     sollte folgende Ausgbabe erzeugen (Zufallswerte):     <pre><code>------------------- Test sortieren() -----------------------\n\nDas Haus besteht aus : \n  5-Zimmer Wohnung mit 20qm in der 2. Etage. Monatliche Miete: 160,00 Euro\n  4-Zimmer Wohnung mit 20qm in der 3. Etage. Monatliche Miete: 250,00 Euro\n  2-Zimmer Wohnung mit 40qm in der 2. Etage. Monatliche Miete: 400,00 Euro\n  2-Zimmer Wohnung mit 60qm im Erdgeschoss. Monatliche Miete: 510,00 Euro\n  3-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n  5-Zimmer Wohnung mit 60qm in der 3. Etage. Monatliche Miete: 540,00 Euro\n  3-Zimmer Wohnung mit 60qm in der 4. Etage. Monatliche Miete: 600,00 Euro\n  1-Zimmer Wohnung mit 80qm in der 4. Etage. Monatliche Miete: 840,00 Euro\n  4-Zimmer Wohnung mit 100qm in der 5. Etage. Monatliche Miete: 850,00 Euro\n  4-Zimmer Wohnung mit 80qm in der 3. Etage. Monatliche Miete: 1000,00 Euro\n</code></pre></li> </ul> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Wohnung Wohnung.javaDachgeschoss.javaHaus.javaTestklasse.java <pre><code>package klausurvorbereitung.wohnung;\n\npublic class Wohnung\n{\n    private int qm;\n    private int anzZimmer;\n    private int etage;\n    private double qmMiete;\n\n    public Wohnung(int qm, int anzZimmer, int etage, double qmMiete)\n    {\n        this.qm = qm;\n        this.anzZimmer = anzZimmer;\n        this.etage = etage;\n        this.qmMiete = qmMiete;\n    }\n\n    public int getQm()\n    {\n        return this.qm;\n    }\n\n    public int getAnzZimmer()\n    {\n        return this.anzZimmer;\n    }\n\n    public int getEtage()\n    {\n        return this.etage;\n    }\n\n    public double getQmMiete()\n    {\n        return this.qmMiete;\n    }\n\n    public double gesamtMiete()\n    {\n        return this.qm * this.qmMiete;\n    }\n\n    public boolean billiger(Wohnung w)\n    {\n        return this.gesamtMiete() &lt; w.gesamtMiete();\n    }\n\n    public boolean teurer(Wohnung w)\n    {\n        return this.gesamtMiete() &gt; w.gesamtMiete();\n    }\n\n    public String toString()\n    {\n        String s = \"\";\n        if(this.etage == 0)\n        {\n            s = String.format(\"%d-Zimmer Wohnung mit %d qm im Erdgeschoss. Monatliche Miete: %.2f Euro\", \n                    this.anzZimmer, this.qm, this.gesamtMiete() );\n        }\n        else\n        {\n            s = String.format(\"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\", \n                    this.anzZimmer, this.qm, this.etage, this.gesamtMiete() );\n        }\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.wohnung;\n\npublic class Dachgeschosswohnung extends Wohnung\n{\n    // alle Objektvariablen von Wohnung geerbt\n    // qm, anzZimmer, etage, qmMiete\n    // alle Objektmethoden von Wohnung geerbt\n\n    public Dachgeschosswohnung(int qm, int anzZimmer, double qmMiete)\n    {\n        super(qm, anzZimmer, 5, qmMiete);   // Konstruktor Wohnung\n    }\n\n    @Override\n    public String toString()\n    {\n        String s= \"\";\n        s = String.format(\"%d-Zimmer Wohnung mit %d qm in der %d. Etage. Monatliche Miete: %.2f Euro\", \n                this.getAnzZimmer(), this.getQm(), this.getEtage(), this.gesamtMiete() );\n        return s;\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.wohnung;\n\nimport java.util.Random;\n\npublic class Haus\n{\n    private Wohnung[] wohnungen;\n\n    public Wohnung neueWohnung()\n    {\n        Random r = new Random();\n        int qm = r.nextInt(5) * 20 + 20;\n        int anzZimmer = r.nextInt(5) + 1;\n        int etage = r.nextInt(6);\n        double qmMiete = r.nextInt(10) * 0.5 + 8.0;\n\n        return new Wohnung(qm, anzZimmer, etage, qmMiete);\n    }\n\n    public Haus(int anzWohnungen)\n    {\n        this.wohnungen = new Wohnung[anzWohnungen];\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            this.wohnungen[index] = this.neueWohnung();\n        }\n    }\n\n    public void print()\n    {\n        System.out.println(\"Das Haus besteht aus :\");\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            this.wohnungen[index].print();  // print()-Methode von Wohnung\n        }\n    }\n\n    public Wohnung[] wohnungenInEtage(int etage)\n    {\n        int anzWohnungenInEtage = 0;\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            if(this.wohnungen[index].getEtage()==etage)\n            {\n                anzWohnungenInEtage++;\n            }\n        }\n\n        Wohnung[] wohnungenInEtage = new Wohnung[anzWohnungenInEtage];\n        int indexWIE = 0;\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            if(this.wohnungen[index].getEtage()==etage)\n            {\n                wohnungenInEtage[indexWIE] = this.wohnungen[index];\n                indexWIE++;\n            }\n        }\n        return wohnungenInEtage;\n    }\n\n    public void print(Wohnung[] warr)\n    {\n        for (int index = 0; index &lt; warr.length; index++)\n        {\n            warr[index].print();    // print()-Methode von Wohnung\n        }\n    }\n\n    public Wohnung teuersteWohnung()\n    {\n        int indexMax = 0;\n\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            if(this.wohnungen[index].teurer(this.wohnungen[indexMax]))\n            {\n                indexMax = index;\n            }\n        }\n\n        return this.wohnungen[indexMax];\n    }\n\n    public double gesamtMieteHaus()\n    {\n        double gesamtMieteHaus = 0.0;\n        for (int index = 0; index &lt; this.wohnungen.length; index++)\n        {\n            gesamtMieteHaus = gesamtMieteHaus + this.wohnungen[index].gesamtMiete();\n        }\n        return gesamtMieteHaus;\n    }\n\n    public void sortieren()\n    {\n        for(int bubble = 1; bubble &lt; this.wohnungen.length; bubble++)\n        {\n            for(int index = 0; index &lt; this.wohnungen.length - bubble; index++)\n            {\n                if(this.wohnungen[index].teurer(this.wohnungen[index + 1]))\n                {\n                    Wohnung tmp = this.wohnungen[index];\n                    this.wohnungen[index] = this.wohnungen[index + 1];\n                    this.wohnungen[index + 1] = tmp;\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.wohnung;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n--------------------- Test Wohnung -------------------------%n%n\");\n        Wohnung w1 = new Wohnung(70, 3, 4, 12.50);\n        Wohnung w2 = new Wohnung(40, 1, 0, 9.50);\n        Wohnung w3 = new Wohnung(90, 4, 2, 11.10);\n        Wohnung w4 = new Wohnung(60, 2, 0, 9.00);\n\n        w1.print();\n        w2.print();\n        w3.print();\n        w4.print();\n\n        System.out.printf(\"%n%n--------------- Test Dachgeschosswohnung -------------------%n%n\");\n        Dachgeschosswohnung dg1 = new Dachgeschosswohnung(70, 3, 15.50);\n        Dachgeschosswohnung dg2 = new Dachgeschosswohnung(100, 4, 17.25);\n\n        dg1.print();\n        dg2.print();\n\n        System.out.printf(\"%n%n---------------------- Test Haus ---------------------------%n%n\");\n        Haus h1 = new Haus(10);\n        h1.print();\n\n        System.out.printf(\"%n%n----- Test wohnungenInEtage() und print(Wohnung[]) ---------%n%n\");\n        for(int etage=0; etage&lt;6; etage++)\n        {\n            System.out.println(\"Etage \" + etage + \" ---------------------------------------\");\n            h1.print(h1.wohnungenInEtage(etage));\n            System.out.println();\n        }\n\n        System.out.printf(\"%n%n--------------- Test teuersteWohnung() ---------------------%n%n\");\n        Wohnung teuerste = h1.teuersteWohnung();\n        teuerste.print();\n\n        System.out.printf(\"%n%n---------------- Test gesamtMieteHaus() --------------------%n%n\");\n        System.out.printf(\"Die Gesamtmiete fuer das Haus betraegt %.2f Euro.%n\", h1.gesamtMieteHaus());\n\n        System.out.printf(\"%n%n------------------- Test sortieren() -----------------------%n%n\");\n        h1.sortieren();\n        h1.print();\n    }\n\n}\n</code></pre> Video zu Wohnung <ul> <li></li> </ul> Pizza <ol> <li>Erstellen Sie ein package <code>klausurvorbereitung.pizza</code>. </li> <li> <p>Erstellen Sie in diesem package eine Klasse <code>Pizza</code> mit</p> <ul> <li>den privaten Objektvariablen <ul> <li><code>name</code> vom Typ <code>String</code> und</li> <li><code>preis</code> vom Typ <code>float</code>. </li> </ul> </li> <li>einem parametrisierten Konstruktor <code>Pizza(String name, float preis)</code>. Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen.</li> <li>Gettern f\u00fcr die Objektvariablen (<code>getName()</code>, <code>getPreis()</code>)</li> <li>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>, die Details der Pizza in folgender Form als <code>String</code> zur\u00fcckgibt (Beispielwerte):     <pre><code>Die Pizza Salami kostet 6.90 Euro.\n</code></pre></li> <li>und einer Objektmethode <code>print()</code>, die den von <code>toString()</code>zur\u00fcckgegebenen <code>String</code> auf der Konsole ausgibt.</li> <li>\u00dcberschreiben Sie die Objektmethode <code>equals(Object o)</code>. Diese Methode gibt <code>true</code> zur\u00fcck, wenn der Name <code>name</code> des aufrufenden Objektes gleich dem Namen <code>name</code> des als Parameter \u00fcbergebenen Objektes ist; <code>false</code> sonst. Tipp : Die Gleichheit von zwei Strings <code>s1</code> und <code>s2</code> k\u00f6nnen Sie mithilfe von <code>s1.equals(s2)</code> ermitteln. (<code>hashCode()</code> muss nicht \u00fcberschrieben werden).</li> </ul> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Geben Sie in der <code>main()</code>-Methode Folgendes ein:     <pre><code>System.out.printf(\"%n%n------------------------- Test Pizza ---------------------------%n%n\");\nPizza p1 = new Pizza(\"Salami\", 6.9f);\nPizza p2 = new Pizza(\"Margheritha\", 5.9f);\nPizza p3 = new Pizza(\"Tonno\", 6.9f);\nPizza p4 = new Pizza(\"Hawaii\", 6.9f);\nPizza p5 = new Pizza(\"Calzone\", 7.9f);\nPizza p6 = new Pizza(\"Salami\", 6.9f);\n\np1.print();\np2.print();\np3.print();\np4.print();\np5.print();\n\nSystem.out.println(\"p1 gleich p2 ? : \" + p1.equals(p2));\nSystem.out.println(\"p1 gleich p1 ? : \" + p1.equals(p1));\nSystem.out.println(\"p1 gleich p6 ? : \" + p1.equals(p6));\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>------------------------- Test Pizza ---------------------------\n\nDie Pizza Salami kostet 6,90 Euro.\nDie Pizza Margheritha kostet 5,90 Euro.\nDie Pizza Tonno kostet 6,90 Euro.\nDie Pizza Hawaii kostet 6,90 Euro.\nDie Pizza Calzone kostet 7,90 Euro.\n\np1 gleich p2 ? : false\np1 gleich p1 ? : true\np1 gleich p6 ? : true\n</code></pre></p> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Pizzaverkauf</code> mit</p> <ul> <li>den privaten Objektvariablen <ul> <li><code>pizza</code> vom Typ <code>Pizza</code> und</li> <li><code>anzVerkaeufe</code> vom Typ <code>int</code>. </li> </ul> </li> <li>einem parametrisierten Konstruktor <code>Pizzaverkauf(Pizza pizza)</code>. Mit dem Parameterwert <code>pizza</code> wird die Objektvariable <code>pizza</code> initialisiert. Der Wert der Objektvariablen <code>anzVerkaeufe</code> wird auf <code>0</code> gesetzt. </li> <li>einer Objektmethode <code>verkaufen()</code>. Darin wird der Wert der Objektvariablen <code>anzVerkaeufe</code> um <code>1</code> erh\u00f6ht.</li> <li>Gettern f\u00fcr die Objektvariablen, also <code>getAnzVerkaeufe()</code> und <code>getPizza()</code>.</li> <li>einer Objektmethode <code>umsatz()</code>. Diese Methode gibt ein <code>double</code> zur\u00fcck. Der Wert berechnet sich aus der Anzahl der Verk\u00e4ufe der Pizza (<code>anzVerkaeufe</code>) mal dem Preis der Pizza. </li> <li> <p>einer Objektmethode <code>toString()</code> die Details der Pizzaverkaeufe in folgender Form als <code>String</code> zur\u00fcckgibt (Beispielwerte):     <pre><code>Pizza Salami wurde 0 mal zum Preis von 6.90 Euro verkauft.\n</code></pre></p> </li> <li> <p>und einer Objektmethode <code>print()</code>, die den von <code>toString()</code>zur\u00fcckgegebenen <code>String</code> auf der Konsole ausgibt</p> </li> </ul> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\");\nPizzaverkauf pv1 = new Pizzaverkauf(p1);\npv1.print();\npv1.verkaufen();\npv1.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>--------------------- Test Pizzaverkauf ------------------------\n\nPizza Salami wurde 0 mal zum Preis von 6,90 Euro verkauft.\nPizza Salami wurde 1 mal zum Preis von 6,90 Euro verkauft.\n</code></pre></p> </li> <li> <p>Erstellen Sie im gleichen package eine Klasse <code>Speisekarte</code> mit</p> <ul> <li> <p>der privaten Objektvariablen </p> <ul> <li><code>angebot</code> vom Typ <code>Pizza[]</code></li> </ul> </li> <li> <p>einem parameterlosen Konstruktor <code>Speisekarte()</code>. In diesem Konstruktor wird f\u00fcr <code>angebot</code> ein <code>Pizza</code>-Array der L\u00e4nge <code>0</code> erzeugt. </p> </li> <li> <p>einer Objektmethode <code>pizzaHinzufuegen(Pizza pizza)</code>. Diese Methode f\u00fcgt die als Parameter \u00fcbergebene <code>pizza</code> dem angebot-Array hinzu.  Beachten Sie:</p> <ul> <li>Um dem <code>angebot</code>-Array eine neue Pizza hinzuzuf\u00fcgen, muss die L\u00e4nge des Arrays um 1 erh\u00f6ht werden.</li> <li>Kopieren Sie sich dazu das alte <code>angebot</code>-Array.</li> <li>Erzeugen Sie dann ein neues <code>angebot</code>-Array, das um 1 l\u00e4nger ist als das alte.</li> <li>Kopieren Sie das bisherige Angebot zur\u00fcck in das neue <code>angebot</code>-Array.</li> <li>F\u00fcgen Sie die neue Pizza (Parameter <code>pizza</code>) als letztes Element im neuen <code>angebot</code>-Array hinzu.</li> </ul> </li> <li> <p>einer Objektmethode <code>getLength()</code>. Diese Methode gibt die L\u00e4nge des <code>angebot</code>-Arrays zur\u00fcck. </p> </li> <li>einer Objektmethode <code>pizzaIstImAngebot(Pizza pizza)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn die als Parameter \u00fcbergebene <code>pizza</code> im <code>angebot</code>-Array enthalten ist. Pr\u00fcfen Sie die Gleichheit mithilfe der <code>equals()</code>-Methode von <code>Pizza</code>. </li> <li> <p>einer Objektmethode <code>pizzaLoeschen(Pizza pizza)</code>. Diese Methode l\u00f6scht die als Parameter \u00fcbergebene <code>pizza</code> aus dem <code>angebot</code>-Array (wenn Sie darin enthalten ist).  Beachten Sie:</p> <ul> <li>Nach dem L\u00f6schen der Pizza aus dem <code>angebot</code>-Array soll das <code>angebot</code>-Array wieder um 1 kleiner sein als vorher (falls die zu l\u00f6schende Pizza \u00fcberhaupt im <code>angebot</code>-Array enthalten war).</li> <li>Kopieren Sie also das alte <code>angebot</code>-Array au\u00dfer die zu l\u00f6schende Pizza. </li> <li>Ihre Kopie ist dann das neue <code>angebot</code>-Array. </li> </ul> </li> <li> <p>einer Objektmethode <code>getPizzaAtIndex(int index)</code>. Diese Methode gibt die Pizza zur\u00fcck, die im <code>angebot</code>-Array beim Index <code>index</code> eingetragen ist. Pr\u00fcfen Sie, ob der \u00fcbergebene Parameter ein g\u00fcltiger Index aus dem <code>angebot</code>-Array ist. Wenn nicht, geben Sie <code>null</code> zur\u00fcck.</p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>, die die Details der Speisekarte in folgender Form als <code>String</code> zur\u00fcckgibt (Beispielwerte):     <pre><code>====== Speisekarte ======\nSalami          6,90 Euro \nMargheritha     5,90 Euro \nTonno           6,90 Euro \nHawaii          6,90 Euro \nCalzone         7,90 Euro\n</code></pre></p> </li> <li> <p>und einer Objektmethode <code>print()</code>, die den von <code>toString()</code>zur\u00fcckgegebenen <code>String</code> auf der Konsole ausgibt</p> </li> </ul> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n--------------------- Test Speisekarte -------------------------%n%n\");\nSpeisekarte s1 = new Speisekarte();\ns1.pizzaHinzufuegen(p1);\ns1.pizzaHinzufuegen(p2);\ns1.pizzaHinzufuegen(p3);\ns1.pizzaHinzufuegen(p4);\ns1.pizzaHinzufuegen(p5);\ns1.print();\n\ns1.pizzaLoeschen(p3);\ns1.print();\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden:     <pre><code>--------------------- Test Speisekarte -------------------------\n\n====== Speisekarte ======\nSalami          6,90 Euro \nMargheritha     5,90 Euro \nTonno           6,90 Euro \nHawaii          6,90 Euro \nCalzone         7,90 Euro \n\n====== Speisekarte ======\nSalami          6,90 Euro \nMargheritha     5,90 Euro \nHawaii          6,90 Euro \nCalzone         7,90 Euro \n</code></pre></p> </li> <li> <p>Zusatz Erstellen Sie im gleichen package eine Klasse <code>Pizzaria</code> mit</p> <ul> <li>der privaten Objektvariablen <ul> <li><code>verkaeufe</code> vom Typ <code>Pizzaverkauf[]</code>. </li> </ul> </li> <li> <p>einem parametrisierten Konstruktor <code>Pizzeria(Speisekarte karte)</code>. In diesem Konstruktor wird </p> <ul> <li>das <code>verkaeufe</code>-Array erzeugt und hat die gleiche L\u00e4nge wie das <code>angebot</code>-Array der Speisekarte <code>karte</code> (siehe <code>getLength()</code>-Methode aus <code>Speisekarte</code>).</li> <li>jedes Element des <code>verkaeufe</code>-Arrays zeigt auf ein <code>Pizzaverkauf</code>-Objekt. Erzeugen Sie alle <code>Pizzaverkauf</code>-Objekte. \u00dcbergeben Sie dem <code>Pizzaverkauf</code>-Konstruktor dazu die jeweiligen <code>Pizza</code>-Objekte aus der Speisekarte <code>karte</code>.</li> </ul> </li> <li> <p>einer Objektmethode <code>bestellen()</code>. Diese Methode gibt ein <code>int</code> zur\u00fcck. In dieser Methode soll zuf\u00e4llig ein Index aus dem <code>verkaeufe</code>-Array erzeugt werden. Nutzen Sie dazu die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket. Verwenden Sie die Objektmethode <code>nextInt(int bound)</code> der Klasse <code>Random</code>. Wenden Sie <code>nextInt()</code> so an, dass auch tats\u00e4chlich ein g\u00fcltiger Index des <code>verkaeufe</code>-Arrays erzeugt wird. Geben Sie diesen zuf\u00e4llig erzeugten Index zur\u00fcck (das Bestellen entspricht also dem Nennen einer Nummer aus der Speisekarte). </p> </li> <li>einer Objektmethode <code>verkaufen(int index)</code>. Durch den Aufruf der Methode wird die Pizza verkauft, die im <code>verkaeufe</code>-Array am Index <code>index</code> steht. Nutzen Sie f\u00fcr den Verkauf die <code>verkaufen()</code>-Methode der Klasse Pizzaverkauf. \u00dcberpr\u00fcfen Sie, ob der als Parameter \u00fcbergebene Wert f\u00fcr <code>index</code> tats\u00e4chlich einem Index im <code>verkaeufe</code>-Array entspricht. </li> <li>einer Objektmethode <code>tagesVerkauf(int anzVerkaeufe)</code>. In dieser Methode wird <code>anzVerkaeufe</code> oft eine Pizza verkauft (<code>verkaufen(int index)</code>). Welche Pizza verkauft wird (also welcher <code>index</code>), wird durch die Methode <code>bestellen()</code> jeweils zuf\u00e4llig ermittelt. </li> <li>einer Objektmethode <code>print()</code>. Diese Methode erzeugt folgende Ausgabe (Beispielwerte):     <pre><code>Salami          : ***********************************\nMargheritha     : ************************************\nHawaii          : *****************************************\nCalzone         : ************************************** \n</code></pre>     Das hei\u00dft, es wird am Anfang der Zeile der Name der Pizza aus dem <code>verkaeufe</code>-Array ausgegeben und danach f\u00fcr die Anzahl der Verk\u00e4ufe jeweils ein <code>*</code>.</li> <li>einer Objektmethode <code>meistverkauftePizza()</code>. Diese Methode gibt die Pizza aus dem <code>verkaeufe</code>-Array zur\u00fcck, die am meisten verkauft wurde.</li> <li>einer Objektmethode <code>gesamtEinnahmen()</code>. Diese Methode gibt die Summe aller Einnahmen als <code>double</code> zur\u00fcck. Die Einnahmen ergeben sich aus der Summe der Ums\u00e4tze aller Pizzen (Methode <code>umsatz()</code> von <code>Pizzaverkauf</code>) aus dem <code>verkaeufe</code>-Array.</li> </ul> </li> <li> <p>F\u00fcgen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> folgende Anweisungen hinzu:     <pre><code>System.out.printf(\"%n%n------------------------ Test Pizzaria -------------------------%n%n\");\nPizzeria pz1 = new Pizzeria(s1);\npz1.tagesVerkauf(150);\npz1.print();\nSystem.out.println();\nSystem.out.print(\"Meistverkaufte Pizza : \");\npz1.meistverkauftePizza().print();\nSystem.out.printf(\"Die Gesamteinnahmen betragen %.2f Euro\", pz1.gesamtEinnahmen());\n</code></pre>     und f\u00fchren Sie die <code>Testklasse</code> aus. Es sollten folgende zus\u00e4tzliche Ausgaben erzeugt werden (Zufallswerte):     <pre><code>------------------------ Test Pizzaria -------------------------\n\nSalami          : ******************************\nMargheritha     : *******************************************\nHawaii          : *******************************************\nCalzone         : **********************************\n\nMeistverkaufte Pizza : Die Pizza Margheritha kostet 5,90 Euro.\nDie Gesamteinnahmen betragen 1026,00 Euro\n</code></pre></p> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Pizza Pizza.javaPizzaverkauf.javaSpeisekarte.javaPizzeria.javaTestklasse.java <pre><code>package klausurvorbereitung.pizza;\n\npublic class Pizza\n{\n    private String name;\n    private float preis;\n\n    public Pizza(String name, float preis)\n    {\n        this.name = name;\n        this.preis = preis;\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public float getPreis()\n    {\n        return this.preis;\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"Die Pizza %s kostet %.2f Euro.\", this.name, this.preis);\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Pizza po = (Pizza)o;\n        return (this.name.equals(po.name));\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.pizza;\n\npublic class Pizzaverkauf\n{\n    private Pizza pizza;\n    private int anzVerkaeufe;\n\n    public Pizzaverkauf(Pizza pizza)\n    {\n        this.pizza = pizza;\n        this.anzVerkaeufe = 0;\n    }\n\n    public void verkaufen()\n    {\n        this.anzVerkaeufe++;\n    }\n\n    public Pizza getPizza()\n    {\n        return this.pizza;\n    }\n\n    public int getAnzVerkaeufe()\n    {\n        return this.anzVerkaeufe;\n    }\n\n    public double umsatz()\n    {\n        return this.anzVerkaeufe * this.pizza.getPreis();\n    }\n\n    @Override\n    public String toString()\n    {\n        return String.format(\"Pizza %s wurde %d mal zum Preis von %.2f Euro verkauft.\", \n                this.pizza.getName(), this.anzVerkaeufe, this.pizza.getPreis());\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.pizza;\n\npublic class Speisekarte\n{\n    private Pizza[] angebot;\n\n    public Speisekarte()\n    {\n        this.angebot = new Pizza[0];\n    }\n\n    public int getLength()\n    {\n        return this.angebot.length;\n    }\n\n    public void pizzaHinzufuegen(Pizza pizza)\n    {\n        Pizza[] kopie = new Pizza[this.angebot.length + 1];\n        for (int index = 0; index &lt; this.angebot.length; index++)\n        {\n            kopie[index] = this.angebot[index];\n        }\n        kopie[kopie.length - 1] = pizza;\n        this.angebot = kopie;\n    }\n\n    public boolean pizzaIstImAngebot(Pizza pizza)\n    {\n        for (int index = 0; index &lt; this.angebot.length; index++)\n        {\n            if(this.angebot[index].equals(pizza))\n            {\n                return true;\n            }\n        }\n        return false;\n        // System.out.println(\"dead code\");\n    }\n\n    public void pizzaLoeschen(Pizza pizza)\n    {\n        if(this.pizzaIstImAngebot(pizza))\n        {\n            Pizza[] kopie = new Pizza[this.angebot.length - 1];\n            int indexKopie = 0;\n            for (int indexAngebot = 0; indexAngebot &lt; this.angebot.length; indexAngebot++)\n            {\n                if(!this.angebot[indexAngebot].equals(pizza))\n                {\n                    kopie[indexKopie] = this.angebot[indexAngebot];\n                    indexKopie++;\n                }\n            }\n            this.angebot = kopie;\n        }\n    }\n\n    public Pizza getPizzaAtIndex(int index)\n    {\n        if(index&gt;=0 &amp;&amp; index&lt;this.angebot.length)\n        {\n            return this.angebot[index];\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"====== Speisekarte ======%n\");\n        for (int index = 0; index &lt; this.angebot.length; index++)\n        {\n            s = s + String.format(\"%-15s %.2f Euro %n\", \n                    this.angebot[index].getName(), this.angebot[index].getPreis());\n        }\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.pizza;\n\nimport java.util.Random;\n\npublic class Pizzeria\n{\n    private Pizzaverkauf[] verkaeufe;\n\n    public Pizzeria(Speisekarte karte)\n    {\n        this.verkaeufe = new Pizzaverkauf[karte.getLength()];\n        for (int index = 0; index &lt; this.verkaeufe.length; index++)\n        {\n            this.verkaeufe[index] = new Pizzaverkauf(karte.getPizzaAtIndex(index));\n        }\n    }\n\n    public int bestellen()\n    {\n        Random r = new Random();\n        int index = r.nextInt(this.verkaeufe.length);\n        return index;   \n    }\n\n    public void verkaufen(int index)\n    {\n        if(index&gt;=0 &amp;&amp; index&lt;this.verkaeufe.length)\n        {\n            this.verkaeufe[index].verkaufen();\n        }\n    }\n\n    public void tagesVerkauf(int anzVerkaeufe)\n    {\n        for(int i=0; i&lt;anzVerkaeufe; i++)\n        {\n            int index = this.bestellen();\n            this.verkaufen(index);\n        }\n    }\n\n    public void print()\n    {\n        for (int index = 0; index &lt; this.verkaeufe.length; index++)\n        {\n            Pizza p = this.verkaeufe[index].getPizza();\n            int anzVerkaeufe = this.verkaeufe[index].getAnzVerkaeufe();\n            String s = String.format(\"%-13s : \", p.getName());\n            for(int stars = 0; stars &lt; anzVerkaeufe; stars++)\n            {\n                s = s + \"*\";\n            }\n            System.out.println(s);\n        }\n    }\n\n    public Pizza meistverkauftePizza()\n    {\n        int maxIndex = 0;\n        for (int index = 0; index &lt; this.verkaeufe.length; index++)\n        {\n            if(this.verkaeufe[index].getAnzVerkaeufe() &gt; this.verkaeufe[maxIndex].getAnzVerkaeufe())\n            {\n                maxIndex = index;\n            }\n        }\n        return this.verkaeufe[maxIndex].getPizza();\n    }\n\n\n    public double gesamtEinnahmen()\n    {\n        double gesamtEinnahmen = 0.0;\n        for (int index = 0; index &lt; this.verkaeufe.length; index++)\n        {\n            gesamtEinnahmen += this.verkaeufe[index].umsatz();\n        }\n        return gesamtEinnahmen;\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.pizza;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n------------------------- Test Pizza ---------------------------%n%n\");\n        Pizza p1 = new Pizza(\"Salami\", 6.9f);\n        Pizza p2 = new Pizza(\"Margheritha\", 5.9f);\n        Pizza p3 = new Pizza(\"Tonno\", 6.9f);\n        Pizza p4 = new Pizza(\"Hawaii\", 6.9f);\n        Pizza p5 = new Pizza(\"Calzone\", 7.9f);\n        Pizza p6 = new Pizza(\"Salami\", 6.9f);\n\n        p1.print();\n        p2.print();\n        p3.print();\n        p4.print();\n        p5.print();\n\n        System.out.println(\"p1 gleich p2 ? : \" + p1.equals(p2));\n        System.out.println(\"p1 gleich p1 ? : \" + p1.equals(p1));\n        System.out.println(\"p1 gleich p6 ? : \" + p1.equals(p6));\n\n        System.out.printf(\"%n%n--------------------- Test Pizzaverkauf ------------------------%n%n\");\n        Pizzaverkauf pv1 = new Pizzaverkauf(p1);\n        pv1.print();\n        pv1.verkaufen();\n        pv1.print();\n\n        System.out.printf(\"%n%n--------------------- Test Speisekarte -------------------------%n%n\");\n        Speisekarte s1 = new Speisekarte();\n        s1.pizzaHinzufuegen(p1);\n        s1.pizzaHinzufuegen(p2);\n        s1.pizzaHinzufuegen(p3);\n        s1.pizzaHinzufuegen(p4);\n        s1.pizzaHinzufuegen(p5);\n        s1.print();\n\n        s1.pizzaLoeschen(p3);\n        s1.print();\n\n        System.out.printf(\"%n%n------------------------ Test Pizzaria -------------------------%n%n\");\n        Pizzeria pz1 = new Pizzeria(s1);\n        pz1.tagesVerkauf(150);\n        pz1.print();\n        System.out.println();\n\n        System.out.print(\"Meistverkaufte Pizza : \");\n        pz1.meistverkauftePizza().print();\n        System.out.printf(\"Die Gesamteinnahmen betragen %.2f Euro\", pz1.gesamtEinnahmen());\n\n    }\n\n}\n</code></pre> Video zu Pizza <ul> <li></li> </ul> Power <ul> <li> <p>Implementieren Sie eine Klasse <code>Power</code>. </p> </li> <li> <p>Idee : Die Klasse <code>Power</code> implementiert die Potenz. Eine Potenz besteht aus einer Basis (<code>base</code>) und dem Exponenten (<code>exp</code>): base^exp, z.B. <code>8^4 = 8 \u2219 8 \u2219 8 \u2219 8</code></p> </li> <li> <p>Objektvariablen sind <code>base</code> und <code>exp</code> vom Typ <code>int</code>. Beide Objektvariablen sind nur innerhalb der Klasse sichtbar!</p> </li> <li>Implementieren Sie getter f\u00fcr die Basis (<code>getBase()</code>) und f\u00fcr den Exponenten (<code>getExp()</code>) (Sichtbarkeit <code>public</code>). </li> <li>Implementieren Sie f\u00fcr die Klasse <code>Power</code> einen parametrisierten Konstruktor <code>Power(int base, int exp)</code>. Die Werte der Parameter werden verwendet, um den Objektvariablen Werte zuzuweisen.</li> <li>Implementieren Sie eine Objektmethode <code>getValue()</code>, die ein <code>double</code> zur\u00fcckgibt. Die Methode gibt den Wert der Potenz zur\u00fcck, also z.B. f\u00fcr <code>8^4</code> den Wert <code>4096.0</code>. Beachten Sie:       Die Verwendung der <code>Math</code>-Klasse ist nicht erlaubt!</li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass eine Potenz in der Form <code>(base, exp)</code> als <code>String</code> zur\u00fcckgegeben wird, wobei <code>base</code> und <code>exp</code> die Werte der jeweiligen Objektvariablen sein sollen, also z.B. <code>(8, 4)</code>. </li> <li>Implementieren Sie eine Objektmethode <code>print()</code>, die mithilfe von <code>toString()</code> eine Potenz auf der Konsole ausgibt. </li> <li>Erstellen Sie eine Klasse <code>PowerTest</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode folgende f\u00fcnf Objekte der Klasse <code>Power</code>: <code>3^4</code>, <code>-3^4</code>, <code>3^0</code>, <code>3^(-4)</code>, <code>-3^(-4)</code>. Wenden Sie jeweils die Methode <code>print()</code> an und geben Sie au\u00dferdem jeweils den Wert der Potenz auf die Konsole aus. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: <pre><code>(3,4)\n(3,4) = 81.0\n(-3,4)\n(-3,4) = 81.0\n(3,0)\n(3,0) = 1.0\n(3,-4)\n(3,-4) = 0.012345679012345678\n(-3,-4)\n(-3,-4) = 0.012345679012345678\n</code></pre></li> </ul> <ul> <li>Erstellen Sie eine Klasse <code>PowerOfTwo</code>. Diese Klasse erbt von <code>Power</code>. </li> <li>Idee : Ein Objekt der Klasse <code>PowerOfTwo</code> ist eine Potenz zur Basis <code>2</code>, also z.B. <code>2^4</code>.</li> <li>Implementieren Sie einen parametrisierten Konstruktor <code>PowerOfTwo(int exp)</code>. Beachten Sie, dass der Basis der Wert <code>2</code> zugewiesen wird. </li> <li>Implementieren Sie eine Objektmethode <code>printBinary()</code>. Diese Methode gibt die Potenz als Bin\u00e4rzahl (bestehend aus Einsen und Nullen) auf die Konsole aus, z.B. <code>2^4</code>: <code>1 0 0 0 0</code>. Tipp : es kommt vorne immer eine <code>1</code> und danach kommen so viele Nullen, wie der Exponent gro\u00df ist. Wenn der Exponent kliner als <code>0</code> ist, dann geben Sie <code>Zahl ist kleiner als 1</code> auf die Konsole aus. Die Bin\u00e4rzahl f\u00fcr eine Potenz kleiner als <code>0</code> muss also nicht ermittelt werden. </li> <li>Erzeugen Sie in der <code>main()</code>-Methode der Klasse <code>PowerTest</code> folgende drei Objekte der Klasse <code>PowerOfTwo</code>: <code>2^4</code>, <code>2^(-4)</code>, <code>2^0</code> und rufen Sie jeweils die Methoden <code>print()</code> und <code>printBinary()</code> auf. Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen: <pre><code>(2,4)\n1 0 0 0 0\n(2,-4)\nZahl ist kleiner als 1\n(2,0)\n1\n</code></pre></li> </ul> <ul> <li>Erstellen Sie eine Klasse <code>PowerArray</code>. Objektvariable ist <code>p</code> vom Typ <code>Power[]</code>. <code>p</code> ist nur innerhalb der Klasse sichtbar!</li> <li>Implementieren Sie einen parametrisierten Konstruktor <code>PowerArray(int length)</code>. Darin wird das <code>p</code>-Array erzeugt. Die L\u00e4nge von <code>p</code> entspricht dem Wert von <code>length</code>.</li> <li>Implementieren Sie eine Objektmethode <code>fillArray()</code>. Bei Aufruf der Methode soll das Array <code>p</code> mit Objekten der Klasse <code>Power</code> gef\u00fcllt werden. Die Werte der Objektvariablen der <code>Power</code>-Objekte werden zuf\u00e4llig mit Hilfe der <code>Random</code>-Klasse erzeugt (um die <code>Random</code>-Klasse verwenden zu k\u00f6nnen, m\u00fcssen Sie diese aus dem <code>java.util</code>-Paket importieren). Beachten Sie folgende Anforderungen:<ol> <li>Sowohl die Basis als auch der Exponent k\u00f6nnen Werte aus dem Wertebereich <code>1..5</code> (jeweils inklusive) annehmen</li> <li>Die Basis soll nie einen gr\u00f6\u00dferen Wert als der Exponent haben (aber es k\u00f6nnen beide gleich sein).</li> </ol> </li> <li>Implementieren Sie eine Objektmethode <code>createArrayOfValues()</code>. Diese Methode liefert ein <code>double[]</code>-Array zur\u00fcck, das alle Werte der Potenzen aus dem <code>p</code>-Array enth\u00e4lt. </li> <li>Implementieren Sie eine Objektmethode <code>getIndexExponent(int exponent)</code>, die den Index des (ersten) Elementes zur\u00fcckliefert, bei dem das <code>Power</code>-Objekt den Exponenten hat, der als Parameter der Methode \u00fcbergeben wird. Existiert ein solches Objekt nicht im Array, wird <code>-1</code> zur\u00fcckgegeben. </li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass das <code>p</code>-Array in der Form (Beispiel)     <pre><code>[ (2,5), (2,3), (3,3), (1,5), (2,3), (1,3), (1,3), (1,2), (3,5), (2,3) ]\n</code></pre>     als <code>String</code> zur\u00fcckgegeben wird. Implementieren Sie eine Methode <code>print()</code>, die mithilfe von <code>toString()</code> das <code>p</code>-Array auf die Konsole ausgibt.</li> <li>Implementieren Sie eine Methode <code>sort()</code>, die das <code>p</code>-Array nach den Gr\u00f6\u00dfen der Werte der Potenzen ordnet \u2013 vom kleinsten Wert zum gr\u00f6\u00dften Wert. Die Verwendung der <code>Arrays</code>-Klasse aus dem <code>java.util</code>-Paket ist nicht gestattet. Sollten 2 Potenzen den gleichen Wert haben, z.B. <code>1^2</code> und <code>1^4</code>, dann soll die Potenz mit dem h\u00f6heren Exponent gr\u00f6\u00dfer sein als die Potenz mit dem kleineren Exponenten.</li> <li>Erzeugen Sie in der <code>main()</code>-Methode der Klasse <code>PowerTest</code> ein Objekt der Klasse <code>PowerArray</code>, so dass das <code>p</code>-Array die L\u00e4nge <code>10</code> hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden <code>fillArray()</code>, <code>print()</code>, <code>sort()</code> und wieder <code>print()</code> auf. Testen Sie au\u00dferdem (mindestens) einmal die <code>getIndexExponent()</code>- und die <code>createArrayOfValues()</code>- Methode (um das Array of Values auf der Konsole auszugeben, verwenden Sie die statische <code>toString()</code>-Methode der <code>Arrays</code>-Klasse (<code>import java.util.Arrays;</code>). Es sollte eine Ausgabe in ungef\u00e4hr der folgenden Form erfolgen (Zufallswerte): <pre><code>[ (1,5), (1,2), (3,5), (3,4), (4,4), (1,5), (1,2), (3,4), (2,3), (3,5) ]\n[ (1,2), (1,2), (1,5), (1,5), (2,3), (3,4), (3,4), (3,5), (3,5), (4,4) ]\nIndex : 5\nIndex : -1\n[1.0, 1.0, 1.0, 1.0, 8.0, 81.0, 81.0, 243.0, 243.0, 256.0]\n</code></pre></li> </ul> eine m\u00f6gliche L\u00f6sung f\u00fcr Power Power.javaPowerOfTwo.javaPowerArray.javaPowerTest.java <pre><code>package klausurvorbereitung.power;\n\npublic class Power\n{\n    private int base;\n    private int exp;\n\n    Power(int base, int exp)\n    {\n        this.base = base;\n        this.exp = exp;\n    }\n\n    public int getBase()\n    {\n        return this.base;\n    }\n\n    public int getExp()\n    {\n        return this.exp;\n    }\n\n    public double getValue()\n    {\n        double value=1.0;\n        if(this.exp&gt;=0)\n        {\n            for(int i=1; i&lt;=this.exp; i++)\n            {\n                value *= this.base;\n            }\n        }\n        else\n        {\n            for(int i=1; i&lt;=-this.exp; i++)\n            {\n                value *= this.base;\n            }\n            value = 1.0/value;\n        }\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\"+this.base+\",\"+this.exp+\")\";\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.power;\n\npublic class PowerOfTwo extends Power\n{\n    public PowerOfTwo(int exp)\n    {\n        super(2, exp);\n    }\n\n    public void printBinary()\n    {\n        if(this.getExp()&lt;0)\n        {\n            System.out.println(\"Zahl ist kleiner als 1\");\n        }\n        else\n        {\n            String s = \"1\";\n            for(int i=1; i&lt;=this.getExp(); i++)\n            {\n                s += \" 0\";\n            }\n            System.out.println(s);\n        }\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.power;\n\nimport java.util.Random;\n\npublic class PowerArray\n{\n    private Power[] p;\n\n    public PowerArray(int length)\n    {\n        this.p = new Power[length];\n    }\n\n    public void fillArray()\n    {\n        Random r = new Random();\n\n        for(int i=0; i&lt;this.p.length; i++)\n        {\n            int nr1 = r.nextInt(5)+1;\n            int nr2 = r.nextInt(5)+1;\n            if(nr1&gt;nr2)\n            {\n                this.p[i] = new Power(nr2, nr1);\n            }\n            else\n            {\n                this.p[i] = new Power(nr1, nr2);\n            }\n        }\n    }\n\n    public double[] createArrayOfValues()\n    {\n        double[] values = new double[this.p.length];\n        for(int i=0; i&lt;this.p.length; i++)\n        {\n            values[i] = this.p[i].getValue();\n        }\n        return values;\n    }\n\n    public int getIndexExponent(int exponent)\n    {\n        final int NOT_FOUND = -1;\n        for(int i=0; i&lt;this.p.length; i++)\n        {\n            if(this.p[i].getExp()==exponent)\n            {\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"[ \";\n        for(int i=0; i&lt;this.p.length; i++)\n        {\n            if(i&lt;this.p.length-1)\n            {\n                s += this.p[i].toString()+\", \";\n            }\n            else\n            {\n                s += this.p[i].toString();\n            }\n        }\n        s += \" ]\";\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public void sort()\n    {\n        for(int bubble=0; bubble&lt;this.p.length-1; bubble++)\n        {\n            for(int i=0; i&lt;this.p.length-1-bubble; i++)\n            {\n                if((this.p[i].getValue()&gt;this.p[i+1].getValue()) ||\n                    ((this.p[i].getValue()==this.p[i+1].getValue() &amp;&amp; \n                    this.p[i].getExp()&gt;this.p[i+1].getExp())))\n                    {\n                        Power temp = this.p[i];\n                        this.p[i] = this.p[i+1];\n                        this.p[i+1] = temp;\n                    }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.power;\n\nimport java.util.Arrays;\n\npublic class PowerTest\n{\n\n    public static void main(String[] args)\n    {\n        // Objekte erzeugen\n        Power p1 = new Power(3,4);\n        Power p2 = new Power(-3,4);\n        Power p3 = new Power(3,0);\n        Power p4 = new Power(3,-4);\n        Power p5 = new Power(-3,-4);\n\n        System.out.printf(\"%n%n---------------------- Ausgaben fuer Power ---------------------------%n%n\");\n        p1.print();\n        System.out.println(p1.toString() + \" = \" + p1.getValue());\n        p2.print();\n        System.out.println(p2.toString() + \" = \" + p2.getValue());\n        p3.print();\n        System.out.println(p3.toString() + \" = \" + p3.getValue());\n        p4.print();\n        System.out.println(p4.toString() + \" = \" + p4.getValue());\n        p5.print();\n        System.out.println(p5.toString() + \" = \" + p5.getValue());\n\n        System.out.printf(\"%n%n-------------------- Ausgaben fuer PowerOfTwo -------------------------%n%n\");\n        PowerOfTwo p21 = new PowerOfTwo(4);\n        p21.print();\n        p21.printBinary();\n        PowerOfTwo p22 = new PowerOfTwo(-4);\n        p22.print();\n        p22.printBinary();\n        PowerOfTwo p23 = new PowerOfTwo(0);\n        p23.print();\n        p23.printBinary();\n\n        System.out.printf(\"%n%n-------------------- Ausgaben fuer PowerArray -------------------------%n%n\");\n        PowerArray pa = new PowerArray(10);\n        pa.fillArray();\n        pa.print();\n        pa.sort();\n        pa.print();\n\n        System.out.println(\"Index : \" +pa.getIndexExponent(4));\n        System.out.println(\"Index : \" +pa.getIndexExponent(0));\n\n        double[] values = pa.createArrayOfValues();\n        System.out.println(Arrays.toString(values));\n    }\n}\n</code></pre> Computer <ul> <li> <p>Implementieren Sie eine Klasse <code>Computer</code>. </p> <ul> <li>Objektvariablen sind <code>hersteller</code> vom Typ <code>String</code>, <code>ram</code> vom Typ <code>int</code> und <code>platte</code> vom Typ <code>int</code>. Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar!</li> <li>Schreiben Sie f\u00fcr alle Objektvariablen Getter (<code>getRam()</code>, <code>getPlatte()</code>, <code>getHersteller()</code>).</li> <li>Schreiben Sie einen parametrisierten Konstruktor <code>Computer(String hersteller, int ram, int platte)</code>. Die Parameterwerte werden genutzt, um den Objektvariablen die entsprechenden Werte zuzuweisen.</li> <li>Schreiben Sie eine Objektmethode <code>gleicherHersteller(Computer c)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn <code>c</code> vom gleichen Hersteller ist, wie das aufrufende Objekt. Ansonsten wird ein <code>false</code> zur\u00fcckgegeben. </li> <li>Schreiben Sie eine Objektmethode <code>gleicherHersteller(String hersteller)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn das aufrufende Objekt den Hersteller hat, der als Parameterwert der Methode \u00fcbergeben wird. Ansonsten wird ein <code>false</code> zur\u00fcckgegeben.</li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass der Computer in folgender Form angezeigt wird (Beispielwerte):     <pre><code>lenovo mit 8 RAM und 256 SSD\n</code></pre></li> <li>Schreiben Sie eine Methode <code>print()</code>, die mit Hilfe von <code>toString()</code> eine Ausgabe auf der Konsole erzeugt.</li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode f\u00fcnf Objekte der Klasse <code>Computer</code>:</p> <ul> <li>lenovo mit 8 RAM und 256 SSD </li> <li>lenovo mit 16 RAM und 512 SSD </li> <li>apple mit 4 RAM und 256 SSD </li> <li>apple mit 8 RAM und 512 SSD </li> <li>dell mit 8 RAM und 256 SSD</li> </ul> <p>Wenden Sie jeweils die Methode <code>print()</code> an, wenden Sie die Methode <code>gleicherHersteller(Computer c)</code> f\u00fcr den ersten Computer an und vergleichen ihn mit dem zweiten und dem dritten. Geben Sie jeweils den Wert des Vergleiches aus.  Es sollten folgende Ausgaben auf der Konsole erzeugt werden: <pre><code>--------------------- Test Computer --------------------\n\nlenovo mit 8 RAM und 256 SSD\nlenovo mit 16 RAM und 512 SSD\napple mit 4 RAM und 256 SSD\napple mit 8 RAM und 512 SSD\ndell mit 8 RAM und 256 SSD\nc1 und c2 gleicher Hersteller ? : true\nc1 und c3 gleicher Hersteller ? : false\n</code></pre></p> </li> <li> <p>Erstellen Sie eine Klasse <code>Notebook</code>. Diese Klasse erbt von der Klasse <code>Computer</code>. </p> <ul> <li>Zus\u00e4tzliche Objektvariable der Klasse <code>Notebook</code> ist <code>monitor</code> vom Typ <code>int</code>. Die Objektvariablen sind in der Klasse und allen abgeleiteten Klassen sichtbar! </li> <li>Implementieren Sie einen parametrisierten Konstruktor <code>Notebook(String hersteller, int ram, int platte, int monitor)</code>. Die Parameterwerte werden genutzt, um den Objektvariablen des zur\u00fcckgegebenen Objektes die entsprechenden Werte zuzuweisen.</li> <li>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass eine Zeichenkette der Form     <pre><code>(hersteller, ram, platte, monitor)\n</code></pre>     zur\u00fcckgegeben wird (die entsprechenden Werte werden eingesetzt - siehe Ausgabe der <code>main()</code>-Methode unten).  </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> zwei Objekte der Klasse <code>Notebook</code> (Beispielwerte siehe n\u00e4chste Zeile) und rufen Sie jeweils die <code>print()</code>-Methode auf.      Es sollten folgende Ausgaben auf der Konsole erzeugt werden:     <pre><code>--------------------- Test Notebook --------------------\n\n(lenovo, 8, 256, 13)\n(lenovo, 16, 512, 15)\n</code></pre></p> </li> <li> <p>Erstellen Sie eine Klasse <code>NotebookArray</code>.  </p> <ul> <li>Objektvariable ist <code>notebooks</code> vom Typ <code>Notebook[]</code>. Die Objektvariable ist nur innerhalb der Klasse sichtbar!</li> <li>Schreiben Sie einen parametrisierten Konstruktor <code>NotebookArray(int anzahl)</code>. Darin wird das <code>notebooks</code>-Array mit der L\u00e4nge <code>anzahl</code> erzeugt (es wird noch nicht mit <code>Notebook</code>-Objekten bef\u00fcllt - das macht die n\u00e4chste Methode).</li> <li> <p>Schreiben Sie eine Objektmethode <code>konfigurieren()</code>. Bei Aufruf der Methode wird das Array <code>notebooks</code> mit Objekten der Klasse <code>Notebook</code> bef\u00fcllt.  Beachten Sie folgende Anforderungen:</p> <ol> <li>das <code>notebooks</code>-Array wird vollst\u00e4ndig bef\u00fcllt</li> <li> <p>f\u00fcr das Erzeugen der Objekte wird eine Zufallszahl aus dem Bereich <code>[0, 1, 2, 3, 4]</code> (<code>4</code> inklusive) erzeugt. Nutzen Sie dazu die Klasse <code>Random</code> aus dem <code>java.util</code>-Paket. Mithilfe von <code>nextInt(int exclusiveBorder)</code> wird eine Zufallszahl erzeugt. Je nach Wert der Zufallszahl wird ein anderes Notebook erzeugt:</p> <p>Wert <code>0</code> -&gt; zu erzeugendes Objekt: <code>(\"lenovo\", 8, 256, 13)</code>  Wert <code>1</code> -&gt; zu erzeugendes Objekt: <code>(\"lenovo\", 16, 512, 15)</code>  Wert <code>2</code> -&gt; zu erzeugendes Objekt: <code>(\"apple\", 4, 256, 13)</code>  Wert <code>3</code> -&gt; zu erzeugendes Objekt: <code>(\"apple\", 8, 512, 13)</code>  Wert <code>4</code> -&gt; zu erzeugendes Objekt: <code>(\"dell\", 8, 512, 15)</code> </p> </li> </ol> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>. Diese Methode gibt einen String in der Form (Beispielwerte):     <pre><code>[ 5 : (lenovo, 8, 256, 13 ), (apple, 8, 512, 13 ), (lenovo, 16, 512, 15 ), (lenovo, 8, 256, 13 ), (apple, 8, 512, 13 )]\n</code></pre>     zur\u00fcck.  Beachten Sie:</p> <ol> <li>die eckigen Klammern zu Beginn und Ende des Strings</li> <li>die Angabe der Anzahl der Elemente am Anfang (im obigen Beispiel <code>5 :</code>) </li> <li>das Komma zwischen den Elementen (aber nicht nach dem letzten Element)</li> </ol> </li> <li> <p>Schreiben Sie eine Methode <code>print()</code>, die den in <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getHersteller(String hersteller)</code>. Diese Methode gibt ein Objekt vom Typ <code>NotebookArray</code> zur\u00fcck. Das <code>notebooks</code>-Array des erzeugten Objektes enth\u00e4lt genau alle Notebooks aus dem <code>notebooks</code>-Array des aufrufenden Objektes, die von dem Hersteller sind, der als Parameterwert \u00fcbergeben wird.   Beispiel: Angenommen, das <code>notebooks</code>-Array des aufrufenden Objektes sieht so aus:     <pre><code>[ 10 : (lenovo, 16, 512, 15 ), (apple, 8, 512, 13 ), (apple, 4, 256, 13 ), (apple, 8, 512, 13 ), (lenovo, 8, 256, 13 ), \n       (lenovo, 16, 512, 15 ), (lenovo, 16, 512, 15 ), (lenovo, 16, 512, 15 ), (apple, 4, 256, 13 ), (apple, 4, 256, 13 ) ]\n</code></pre> Dann w\u00fcrde bei Aufruf der Methode <code>getHersteller(\"apple\")</code> das zur\u00fcckgegebene <code>NotebookArray</code>-Objekt folgendes <code>notebooks</code>-Array haben:     <pre><code>[ (apple, 8, 512, 13 ), (apple, 4, 256, 13 ), (apple, 8, 512, 13 ), (apple, 4, 256, 13 ), (apple, 4, 256, 13 ) ]\n</code></pre>     , bei Aufruf der Methode <code>getHersteller(\"lenovo\")</code> das zur\u00fcckgegebene <code>NotebookArray</code>-Objekt folgendes <code>notebooks</code>-Array:     <pre><code>[ (lenovo, 16, 512, 15 ), (lenovo, 8, 256, 13 ), (lenovo, 16, 512, 15 ), (lenovo, 16, 512, 15 ), (lenovo, 16, 512, 15 ) ]\n</code></pre>     und bei Aufruf der Methode <code>getHersteller(\"dell\")</code> das zur\u00fcckgegebene <code>NotebookArray</code>-Objekt ein leeres <code>notebooks</code>-Array:     <pre><code>[ ]\n</code></pre></p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>sortRamPlatte()</code>. Diese Methode sortiert das <code>notebooks</code>-Array wie folgt:</p> <ol> <li>aufsteigend nach RAM-Gr\u00f6\u00dfe (kleinste RAM-Gr\u00f6\u00dfe zuerst)</li> <li>ist die RAM-Gr\u00f6\u00dfer zweier Notebooks gleich, entscheidet die Plattengr\u00f6\u00dfe (kleinste Plattengr\u00f6\u00dfe zuerst)</li> </ol> </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode der <code>Testklasse</code> ein Objekt der Klasse <code>NotebookArray</code>, so dass das <code>notebooks</code>-Array die L\u00e4nge <code>10</code> hat. Rufen Sie f\u00fcr dieses Objekt die Objektmethoden <code>konfigurieren()</code>, <code>print()</code>, <code>sortRamPlatte()</code> und <code>print()</code> auf. Testen Sie au\u00dferdem die <code>getHersteller()</code>-Methode f\u00fcr alle drei Hersteller und geben Sie jeweils das erzeugte Array aus.       Es sollten folgende Ausgaben auf der Konsole erzeugt werden (Zufallswerte!):     <pre><code>------------------ Test NotebookArray ------------------\n\n[ 10 : (apple, 8, 512, 13), (lenovo, 16, 512, 15), (apple, 4, 256, 13), (lenovo, 8, 256, 13), (apple, 4, 256, 13), (dell, 8, 512, 15), (apple, 4, 256, 13), (apple, 8, 512, 13), (lenovo, 8, 256, 13), (apple, 8, 512, 13)]\n[ 10 : (apple, 4, 256, 13), (apple, 4, 256, 13), (apple, 4, 256, 13), (lenovo, 8, 256, 13), (lenovo, 8, 256, 13), (apple, 8, 512, 13), (dell, 8, 512, 15), (apple, 8, 512, 13), (apple, 8, 512, 13), (lenovo, 16, 512, 15)]\n[ 3 : (lenovo, 8, 256, 13), (lenovo, 8, 256, 13), (lenovo, 16, 512, 15)]\n[ 6 : (apple, 4, 256, 13), (apple, 4, 256, 13), (apple, 4, 256, 13), (apple, 8, 512, 13), (apple, 8, 512, 13), (apple, 8, 512, 13)]\n[ 1 : (dell, 8, 512, 15)]\n</code></pre></p> </li> </ul> eine m\u00f6gliche L\u00f6sung f\u00fcr Computer Computer.javaNotebook.javaNotebookArray.javaTestklasse.java <pre><code>package klausurvorbereitung.computer;\n\npublic class Computer\n{\n    protected String hersteller;\n    protected int ram;\n    protected int platte;\n\n    public String getHersteller()\n    {\n        return this.hersteller;\n    }\n    public int getRam()\n    {\n        return this.ram;\n    }\n    public int getPlatte()\n    {\n        return this.platte;\n    }\n\n    public Computer(String hersteller, int ram, int platte)\n    {\n        this.hersteller = hersteller;\n        this.ram = ram;\n        this.platte = platte;\n    }\n\n    public boolean gleicherHersteller(Computer c)\n    {\n        return this.hersteller.equals(c.hersteller);\n        // es geht auch: return this.hersteller == c.hersteller;\n    }\n\n    public boolean gleicherHersteller(String hersteller)\n    {\n        return this.hersteller.equals(hersteller);\n        // es geht auch: return this.hersteller == hersteller;\n    }\n\n    @Override\n    public String toString()\n    {\n        return this.hersteller + \" mit \" + this.ram + \" RAM und \" + this.platte + \" SSD\";\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.computer;\n\npublic class Notebook extends Computer\n{\n    protected int monitor;\n\n    public Notebook(String hersteller, int ram, int platte, int monitor)\n    {\n        super(hersteller, ram, platte);\n        this.monitor = monitor;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"(\" + this.hersteller + \", \" + this.ram + \", \" + this.platte + \", \" + this.monitor +\")\";\n    }\n\n}\n</code></pre> <pre><code>package klausurvorbereitung.computer;\n\nimport java.util.Random;\n\npublic class NotebookArray\n{\n    private Notebook[] notebooks;\n\n    public NotebookArray(int anzahl)\n    {\n        this.notebooks = new Notebook[anzahl];\n    }\n\n    public void konfigurieren()\n    {\n        Random r = new Random();\n        for (int i = 0; i &lt; this.notebooks.length; i++)\n        {\n            int auswahl = r.nextInt(5);\n            // folgendes kann natuerlich auch mit if..else geloest werden\n            this.notebooks[i] = switch(auswahl)\n            {\n                case 0 -&gt; new Notebook(\"lenovo\", 8, 256, 13); \n                case 1 -&gt;  new Notebook(\"lenovo\", 16, 512, 15); \n                case 2 -&gt;  new Notebook(\"apple\", 4, 256, 13); \n                case 3 -&gt;  new Notebook(\"apple\", 8, 512, 13); \n                case 4 -&gt;  new Notebook(\"dell\", 8, 512, 15); \n                default -&gt; null;\n            };\n        }\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"[ \" + this.notebooks.length + \" : \";\n        for (int i = 0; i &lt; this.notebooks.length; i++)\n        {\n            if(i&lt;this.notebooks.length-1)\n            {\n                s += this.notebooks[i].toString() + \", \";\n            }\n            else\n            {\n                s += this.notebooks[i].toString();\n            }\n        }\n        s += \"]\";\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public NotebookArray getHersteller(String hersteller)\n    {\n        int anzahl = 0;\n        for (int i = 0; i &lt; this.notebooks.length; i++)\n        {\n            if(this.notebooks[i].gleicherHersteller(hersteller))\n            {\n                anzahl++;\n            }\n        }\n        NotebookArray na = new NotebookArray(anzahl);\n        int indexNA = 0;\n        for (int i = 0; i &lt; this.notebooks.length; i++)\n        {\n            if(this.notebooks[i].gleicherHersteller(hersteller))\n            {\n                na.notebooks[indexNA++] = this.notebooks[i];\n            }\n        }\n        return na;\n    }\n\n    public void sortRamPlatte()\n    {\n        for(int bubble=0; bubble&lt;this.notebooks.length-1; bubble++)\n        {\n            for(int i=0; i&lt;this.notebooks.length-1-bubble; i++)\n            {\n                if((this.notebooks[i].getRam()&gt;this.notebooks[i+1].getRam()) ||\n                    (this.notebooks[i].getRam()==this.notebooks[i+1].getRam() &amp;&amp; \n                    this.notebooks[i].getPlatte()&gt;this.notebooks[i+1].getPlatte()))\n                {\n                    Notebook temp = this.notebooks[i];\n                    this.notebooks[i] = this.notebooks[i+1];\n                    this.notebooks[i+1] = temp;\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.computer;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n\n        System.out.printf(\"%n%n--------------------- Test Computer --------------------%n%n\");\n        Computer c1 = new Computer(\"lenovo\", 8, 256);\n        Computer c2 = new Computer(\"lenovo\", 16, 512);\n        Computer c3 = new Computer(\"apple\", 4, 256);\n        Computer c4 = new Computer(\"apple\", 8, 512);\n        Computer c5 = new Computer(\"dell\", 8, 256);\n\n        c1.print();\n        c2.print();\n        c3.print();\n        c4.print();\n        c5.print();\n\n        System.out.println(\"c1 und c2 gleicher Hersteller ? : \" + c1.gleicherHersteller(c2));\n        System.out.println(\"c1 und c3 gleicher Hersteller ? : \" + c1.gleicherHersteller(c3));\n\n        System.out.printf(\"%n%n--------------------- Test Notebook --------------------%n%n\");\n        Notebook n1 = new Notebook(\"lenovo\", 8, 256, 13);\n        Notebook n2 = new Notebook(\"lenovo\", 16, 512, 15);\n\n        n1.print();\n        n2.print();\n\n        System.out.printf(\"%n%n------------------ Test NotebookArray ------------------%n%n\");      \n        NotebookArray na = new NotebookArray(10);\n        na.konfigurieren();\n        na.print();\n        na.sortRamPlatte();\n        na.print();\n        NotebookArray lenovo = na.getHersteller(\"lenovo\");\n        lenovo.print();\n        NotebookArray apple = na.getHersteller(\"apple\");\n        apple.print();\n        NotebookArray dell = na.getHersteller(\"dell\");\n        dell.print();\n\n    }\n\n}\n</code></pre> Uhrzeit <ul> <li> <p>Implementieren Sie eine Klasse <code>Uhrzeit</code>. </p> <ul> <li> <p>Objektvariablen sind <code>stunden</code> vom Typ <code>int</code>, <code>minuten</code> vom Typ <code>int</code> und <code>sekunden</code> vom Typ <code>int</code>. Die Objektvariablen sind nur in der Klasse sichtbar!</p> </li> <li> <p>Schreiben Sie einen parametrisierten Konstruktor <code>Uhrzeit(int sekunden)</code>. \u00dcbergeben wird eine beliebige Anzahl von Sekunden. Aus diesem Wert wird die Uhrzeit berechnet. </p> <ul> <li> <p>Beispiel 1: Angenommen, es wird der Wert <code>83</code> \u00fcbergeben, dann sind das <code>0</code> Stunden, <code>1</code> Minute (<code>60</code> Sekunden) und <code>23</code> Sekunden.</p> </li> <li> <p>Beispiel 2: Angenommen, es wird der Wert <code>3662</code> \u00fcbergeben, dann sind das <code>1</code> Stunde (<code>3600</code> Sekunden), <code>1</code> Minute (<code>60</code> Sekunden) und <code>2</code> Sekunden. </p> </li> <li> <p>Beispiel 3: Angenommen, es wird der Wert <code>86399</code> \u00fcbergeben, dann sind das <code>23</code> Stunden (<code>23x3600</code> Sekunden), <code>59</code> Minuten (<code>59x60</code> Sekunden) und <code>59</code> Sekunden. </p> </li> <li> <p>Die Stunden sollen immer im Bereich <code>0..23</code> sein, d.h. f\u00fcr einen Stunden-Wert gr\u00f6\u00dfer als <code>24</code> nehmen Sie einfach den <code>Modulo-24</code>-Wert.</p> </li> <li> <p>Initialisieren Sie die Objektvariablen mit den berechneten Werten.  </p> </li> </ul> </li> <li> <p>Schreiben Sie eine Objektmethode <code>uhrzeitInSekunden()</code>. Diese Methode gibt die Uhrzeit in Sekunden als <code>int</code> zur\u00fcck. Der Wert der zur\u00fcckgegebenen Sekunden berechnet sich aus den Stunden multipliziert mit <code>3600</code> plus den Minuten multipliziert mit <code>60</code> plus den Sekunden des aufrufenden <code>Uhrzeit</code>-Objektes.  </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>frueher(Uhrzeit u)</code>, die ein <code>true</code> zur\u00fcckgibt, wenn die Uhrzeit des aufrufenden Objektes fr\u00fcher liegt als der Wert von <code>u</code>; <code>false</code> sonst. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>jetztPlusXSekunden(int sekunden)</code>, die ein neues <code>Uhrzeit</code>-Objekt zur\u00fcckgibt. Die Uhrzeit des neuen Objektes ergibt sich aus der Uhrzeit des aufrufenden Objektes plus der Anzahl der Sekunden, die als Parameter \u00fcbergeben werden.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>differenzInSekunden(Uhrzeit u)</code>, die die Anzahl in Sekunden (<code>int</code>) zur\u00fcckgibt, die zwischen der Uhrzeit des aufrufenden Objektes und <code>u</code> liegen. Geben Sie die Anzahl stets als positiven Wert zur\u00fcck! Sie k\u00f6nnen dazu die Methode <code>Math.abs(int wert)</code> verwenden, die den absoluten Betrag von <code>wert</code> zur\u00fcckgibt. </p> </li> <li> <p>\u00dcberschreiben Sie die Methode <code>toString()</code>, so dass der Wert des aufrufenden Objektes in der Form <code>hh:mm:ss</code> als <code>String</code> zur\u00fcckgegeben wird, z.B. <code>23:59:59</code>. Achten Sie darauf, dass die Stunden, Minuten und Sekunden f\u00fchrende Nullen enthalten k\u00f6nnen, also z.B. <code>01:02:03</code>!</p> </li> <li> <p>Schreiben Sie eine Methode <code>print()</code>, die den von <code>toString()</code> erzeugten <code>String</code> auf die Konsole ausgibt. </p> </li> </ul> </li> <li> <p>Erstellen Sie eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode vier Objekte der Klasse <code>Uhrzeit</code>. Verwenden Sie als Parameterwerte: <code>83</code>, <code>3662</code>, <code>86399</code> und <code>172799</code>. Wenden Sie jeweils die Methoden <code>System.out.print()</code> und <code>print()</code> aus <code>Uhrzeit</code> so an, dass folgende Ausgabe entsteht: <pre><code>z1 : 00:01:23\nz2 : 01:01:02\nz3 : 23:59:59\nz4 : 23:59:59\n</code></pre></p> </li> <li> <p>Wenden Sie au\u00dferdem jeweils die Methoden <code>System.out.println()</code> sowie <code>frueher()</code>, <code>jetztPlusXSekunden()</code>, <code>differenzInSekunden()</code> (und evtl. <code>toString()</code>) aus <code>Uhrzeit</code> so an, dass folgende Ausgabe entsteht: <pre><code>z1 frueher als z2 ? true\nz3 frueher als z4 ? false\n\nz1 plus   40 Sekunden : 00:02:03\nz2 plus 3598 Sekunden : 02:01:00\n\nz3-z2 in Sekunden : 82737\n</code></pre></p> </li> <li> <p>Erstellen Sie eine Klasse <code>UhrzeitArray</code>. Objektvariable <code>uhren</code> ist ein Array, das Elemente von <code>Uhrzeit</code> aufnimmt. Die Variable ist nur innerhalb der Klasse sichtbar.</p> <ul> <li>Schreiben Sie einen parametrisierten Konstruktor <code>UhrzeitArray(int laenge)</code>. Innerhalb des Konstruktors wird das Array erzeugt, auf das die Objektvariable <code>uhren</code> referenziert. Das Array hat die L\u00e4nge <code>laenge</code> (Parameterwert).</li> <li>Schreiben Sie eine Objektmethode <code>fill()</code>, die das <code>uhren</code>-Array vollst\u00e4ndig mit <code>Uhrzeit</code>-Objekten bef\u00fcllt. Die Parameterwerte der <code>Uhrzeit</code>-Objekte werden zuf\u00e4llig erzeugt. Erzeugen Sie ein Objekt der Klasse <code>Random</code> (daf\u00fcr muss <code>java.util.Random</code> importiert werden) und erzeugen Sie die Parameter-Werte f\u00fcr die <code>Uhrzeit</code>-Objekte zuf\u00e4llig (unter Verwendung des <code>Random</code>-Objektes) aus dem Bereich <code>[0, ..., 86399]</code> (<code>0</code> und <code>86399</code> jeweils inklusive)</li> <li>\u00dcberschreiben Sie die Objektmethode <code>toString()</code>, so dass das <code>uhren</code>-Array wie folgt als Zeichenkette zur\u00fcckgegeben wird (Beispielwerte):      <pre><code>((06:38:30), (01:59:32), (07:16:48), (01:37:58), (18:16:06), (07:50:33), (01:41:47), (05:07:41), (12:38:08), (02:00:04)) \n</code></pre>     Also die Uhrzeit jeweils in runden Klammern und durch Komma getrennt sowie das ganze Array in runden Klammern. </li> <li>Schreiben Sie eine Objektmethode <code>print()</code>, so dass auf der Konsole die durch <code>toString()</code> erzeugte eine Zeichenkette ausgegeben wird.  </li> <li>Schreiben Sie eine Objektmethode <code>spaeteste()</code>. Diese Methode gibt die gr\u00f6\u00dfte (sp\u00e4teste) <code>Uhrzeit</code> aus dem Array <code>uhren</code> zur\u00fcck. </li> <li>Schreiben Sie eine Objektmethode <code>zwischen(Uhrzeit frueh, Uhrzeit spaet)</code>. Diese Methode gibt ein <code>UhrzeitArray</code>-Objekt zur\u00fcck. Das zur\u00fcckgegebene <code>UhrzeitArray</code>-Objekt enth\u00e4lt alle <code>Uhrzeit</code>-Objekte aus dem Array <code>uhren</code>, welche zwischen den beiden Uhrzeiten <code>frueh</code> und <code>spaet</code> liegen.</li> <li>Schreiben Sie eine Objektmethode <code>sortieren()</code>. Diese Methode sortiert das <code>uhren</code>-Array aufsteigend beginnend mit der kleinsten Uhrzeit.</li> <li>Schreiben Sie eine Objektmethode <code>kleinsterAbstand()</code>. Diese Methode gibt ein <code>UhrzeitArray</code> der L\u00e4nge <code>2</code> zur\u00fcck. Es enth\u00e4lt die beiden <code>Uhrzeit</code>en aus dem Array <code>uhren</code>, welche den kleinsten Abstand (Differenz in Sekunden) haben. Sie k\u00f6nnen beim Schreiben der Methode davon ausgehen, dass das <code>uhren</code>-Array bereits sortiert ist! </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode ein Objekt der Klasse <code>UhrzeitArray</code>. Das Array soll die L\u00e4nge <code>10</code> haben. </p> <ul> <li> <p>Rufen Sie die <code>fill()</code>- und dann die <code>print()</code>-Methode auf. Es entsteht folgende Ausgabe (Zufallswerte):     <pre><code>((06:38:30), (01:59:32), (07:16:48), (01:37:58), (18:16:06), (07:50:33), (01:41:47), (05:07:41), (12:38:08), (02:00:04))\n</code></pre></p> </li> <li> <p>Wenden Sie jeweils die Methoden <code>System.out.print()</code> sowie <code>spaeteste()</code> so an, dass folgende Ausgabe entsteht (Zufallswerte): <pre><code>spaeteste : 18:16:06\n</code></pre></p> </li> <li> <p>Wenden Sie jeweils die Methoden <code>System.out.print()</code> sowie <code>sortieren()</code> und <code>print()</code> so an, dass folgende Ausgabe entsteht (Zufallswerte):     <pre><code>sortiert  : ((01:37:58), (01:41:47), (01:59:32), (02:00:04), (05:07:41), (06:38:30), (07:16:48), (07:50:33), (12:38:08), (18:16:06))\n</code></pre></p> </li> <li> <p>Erzeugen Sie zwei weitere <code>Uhrzeit</code>-Objekte <code>frueh</code> (Parameterwert <code>36000</code>) und <code>spaet</code> (Parameterwert <code>72000</code>) und rufen Sie damit die Objektmethoden <code>zwischen(frueh, spaet)</code> und <code>print()</code> auf, so dass folgende Ausgabe entsteht (Zufallswerte):     <pre><code>frueh    : 10:00:00\nspaet    : 20:00:00\nzwischen : ((12:38:08), (18:16:06))\n</code></pre></p> </li> <li> <p>Wenden Sie jeweils die Methoden <code>System.out.print()</code> sowie <code>kleinsterAbstand()</code> und <code>print()</code> so an, dass folgende Ausgabe entsteht (Zufallswerte): <pre><code>kleinster Abstand : ((01:59:32), (02:00:04))\n</code></pre></p> </li> </ul> </li> <li> <p>Zur Kontrolle: ungef\u00e4hre Ausgabe auf der Konsole (in Teil 2 Zufallswerte):     <pre><code>--------------- Teil 1 ---------------\n\nz1 : 00:01:23\nz2 : 01:01:02\nz3 : 23:59:59\nz4 : 23:59:59\n\nz1 frueher als z2 ? true\nz3 frueher als z4 ? false\n\nz1 plus   40 Sekunden : 00:02:03\nz2 plus 3598 Sekunden : 02:01:00\n\nz3-z2 in Sekunden : 82737\n\n--------------- Teil 2 ---------------\n\n((06:38:30), (01:59:32), (07:16:48), (01:37:58), (18:16:06), (07:50:33), (01:41:47), (05:07:41), (12:38:08), (02:00:04))\n\nspaeteste : 18:16:06\n\nsortiert  : ((01:37:58), (01:41:47), (01:59:32), (02:00:04), (05:07:41), (06:38:30), (07:16:48), (07:50:33), (12:38:08), (18:16:06))\n\nfrueh    : 10:00:00\nspaet    : 20:00:00\nzwischen : ((12:38:08), (18:16:06))\n\nkleinster Abstand : ((01:59:32), (02:00:04))\n</code></pre></p> </li> </ul> eine m\u00f6gliche L\u00f6sung f\u00fcr Uhrzeit Uhrzeit.javaUhrzeitArray.javaTestklasse.java <pre><code>package klausurvorbereitung.uhrzeit;\n\npublic class Uhrzeit\n{\n    private int stunden;\n    private int minuten;\n    private int sekunden;\n\n    public Uhrzeit(int sekunden)\n    {\n        final int STUNDE = 3600;\n        final int MINUTE = 60;\n\n        this.stunden = (sekunden/STUNDE)%24;\n        int rest = sekunden%STUNDE; \n        this.minuten = rest/MINUTE;\n        rest = rest%MINUTE;\n        this.sekunden = rest;\n    }\n\n    public int uhrZeitInSekunden()\n    {\n        final int STUNDE = 3600;\n        final int MINUTE = 60;\n\n        int sekunden = this.stunden*STUNDE \n                + this.minuten*MINUTE \n                + this.sekunden;\n        return sekunden;\n    }\n\n    public boolean frueher(Uhrzeit u)\n    {\n        return this.uhrZeitInSekunden() &lt; u.uhrZeitInSekunden();\n    }\n\n    public boolean spaeter(Uhrzeit u)\n    {\n        return this.uhrZeitInSekunden() &gt; u.uhrZeitInSekunden();\n    }\n\n    public Uhrzeit jetztPlusXSekunden(int sekunden)\n    {\n        int jetzt = this.uhrZeitInSekunden();\n        int neu = jetzt + sekunden;\n\n        return new Uhrzeit(neu);\n    }\n\n    public int differenzInSekunden(Uhrzeit u)\n    {\n        int uhrzeit1 = this.uhrZeitInSekunden();\n        int uhrzeit2 = u.uhrZeitInSekunden();\n        int diff    = Math.abs(uhrzeit1-uhrzeit2);\n        return diff;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = \"\";\n        if(this.stunden&lt;10)\n        {\n            s = s + \"0\";\n        }\n        s = s + this.stunden +\":\";\n        if(this.minuten&lt;10)\n        {\n            s = s + \"0\";\n        }\n        s = s + this.minuten +\":\";\n        if(this.sekunden&lt;10)\n        {\n            s = s + \"0\";\n        }\n        s = s + this.sekunden;\n\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.uhrzeit;\n\nimport java.util.Random;\n\npublic class UhrzeitArray\n{\n    private Uhrzeit[] uhren;\n\n    public UhrzeitArray(int laenge)\n    {\n        this.uhren = new Uhrzeit[laenge];\n    }\n\n    public void fill()\n    {\n        Random r = new Random();\n        for(int i=0; i&lt;this.uhren.length; i++)\n        {\n            int zufSekunden = r.nextInt(86400);\n            this.uhren[i] = new Uhrzeit(zufSekunden);\n        }\n    }\n\n    public void print()\n    {\n        String s = \"(\";\n        for(int i=0; i&lt;this.uhren.length; i++)\n        {\n            if(i&lt;this.uhren.length-1)\n            {\n                s = s + \"(\" + this.uhren[i].toString() + \"), \";\n            }\n            else\n            {\n                s = s + \"(\" + this.uhren[i].toString() + \")\";\n            }\n        }\n        s = s +\")\";\n        System.out.println(s);\n    }\n\n    public Uhrzeit frueheste()\n    {\n        Uhrzeit frueheste = this.uhren[0];\n        for(int i=1; i&lt;this.uhren.length; i++)\n        {\n            if(this.uhren[i].frueher(frueheste))\n            {\n                frueheste = this.uhren[i];\n            }\n        }\n        return frueheste;\n    }\n\n    public UhrzeitArray zwischen(Uhrzeit frueh, Uhrzeit spaet)\n    {\n        int anzZwischen = 0;\n        for(Uhrzeit u : this.uhren)\n        {\n            if(frueh.frueher(u) &amp;&amp; u.frueher(spaet))\n            {\n                anzZwischen++;\n            }\n        }\n        UhrzeitArray ua = new UhrzeitArray(anzZwischen);\n        int uaIndex = 0;\n        for(int i=0; i&lt;this.uhren.length; i++)\n        {\n            if(frueh.frueher(this.uhren[i]) \n                    &amp;&amp; this.uhren[i].frueher(spaet))\n            {\n                ua.uhren[uaIndex] = this.uhren[i];\n                uaIndex++;\n            }\n        }\n        return ua;\n    }\n\n    public void sortieren()\n    {\n        for(int bubble=0; bubble&lt;this.uhren.length-1; bubble++)\n        {\n            for(int i=0; i&lt;this.uhren.length-1-bubble; i++)\n            {\n                if(this.uhren[i+1].frueher(this.uhren[i]))\n                {\n                    Uhrzeit temp = this.uhren[i];\n                    this.uhren[i] = this.uhren[i+1];\n                    this.uhren[i+1] = temp;\n                }\n            }\n        }\n    }\n\n    public UhrzeitArray kleinsterAbstand()\n    {\n        this.sortieren();\n        Uhrzeit u1 = this.uhren[0];\n        Uhrzeit u2 = this.uhren[1];\n        int kleinsterAbstand = u1.differenzInSekunden(u2);\n        for(int i=1; i&lt;this.uhren.length-1; i++)\n        {\n            if(this.uhren[i].differenzInSekunden(this.uhren[i+1]) \n                    &lt; kleinsterAbstand)\n            {\n                u1 = this.uhren[i];\n                u2 = this.uhren[i+1];\n                kleinsterAbstand = u1.differenzInSekunden(u2);\n            }\n        }\n        UhrzeitArray ua = new UhrzeitArray(2);\n        ua.uhren[0] = u1;\n        ua.uhren[1] = u2;\n        return ua;\n\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.uhrzeit;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n---------------------- Test Uhrzeit --------------------------%n%n\");\n        Uhrzeit z1 = new Uhrzeit(83);\n        Uhrzeit z2 = new Uhrzeit(3662);\n        Uhrzeit z3 = new Uhrzeit(86399);\n        Uhrzeit z4 = new Uhrzeit(172799);\n\n        System.out.print(\"z1 : \"); \n        z1.print();\n        System.out.print(\"z2 : \"); \n        z2.print();\n        System.out.print(\"z3 : \"); \n        z3.print();\n        System.out.print(\"z4 : \"); \n        z4.print();\n\n        System.out.println(\"z1 frueher als z2 ? \" + z1.frueher(z2));\n        System.out.println(\"z3 frueher als z4 ? \" + z3.frueher(z4));\n\n        System.out.println(\"z1 plus   40 Sekunden : \" \n        + z1.jetztPlusXSekunden(40));\n        System.out.println(\"z2 plus 3598 Sekunden : \" \n        + z2.jetztPlusXSekunden(3598));\n\n        System.out.println(\"z3-z2 in Sekunden : \" \n        + z3.differenzInSekunden(z2));\n\n        System.out.printf(\"%n%n------------------- Test UhrzeitArray ------------------------%n%n\");\n        UhrzeitArray ua = new UhrzeitArray(10);\n        ua.fill();\n        ua.print();\n        System.out.println(\"frueheste : \" + ua.frueheste());\n\n        Uhrzeit frueh = new Uhrzeit(36000);\n        Uhrzeit spaet = new Uhrzeit(72000);\n        UhrzeitArray zwischen = ua.zwischen(frueh, spaet);\n\n        System.out.print(\"frueh    : \"); frueh.print();\n        System.out.print(\"spaet    : \"); spaet.print();\n        System.out.print(\"zwischen : \"); zwischen.print();\n\n        ua.sortieren();\n        ua.print();\n\n        UhrzeitArray kleinsterAbstand = ua.kleinsterAbstand();\n        System.out.print(\"kleinster Abstand : \");\n        kleinsterAbstand.print();   \n    }\n}\n</code></pre> L\u00e4nder und Kontinente <ul> <li> <p>Implementieren Sie eine Klasse <code>Land</code>. </p> <ul> <li> <p>Objektvariablen sind <code>name</code> vom Typ <code>String</code> (Name des Landes), <code>groesse</code> vom Typ <code>int</code> (Gr\u00f6\u00dfe des Landes) und <code>einwohner</code> vom Typ <code>int</code> (Anzahl der Einwohner des Landes). Die Objektvariablen sind nur in der Klasse sichtbar!</p> </li> <li> <p>Schreiben Sie f\u00fcr alle drei Objektvariablen Getter (<code>getName()</code>, <code>getGroesse()</code>, `getEinwohner())! </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>erzeugeName()</code>. Diese Methode gibt einen <code>String</code> zur\u00fcck, der sich aus einem gro\u00dfen Buchstaben und einer Ziffer zusammensetzt, also z.B. <code>K8</code>, <code>L1</code>, <code>J4</code> usw.  Sowohl der Gro\u00dfbuchstabe als auch die Ziffer sollen mithilfe der Klasse <code>Random</code> zuf\u00e4llig erzeugt werden. </p> </li> <li> <p>Tipps:</p> <ul> <li>um die Klasse <code>Random</code> verwenden zu k\u00f6nnen, m\u00fcssen Sie sie aus dem <code>java.util</code>-Paket importieren,</li> <li>verwenden Sie sowohl zum Erzeugen des Gro\u00dfbuchstabens als auch zum Erzeugen der Ziffer die Objektmethode <code>nextInt(int bound)</code> der Klasse <code>Random</code>,</li> <li>der ASCII-Code von <code>A</code> ist <code>65</code>, der von <code>Z</code> ist <code>90</code> (es sind 26 verschiedene Buchstaben)</li> <li>bei den Ziffern sind alle 10 Ziffern [0, \u2026,9] m\u00f6glich</li> </ul> </li> <li> <p>Schreiben Sie f\u00fcr die Klasse <code>Land</code> einen parameterlosen Konstruktor. In diesem Konstruktor wird</p> <ul> <li>die Objektvariable <code>name</code> mithilfe der <code>erzeugeName()</code>-Methode initialisiert,</li> <li>die Objektvariable <code>groesse</code> wird mit einem Zufallswert aus dem Wertebereich [1, \u2026, 100] (100 verschiedene Zahlen, 1 und 100 inklusive) initialisiert und </li> <li>die Objektvariable <code>einwohner</code> mit einem Zufallswert aus dem Wertebereich [1, \u2026, 1000] (1000 verschiedene Zahlen, 1 und 1000 inklusive) initialisiert. </li> <li>Nutzen Sie erneut die Klasse <code>Random</code> und die Methode <code>nextInt(bound)</code>.</li> </ul> </li> <li> <p>Schreiben Sie eine Objektmethode <code>ewDichte()</code>. Diese Methode gibt ein <code>double</code> zur\u00fcck und gibt die Anzahl der <code>einwohner</code> pro <code>groesse</code> an. </p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code> so, dass ein Land in der folgenden Form als ein <code>String</code> zur\u00fcckgegeben wird (Zufallswerte):     <pre><code>A3 :  37 km2 :   91 ew :   2,4595\n</code></pre></p> <ul> <li>Zuerst der Name des Landes und dann <code>:</code>, </li> <li>dann die Groesse des Landes gefolgt von <code>km2 :</code>,</li> <li>dann die Anzahl der Einwohner des Landes gefolgt von <code>ew :</code>  und</li> <li>dann die Einwohnerdichte mit vier Stellen nach dem Komma. </li> </ul> <p>Der String soll so formatiert sein, dass die Doppelpunkte <code>:</code> und das Komma bei der Einwohnerdichte bei der Ausgabe mehrerer Strings untereinander stehen!, also z.B. so:     <pre><code>G5 :  76 km2 :   25 ew :   0,3289\nW0 :  60 km2 :   18 ew :   0,3000\nS9 :   6 km2 :  585 ew :  97,5000\nH1 :   4 km2 :  965 ew : 241,2500\n</code></pre></p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>. Diese Methode gibt den durch <code>toString()</code> erzeugten <code>String</code> auf der Konsole aus.</p> </li> <li> <p>Schreiben Sie die Objektmethode <code>istGroesser(Land land)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von <code>groesse</code> gr\u00f6\u00dfer ist als von <code>land</code>. Ansonsten <code>false</code>. </p> </li> <li> <p>Schreiben Sie die Objektmethode <code>hatMehrEinwohner(Land land)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von <code>einwohner</code> gr\u00f6\u00dfer ist als von <code>land</code>. Ansonsten <code>false</code>. </p> </li> <li> <p>Schreiben Sie die Objektmethode <code>nameIstGroesser(Land land)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn bei dem aufrufenden Objekt der Wert von <code>name</code> lexikografisch gr\u00f6\u00dfer ist als von <code>land</code>. Ansonsten false.</p> </li> </ul> <p>Tipp: f\u00fcr zwei Strings <code>s1</code> und <code>s2</code> gilt, dass <code>s1</code> lexikografisch gr\u00f6\u00dfer ist, wenn der Wert von <code>s1.compareTo(s2)</code> einem positiven <code>int</code>-Wert etspricht. </p> <ul> <li>\u00dcberschreiben Sie die Objektmethode <code>equals(Object o)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn das aufrufende Objekt den gleichen Namen hat wie <code>o</code>. Sonst <code>false</code>. </li> </ul> </li> <li> <p>Schreiben Sie eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode in einer Schleife <code>10</code> Objekte der Klasse <code>Land</code> und rufen (auch in der Schleife) jeweils die <code>print()</code>-Methode auf. </p> <p>Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): <pre><code>J6 :  34 km2 :  198 ew :   5,8235\nB4 :  72 km2 :  171 ew :   2,3750\nZ8 :  93 km2 :  712 ew :   7,6559\nW2 :  75 km2 :  149 ew :   1,9867\nO0 : 100 km2 :  576 ew :   5,7600\nQ5 :  21 km2 :  210 ew :  10,0000\nO9 :  71 km2 :  533 ew :   7,5070\nB8 :  52 km2 :   57 ew :   1,0962\nK4 :  71 km2 :  830 ew :  11,6901\nA9 :  98 km2 :  288 ew :   2,9388\n</code></pre></p> <ul> <li> <p>Erzeugen Sie 1 Objekt von <code>Land</code> und rufen Sie f\u00fcr dieses Objekt die <code>print()</code>-Methode auf. Erzeugen Sie in einer Schleife so lange ein weiteres Objekt von <code>Land</code>, bis die beiden Objekte laut <code>equals()</code>-Methode gleich sind. Z\u00e4hlen Sie mit, wie viele Objekte von <code>Land</code> Sie erzeugen mussten, bis ein gleiches Objekt gefunden wurde. Geben Sie das gefundene Objekt mithilfe der <code>print()</code>-Methode aus und wie viele Objekte erzeugt wurden. </p> <p>Es entsteht folgende Ausgabe (Beispielwerte sind zuf\u00e4llig und unterscheiden sich!): <pre><code>I1 :  28 km2 :  914 ew :  32,6429\nI1 :  80 km2 :    1 ew :   0,0125\n43 andere Laender erzeugt\n</code></pre></p> </li> <li> <p>Erzeugen Sie zwei Objekte <code>l1</code> und <code>l2</code> von <code>Land</code> und wenden Sie die Methoden <code>istGroesser()</code>, <code>hatMehrEinwohner()</code> und <code>nameIstGroesser()</code> so an, dass folgende Ausgabe entsteht (Zufallswerte!):     <pre><code>l1 : T0 :  30 km2 :  237 ew :   7,9000\nl2 : K0 :  29 km2 :  328 ew :  11,3103\n\nl1 groesser als l2 ?                : true\nl1 mehr Einwohner als l2 ?          : false\nl1 lexikografisch groesser als l2 ? : true\n</code></pre></p> </li> </ul> </li> <li> <p>Schreiben Sie eine Klasse <code>Kontinent</code>. </p> <ul> <li> <p>Objektvariablen dieser Klasse sind:</p> <ul> <li> <p><code>laender</code> vom Typ <code>Land[]</code> und</p> </li> <li> <p><code>kontinent</code> vom Typ <code>char</code>. </p> </li> </ul> <p>Beide Objektvariablen sind nur innerhalb der Klasse sichtbar!</p> </li> <li> <p>Schreiben Sie einen parametrisierten Konstruktor <code>Kontinent(char kontinent, int anzahlLaender)</code>. Innerhalb des Konstruktors werden:</p> <ul> <li>der Parameterwert <code>kontinent</code> verwendet, um die Objektvariable <code>kontinent</code> zu initialisieren, </li> <li>das Array erzeugt, auf das die Objektvariable <code>laender</code> referenziert. Das Array hat die L\u00e4nge <code>anzahlLaender</code>,</li> <li>sowie das <code>laender</code>-Array vollst\u00e4ndig mit Objekten vom Typ <code>Land</code> bef\u00fcllt.</li> </ul> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getAnzLaender()</code>. Diese Methode gibt die Anzahl der L\u00e4nder im <code>laender</code>-Array als <code>int</code> zur\u00fcck.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getLaender()</code>. Diese Methode gibt eine Referenz auf das <code>laender</code>-Array zur\u00fcck.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getLandAtIndex(int index)</code>. Diese Methode gibt das <code>Land</code> zur\u00fcck, das im <code>laender</code>-Array unter dem Index <code>index</code> gespeichert ist. Sollte <code>index</code> kein korrekter Index aus dem <code>laender</code>-Array sein, wird <code>null</code> zur\u00fcckgegeben. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getSummen()</code>. Diese Methode gibt ein <code>int</code>-Array der L\u00e4nge <code>2</code> zur\u00fcck. </p> <ul> <li> <p>Der erste Eintrag in diesem Array ist die Summe der Gr\u00f6\u00dfen aller L\u00e4nder im <code>laender</code>-Array und </p> </li> <li> <p>der zweite Eintrag ist die Summe der Einwohner aller L\u00e4nder im <code>laender</code>-Array. </p> </li> </ul> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code> so, dass ein <code>String</code> in der folgenden Form zur\u00fcckgegeben wird (Zufallswerte!): <pre><code>Kontinent a \n--------------------------\nS2 :  81 km2 :  918 ew :  11,3333 \nZ7 :  14 km2 :  453 ew :  32,3571 \nO4 :  35 km2 :  713 ew :  20,3714 \nQ9 :  14 km2 :  728 ew :  52,0000 \nF1 :  23 km2 :  714 ew :  31,0435 \nK9 :  67 km2 :  630 ew :   9,4030 \nW5 :  35 km2 :  128 ew :   3,6571 \n\nSummen : 269 : 4284 \n</code></pre></p> <ul> <li> <p>es wird Kontinent und der Name des Kontinents in der ersten Zeile ausgegeben, </p> </li> <li> <p>dann kommt eine Trennlinie (egal, wie lang), </p> </li> <li> <p>dann kommen untereinander alle L\u00e4nder aus dem laender-Array, </p> </li> <li> <p>dann kommt eine Lehrzeile und</p> </li> <li> <p>dann kommen die Summen der Gr\u00f6\u00dfen der L\u00e4nder und die Summen der Einwohner (beliebig formatiert)</p> </li> </ul> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>. Diese Methode gibt den durch <code>toString()</code> erzeugten <code>String</code> auf der Konsole aus.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>sortiere(int nach)</code>. Diese Methode sortiert das <code>laender</code>-Array aufsteigend von klein nach gro\u00df. Der Parameter nach hat folgende Bedeutung:</p> <ul> <li> <p>Ist der Wert von <code>nach</code> <code>0</code>, dann wird das Array nach der <code>groesse</code> der L\u00e4nder sortiert. </p> </li> <li> <p>Ist der Wert von <code>nach</code> <code>1</code>, dann wird das Array nach der Anzahl der <code>einwohner</code> der L\u00e4nder sortiert.</p> </li> <li> <p>Ist der Wert von <code>nach</code> <code>2</code>, dann wird das Array nach der Einwohnerdichte (<code>ewDichte</code>) der L\u00e4nder sortiert.</p> </li> <li> <p>F\u00fcr jeden anderen Wert von <code>nach</code> (also alles au\u00dfer <code>0,1,2</code>) wird das Array lexikografisch nach den Namen der L\u00e4nder sortiert. </p> </li> </ul> </li> </ul> </li> <li> <p>Erzeugen Sie in der <code>main()</code>-Methode ein Array, in dem jedes Element vom Typ <code>Kontinent</code> ist. Das Array hat die L\u00e4nge <code>5</code>. Bef\u00fcllen Sie dieses Array mit <code>Kontinent</code>-Objekten in einer Schleife(!) wie folgt:</p> <ul> <li> <p>Die f\u00fcnf Kontinente haben die Namen <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> (der ASCII-Code von <code>a</code> ist <code>97</code>, der von <code>b</code> ist <code>98</code> usw. ).</p> </li> <li> <p>Der erste Kontinent hat 7 L\u00e4nder, der zweite hat 8, der dritte 9, der vierte 10 und der f\u00fcnfte Kontinent hat 11 L\u00e4nder.</p> </li> <li> <p>Rufen Sie f\u00fcr alle Kontinente jeweils die <code>print()</code>-Methode auf. Es entsteht folgende Ausgabe (Zufallswerte!): <pre><code>Kontinent a\n--------------------------\nS2 :  81 km2 :  918 ew :  11,3333 \nZ7 :  14 km2 :  453 ew :  32,3571 \nO4 :  35 km2 :  713 ew :  20,3714 \nQ9 :  14 km2 :  728 ew :  52,0000 \nF1 :  23 km2 :  714 ew :  31,0435 \nK9 :  67 km2 :  630 ew :   9,4030 \nW5 :  35 km2 :  128 ew :   3,6571 \n\nSummen : 269 : 4284\n\nKontinent b \n--------------------------\nR8 :  65 km2 :  337 ew :   5,1846 \nL9 :  57 km2 :  732 ew :  12,8421 \nT0 :  74 km2 :  796 ew :  10,7568 \nP4 :  13 km2 :  481 ew :  37,0000 \nL5 :  48 km2 :  575 ew :  11,9792 \nQ2 :  35 km2 :  538 ew :  15,3714 \nM8 :  72 km2 :  865 ew :  12,0139 \nT0 :  29 km2 :  855 ew :  29,4828 \n\nSummen : 393 : 5179\n\nKontinent c \n--------------------------\nI9 :  91 km2 :   84 ew :   0,9231 \nX9 :  41 km2 :  842 ew :  20,5366 \nV7 :  31 km2 :  120 ew :   3,8710 \nO3 :  48 km2 :  990 ew :  20,6250 \nP6 :  27 km2 :  565 ew :  20,9259 \nJ7 :  54 km2 :  810 ew :  15,0000 \nS9 :  72 km2 :  401 ew :   5,5694 \nC4 :  29 km2 :  486 ew :  16,7586 \nI2 :   6 km2 :  393 ew :  65,5000 \n\nSummen : 399 : 4691\n\nKontinent d \n--------------------------\nC0 :  44 km2 :  122 ew :   2,7727 \nE2 :   8 km2 :  925 ew : 115,6250 \nI1 :  12 km2 :  585 ew :  48,7500 \nX9 :  13 km2 :  583 ew :  44,8462 \nZ6 :  10 km2 :   24 ew :   2,4000 \nJ1 :  20 km2 :  161 ew :   8,0500 \nI2 :  75 km2 :  432 ew :   5,7600 \nY8 :  69 km2 :  224 ew :   3,2464 \nH1 :  45 km2 :  410 ew :   9,1111 \nP1 :  24 km2 :  332 ew :  13,8333 \n\nSummen : 320 : 3798\n\nKontinent e \n--------------------------\nJ6 :  22 km2 :  358 ew :  16,2727 \nN9 :  95 km2 :  471 ew :   4,9579 \nG5 :  94 km2 :  524 ew :   5,5745 \nG0 :  72 km2 :  753 ew :  10,4583 \nL3 :  84 km2 :   49 ew :   0,5833 \nM8 :  39 km2 :   13 ew :   0,3333 \nK7 :  22 km2 :  881 ew :  40,0455 \nY3 :  58 km2 :  355 ew :   6,1207 \nH3 :  28 km2 :    2 ew :   0,0714 \nV2 :  67 km2 :   94 ew :   1,4030 \nS9 :  15 km2 :  392 ew :  26,1333 \n\nSummen : 596 : 3892\n</code></pre></p> </li> <li> <p>Rufen Sie f\u00fcr den ersten Kontinent im Array nacheinander die Methoden <code>sortiere(0)</code>, <code>print()</code>, <code>sortiere(1)</code>, <code>print()</code>, <code>sortiere(2)</code>, <code>print()</code>, <code>sortiere(3)</code>, <code>print()</code> auf. Es entsteht folgende Ausgabe (Zufallswerte!): <pre><code>Kontinent a           // keine Ausgabe, nur Info: Kontinent unsortiert \n--------------------------\nS2 :  81 km2 :  918 ew :  11,3333 \nZ7 :  14 km2 :  453 ew :  32,3571 \nO4 :  35 km2 :  713 ew :  20,3714 \nQ9 :  14 km2 :  728 ew :  52,0000 \nF1 :  23 km2 :  714 ew :  31,0435 \nK9 :  67 km2 :  630 ew :   9,4030 \nW5 :  35 km2 :  128 ew :   3,6571 \n\nKontinent a           // keine Ausgabe, nur Info: nach groesse sortiert \n--------------------------\nZ7 :  14 km2 :  453 ew :  32,3571 \nQ9 :  14 km2 :  728 ew :  52,0000 \nF1 :  23 km2 :  714 ew :  31,0435 \nO4 :  35 km2 :  713 ew :  20,3714 \nW5 :  35 km2 :  128 ew :   3,6571 \nK9 :  67 km2 :  630 ew :   9,4030 \nS2 :  81 km2 :  918 ew :  11,3333 \n\nKontinent a           // keine Ausgabe, nur Info: nach einwohner sortiert \n--------------------------\nW5 :  35 km2 :  128 ew :   3,6571 \nZ7 :  14 km2 :  453 ew :  32,3571 \nK9 :  67 km2 :  630 ew :   9,4030 \nO4 :  35 km2 :  713 ew :  20,3714 \nF1 :  23 km2 :  714 ew :  31,0435 \nQ9 :  14 km2 :  728 ew :  52,0000 \nS2 :  81 km2 :  918 ew :  11,3333 \n\nKontinent a           // keine Ausgabe, nur Info: nach ewDichte sortiert \n--------------------------\nW5 :  35 km2 :  128 ew :   3,6571 \nK9 :  67 km2 :  630 ew :   9,4030 \nS2 :  81 km2 :  918 ew :  11,3333 \nO4 :  35 km2 :  713 ew :  20,3714 \nF1 :  23 km2 :  714 ew :  31,0435 \nZ7 :  14 km2 :  453 ew :  32,3571 \nQ9 :  14 km2 :  728 ew :  52,0000 \n\nKontinent a           // keine Ausgabe, nur Info: nach name sortiert \n--------------------------\nF1 :  23 km2 :  714 ew :  31,0435 \nK9 :  67 km2 :  630 ew :   9,4030 \nO4 :  35 km2 :  713 ew :  20,3714 \nQ9 :  14 km2 :  728 ew :  52,0000 \nS2 :  81 km2 :  918 ew :  11,3333 \nW5 :  35 km2 :  128 ew :   3,6571 \nZ7 :  14 km2 :  453 ew :  32,3571\n</code></pre></p> </li> </ul> </li> <li> <p>Schreiben Sie eine Klasse <code>Welt</code>.</p> <ul> <li> <p>Objektvariable dieser Klasse ist <code>kontinente</code> vom Typ <code>Kontinent[]</code>. Die Objektvariable ist nur innerhalb der Klasse sichtbar!</p> </li> <li> <p>Schreiben Sie einen parametrisierten Konstruktor <code>Welt(Kontinent[] kontinente)</code>. Die Referenz des Parameters wird der Objektvariablen zugewiesen. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>getAlleLaender()</code>. Diese Methode gibt ein <code>Land</code>-Array zur\u00fcck, in dem alle L\u00e4nder aus dem <code>kontinente</code>-Array enthalten sind. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>printAlleLaender(Land[] alleLaender)</code>, die das als Parameter \u00fcbergebene Array in der folgenden Form ausgibt (Zufallswerte!):  <pre><code>F1 :  23 km2 :  714 ew :  31,0435\nK9 :  67 km2 :  630 ew :   9,4030\nO4 :  35 km2 :  713 ew :  20,3714\nQ9 :  14 km2 :  728 ew :  52,0000\nS2 :  81 km2 :  918 ew :  11,3333\nW5 :  35 km2 :  128 ew :   3,6571\nZ7 :  14 km2 :  453 ew :  32,3571\nR8 :  65 km2 :  337 ew :   5,1846\nL9 :  57 km2 :  732 ew :  12,8421\nT0 :  74 km2 :  796 ew :  10,7568\nP4 :  13 km2 :  481 ew :  37,0000\nL5 :  48 km2 :  575 ew :  11,9792\n</code></pre>     Es sind mehr L\u00e4nder \u2013 ist hier gek\u00fcrzt. Also einfach alle L\u00e4nder untereinander.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>enthaeltDoppel()</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn das <code>kontinente</code>-Array L\u00e4nder enth\u00e4lt, die den gleichen Namen haben, also laut <code>equals()</code> gleich sind. Ansonsten <code>false</code>. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>groesstestLand()</code>. Diese Methode gibt das gr\u00f6\u00dfte Land (gr\u00f6\u00dfte <code>groesse</code>) aller L\u00e4nder im <code>kontinente</code>-Array zur\u00fcck. </p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>alleLaenderGroesserAls(int groesse)</code>, die ein <code>Land[]</code> zur\u00fcckgibt. Das zur\u00fcckgegebene <code>Land[]</code> enth\u00e4lt alle L\u00e4nder aus dem <code>kontinente</code>-Array, die gr\u00f6\u00dfer sind als der Parameterwert <code>groesse</code>.</p> </li> </ul> </li> <li> <p>Testen Sie in der <code>main()</code>-Methode die Methoden <code>getAlleLaender()</code> und <code>printAlleLaender()</code> der Klasse <code>Welt</code>, so dass f\u00fcr die Methoden folgende Ausgaben entstehen (Zufallswerte!): <pre><code>L6 :  37 km2 :  122 ew :   3,2973\nM9 :  22 km2 :  351 ew :  15,9545\nO4 :  84 km2 :  717 ew :   8,5357\nP4 :  93 km2 :  759 ew :   8,1613\nQ3 :   3 km2 :  771 ew : 257,0000\nR1 :  48 km2 :  610 ew :  12,7083\nV3 :  40 km2 :  153 ew :   3,8250\nE8 :  58 km2 :  195 ew :   3,3621\nI9 :  19 km2 :  875 ew :  46,0526\nZ6 :  47 km2 :  188 ew :   4,0000\nY6 :  75 km2 :  858 ew :  11,4400\nC7 :  26 km2 :  676 ew :  26,0000\nV8 :   1 km2 :  470 ew : 470,0000\nQ8 :  92 km2 :  214 ew :   2,3261\nT7 :  52 km2 :  544 ew :  10,4615\nU1 :  46 km2 :  939 ew :  20,4130\nC9 :  22 km2 :  594 ew :  27,0000\nZ5 :  94 km2 :  353 ew :   3,7553\nG6 :   9 km2 :  237 ew :  26,3333\nD8 :  85 km2 :  910 ew :  10,7059\nI5 :  15 km2 :  521 ew :  34,7333\nV7 :  58 km2 :  546 ew :   9,4138\nV8 :  25 km2 :  535 ew :  21,4000\nI4 :  91 km2 :  407 ew :   4,4725\nW1 :  92 km2 :  278 ew :   3,0217\nM4 :  30 km2 :  494 ew :  16,4667\nR5 :   8 km2 :  912 ew : 114,0000\nO1 :  15 km2 :  858 ew :  57,2000\nS3 :  46 km2 :  463 ew :  10,0652\nM9 :  43 km2 :  624 ew :  14,5116\nP5 :  35 km2 :  704 ew :  20,1143\nY2 :   2 km2 :  243 ew : 121,5000\nX9 :  79 km2 :  928 ew :  11,7468\nZ4 :  36 km2 :  311 ew :   8,6389\nC6 :   2 km2 :  249 ew : 124,5000\nJ6 :   6 km2 :  683 ew : 113,8333\nG8 :  18 km2 :    3 ew :   0,1667\nW3 :  24 km2 :  502 ew :  20,9167\nK9 :  81 km2 :  996 ew :  12,2963\nA0 :  46 km2 :  950 ew :  20,6522\nK9 :  99 km2 :   84 ew :   0,8485\nT5 :  93 km2 :  488 ew :   5,2473\nX1 :  40 km2 :  555 ew :  13,8750\nQ9 :  18 km2 :  631 ew :  35,0556\nI9 :  22 km2 :  867 ew :  39,4091\n</code></pre></p> <ul> <li>Rufen Sie die Methoden <code>enthaeltDoppel()</code>, <code>groesstesLand()</code>, <code>alleLaenderGroesserAls(50)</code> und <code>printAlleLaender()</code> so auf, dass folgende Ausgaben entstehen (Zufallswerte!):  <pre><code>Enthaelt Doppel? : true\ngroesstes Land   : K9 :  99 km2 :   84 ew :   0,8485\nAlle Laender groesser als 50 :\nO4 :  84 km2 :  717 ew :   8,5357\nP4 :  93 km2 :  759 ew :   8,1613\nE8 :  58 km2 :  195 ew :   3,3621\nY6 :  75 km2 :  858 ew :  11,4400\nQ8 :  92 km2 :  214 ew :   2,3261\nT7 :  52 km2 :  544 ew :  10,4615\nZ5 :  94 km2 :  353 ew :   3,7553\nD8 :  85 km2 :  910 ew :  10,7059\nV7 :  58 km2 :  546 ew :   9,4138\nI4 :  91 km2 :  407 ew :   4,4725\nW1 :  92 km2 :  278 ew :   3,0217\nX9 :  79 km2 :  928 ew :  11,7468\nK9 :  81 km2 :  996 ew :  12,2963\nK9 :  99 km2 :   84 ew :   0,8485\nT5 :  93 km2 :  488 ew :   5,2473\n</code></pre></li> </ul> </li> </ul> eine m\u00f6gliche L\u00f6sung f\u00fcr L\u00e4nder und Kontinente Land.javaKontinent.javaWelt.javaTestklasse.java <pre><code>package klausurvorbereitung.land;\n\nimport java.util.Random;\n\npublic class Land\n{\n    private String name;\n    private int groesse;\n    private int einwohner;\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public int getGroesse()\n    {\n        return this.groesse;\n    }\n\n    public int getEinwohner()\n    {\n        return this.einwohner;\n    }\n\n    public String erzeugeName()\n    {\n        Random r = new Random();\n        int ascii = r.nextInt(26) + 65;\n        char c = (char)ascii;\n        String s = \"\" + c;\n\n        int nr = r.nextInt(10);\n        s += nr;\n        return s;\n    }\n\n    public Land()\n    {\n        this.name = this.erzeugeName();\n        Random r = new Random();\n        this.groesse = r.nextInt(100) + 1;\n        this.einwohner = r.nextInt(1000) + 1;\n    }\n\n    public double ewDichte()\n    {\n        double ewDichte = (double)this.einwohner / (double)this.groesse;\n        return ewDichte;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"%s : %3d km2 : %4d ew : %8.4f\", this.name, this.groesse, this.einwohner, this.ewDichte());\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public boolean istGroesser(Land l)\n    {\n        return this.groesse &gt; l.groesse;\n    }\n\n    public boolean hatMehrEinwohner(Land l)\n    {\n        return this.einwohner &gt; l.einwohner;\n    }\n\n    public boolean nameIstGroesser(Land l)\n    {\n        return this.name.compareTo(l.name) &gt; 0;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        Land lo = (Land)o;\n        return this.name.equals(lo.name);\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.land;\n\npublic class Kontinent\n{\n    private Land[] laender;\n    private char kontinent;\n\n    public Kontinent(char kontinent, int anzahlLaender)\n    {\n        this.kontinent = kontinent;\n        this.laender = new Land[anzahlLaender];\n        for (int index = 0; index &lt; this.laender.length; index++)\n        {\n            this.laender[index] = new Land();\n        }\n    }\n\n    public int getAnzLaender()\n    {\n        return this.laender.length;\n    }\n\n    public Land[] getLaender()\n    {\n        return this.laender;\n    }\n\n    public Land getLandAtIndex(int index)\n    {\n        if(index&gt;=0 &amp;&amp; index&lt;this.getAnzLaender())\n        {\n            return this.laender[index];\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /*\n    public char getKontinent()\n    {\n        return this.kontinent;\n    }\n    */\n\n    public int[] getSummen()\n    {\n        int summeEw = 0;\n        int summeQm = 0;\n        for (int index = 0; index &lt; this.laender.length; index++)\n        {\n            summeEw += this.laender[index].getEinwohner();\n            summeQm += this.laender[index].getGroesse();\n        }\n        int[] summen = {summeQm, summeEw};\n        return summen;\n    }\n\n    @Override\n    public String toString()\n    {\n        String s = String.format(\"Kontinent %c %n\", this.kontinent);\n        s += String.format(\"--------------------------%n\");\n        for (int index = 0; index &lt; this.laender.length; index++)\n        {\n            s += String.format(\"%24s %n\", this.laender[index]);\n        }\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public void sortiere(int nach)\n    {\n        for(int bubble=1; bubble&lt;this.laender.length; bubble++)\n        {\n            for(int index=0; index&lt;this.laender.length-bubble; index++)\n            {\n                if(nach==0 &amp;&amp; this.laender[index].istGroesser(this.laender[index+1]) ||\n                   nach==1 &amp;&amp; this.laender[index].hatMehrEinwohner(this.laender[index+1]) ||\n                   nach==2 &amp;&amp; this.laender[index].ewDichte() &gt; this.laender[index+1].ewDichte() ||\n                   nach!=0 &amp;&amp; nach!=1 &amp;&amp; nach!=2 &amp;&amp; this.laender[index].nameIstGroesser(this.laender[index+1]))\n                {\n                    Land tmp = this.laender[index];\n                    this.laender[index] = this.laender[index+1];\n                    this.laender[index+1] = tmp;\n                }\n            }\n        }\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.land;\n\npublic class Welt\n{\n    private Kontinent[] kontinente;\n\n    public Welt(Kontinent[] kontinente)\n    {\n        this.kontinente = kontinente;\n    }\n\n    public int anzahlLaender()\n    {\n        int anzahl = 0;\n        for (int index = 0; index &lt; this.kontinente.length; index++)\n        {\n            anzahl += this.kontinente[index].getAnzLaender();\n        }\n        return anzahl;\n    }\n\n    public Land[] getAlleLaender()\n    {\n        Land[] alleLaender = new Land[this.anzahlLaender()];\n        int indexAlle = 0;\n\n        for (int kontinent = 0; kontinent &lt; this.kontinente.length; kontinent++)\n        {\n            for(int index = 0; index &lt; this.kontinente[kontinent].getAnzLaender(); index++)\n            {\n                alleLaender[indexAlle++] = this.kontinente[kontinent].getLandAtIndex(index);\n            }\n        }\n        return alleLaender;\n    }\n\n    /*\n     * war nicht gefordert\n     */\n    public Land[] sortiereAlleLaenderNachName()\n    {\n        Land[] alleLaender = this.getAlleLaender();\n\n        for(int bubble=1; bubble&lt;alleLaender.length; bubble++)\n        {\n            for(int index=0; index&lt;alleLaender.length-bubble; index++)\n            {\n                if(alleLaender[index].nameIstGroesser(alleLaender[index+1]))\n                {\n                    Land tmp = alleLaender[index];\n                    alleLaender[index] = alleLaender[index+1];\n                    alleLaender[index+1] = tmp;\n                }\n            }\n        }\n        return alleLaender;\n    }\n\n    public void printAlleLaender(Land[] alleLaender)\n    {\n        for(int index=0; index&lt;alleLaender.length; index++)\n        {\n            System.out.println(alleLaender[index]);\n        }\n    }\n\n    public boolean enthaeltDoppel()\n    {\n        Land[] alleLaender = this.getAlleLaender();\n        for(int index1=0; index1&lt;alleLaender.length-1; index1++)\n        {\n            for(int index2=index1+1; index2&lt;alleLaender.length; index2++)\n            {\n                if(alleLaender[index1].equals(alleLaender[index2]))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public Land[] alleLaenderGroesserAls(int groesse)\n    {\n        Land[] alleLaender = this.getAlleLaender();\n        int anzahl = 0;\n        for(int index=0; index&lt;alleLaender.length; index++)\n        {\n            if(alleLaender[index].getGroesse() &gt; groesse)\n            {\n                anzahl++;\n            }\n        }\n\n        Land[] laender = new Land[anzahl];\n        int indexLaender = 0;\n        for(int index=0; index&lt;alleLaender.length; index++)\n        {\n            if(alleLaender[index].getGroesse() &gt; groesse)\n            {\n                laender[indexLaender++] = alleLaender[index];\n            }\n        }\n        return laender;\n    }\n\n    public Land groesstesLand()\n    {\n        Land[] alleLaender = this.getAlleLaender();\n        int indexGroesstes = 0;\n        for(int index=1; index&lt;alleLaender.length; index++)\n        {\n            if(alleLaender[index].istGroesser(alleLaender[indexGroesstes]))\n            {\n                indexGroesstes = index;\n            }\n        }\n        return alleLaender[indexGroesstes];\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.land;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n------------------ Test Land ------------------%n%n\");\n        for(int i=0; i&lt;10; i++)\n        {\n            new Land().print();\n        }\n\n        System.out.printf(\"%n%n----------------- Land equals -----------------%n%n\");\n        Land l1 = new Land();\n        Land l2 = new Land();\n        int anz = 0;\n        while(!l1.equals(l2))\n        {\n            l2 = new Land();\n            anz++;\n        }\n        l1.print();\n        l2.print();\n        System.out.println(anz + \" andere Laender erzeugt\");\n\n        System.out.printf(\"%n%n----------------- Land Vergleiche -----------------%n%n\");\n        l1 = new Land();\n        l2 = new Land();\n        System.out.print(\"l1 : \");l1.print();\n        System.out.print(\"l2 : \");l2.print();\n        System.out.println();\n        System.out.println(\"l1 groesser als l2 ?                : \" + l1.istGroesser(l2));\n        System.out.println(\"l1 mehr Einwohner als l2 ?          : \" + l1.hatMehrEinwohner(l2));\n        System.out.println(\"l1 lexikografisch groesser als l2 ? : \" + l1.nameIstGroesser(l2));\n\n        System.out.printf(\"%n%n----------------- Kontinent ------------------%n%n\");\n        final int ANZAHL_KONTINENTE = 5;\n        final int ASCII_KLEIN_A = 97;\n\n        Kontinent[] ka = new Kontinent[ANZAHL_KONTINENTE];\n        for(int index=0; index &lt; ANZAHL_KONTINENTE; index++)\n        {\n            char c = (char)(index+ASCII_KLEIN_A);\n            int anzahlLaender = index + 7;\n            ka[index] = new Kontinent(c, anzahlLaender);\n            ka[index].print();\n            int[] summen = ka[index].getSummen();\n            System.out.println(\"Summen : \" + summen[0] + \" : \" + summen[1] );\n            System.out.println();\n        }\n\n        System.out.printf(\"%n%n----------------- sortieren ------------------%n%n\");\n        ka[0].print();\n        ka[0].sortiere(0);\n        ka[0].print();\n        ka[0].sortiere(1);\n        ka[0].print();\n        ka[0].sortiere(2);\n        ka[0].print();\n        ka[0].sortiere(3);\n        ka[0].print();\n\n        System.out.printf(\"%n%n----------------- Welt ------------------%n%n\");\n        Welt welt = new Welt(ka);\n        Land[] alleLaender = welt.getAlleLaender();\n        welt.printAlleLaender(alleLaender);\n        System.out.println();\n        System.out.println(\"Enthaelt Doppel? : \" + welt.enthaeltDoppel());\n        Land groesstes = welt.groesstesLand();\n        System.out.println(\"groesstes Land   : \" + groesstes.toString());\n        Land[] groesser = welt.alleLaenderGroesserAls(50);\n        System.out.println(\"Alle Laender groesser als 50 :\");\n        welt.printAlleLaender(groesser);\n\n    }\n\n}\n</code></pre> MyString <ul> <li> <p>Information: </p> <ul> <li> <p>Wir bauen in Ans\u00e4tzen die Klasse <code>String</code> nach, d.h. wir bauen uns einen eigenen Datentypen f\u00fcr Zeichenketten: <code>MyString</code>.</p> </li> <li> <p>Ein Objekt von <code>MyString</code> ist intern ein <code>char[]</code> (wir nennen es <code>wort</code>).</p> </li> <li> <p>Von der Klasse <code>String</code> selbst verwenden wir nur zwei Methoden: <code>charAt(index)</code> und <code>length()</code>, und zwar in dem Konstruktor von <code>MyString</code>, dem ein <code>String</code> als Parameter \u00fcbergeben wird \u2192 das steht aber nochmal explizit dort</p> </li> <li> <p>Ansonsten verwenden wir von <code>String</code> keine weiteren Methoden (ist nicht erlaubt, w\u00e4re aber auch nirgendwo hilfreich)</p> </li> <li> <p>Wir erstellen insgesamt nur 2 Klassen: <code>MyString</code> und <code>Testklasse</code>.</p> </li> </ul> </li> <li> <p>Implementieren Sie eine Klasse <code>MyString</code>. </p> <ul> <li> <p>Objektvariable ist <code>wort</code> vom Typ <code>char[]</code> (unsere Zeichenkette - Array von Zeichen). Die Objektvariable ist nur in der Klasse sichtbar!</p> </li> <li> <p>Schreiben Sie f\u00fcr <code>MyString</code> einen parameterlosen Konstruktor. In diesem Konstruktor wird das <code>wort</code>-Array erzeugt mit der L\u00e4nge <code>0</code>.</p> </li> <li> <p>Schreiben Sie f\u00fcr <code>MyString</code> einen parametrisierten Konstruktor, dem ein einzelnes Zeichen (<code>char</code>) als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das <code>wort</code>-Array erzeugt mit der L\u00e4nge <code>1</code> und das einzelne Zeichen wird in das <code>wort</code>-Array gespeichert.</p> </li> <li> <p>Schreiben Sie f\u00fcr <code>MyString</code> einen parametrisierten Konstruktor, dem ein <code>String</code> als Parameter \u00fcbergeben wird. In diesem Konstruktor wird das <code>wort</code>-Array erzeugt mit der L\u00e4nge des Strings und jedes einzelne Zeichen des Strings wird in das <code>wort</code>-Array gespeichert. Hierzu nutzen Sie die Methoden <code>charAt(index)</code> und <code>length()</code> der Klasse <code>String</code>.</p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>toString()</code> so, dass alle Zeichen aus dem <code>wort</code>-Array als ein <code>String</code> zur\u00fcckgegeben werden, also z.B. </p> <p></p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>print()</code>. Diese Methode gibt den durch <code>toString()</code> erzeugten <code>String</code> auf der Konsole aus.</p> </li> <li> <p>Schreiben Sie die Objektmethode <code>getLength()</code>. Diese Methode gibt die L\u00e4nge des <code>wort</code>-Arrays zur\u00fcck. </p> </li> <li> <p>Schreiben Sie die Objektmethode <code>getCharAt(int index)</code>. Diese Methode gibt ein Leerzeichen zur\u00fcck, wenn der \u00fcbergebene <code>index</code> kein Index des <code>wort</code>-Arrays ist. Ansonsten wird das Zeichen zur\u00fcckgegeben, das im <code>wort</code>-Array unter dem Index <code>index</code> gespeichert ist.</p> </li> <li> <p>Schreiben Sie die Objektmethode <code>contains(char c)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn <code>c</code> im <code>wort</code>-Array vorkommt. Ansonsten <code>false</code>.</p> </li> <li> <p>\u00dcberschreiben Sie die Objektmethode <code>equals(Object o)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn das aufrufende Objekt die gleiche <code>wort</code>-L\u00e4nge hat wie <code>o</code> und auch alle Zeichen in den beiden <code>wort</code>-Arrays elementweise gleich sind (also Index f\u00fcr Index). Sonst <code>false</code>. </p> </li> </ul> </li> <li> <p>Schreiben Sie eine Klasse <code>Testklasse</code> mit <code>main()</code>-Methode. Erzeugen Sie in der <code>main()</code>-Methode </p> <ul> <li> <p>ein Objekt <code>s1</code> von <code>MyString</code> mithilfe des parameterlosen Konstruktors, </p> </li> <li> <p>ein Objekt <code>s2</code> von <code>MyString</code>, dem der einzelne Buchstabe <code>a</code> \u00fcbergeben wird, </p> </li> <li> <p>ein Objekt <code>s3</code> von <code>MyString</code>, dem die Zeichenkette <code>hallo</code> \u00fcbergeben wird, </p> </li> <li> <p>rufen Sie f\u00fcr alle drei Objekte die print()-Methode auf. Es entsteht folgende Ausgabe:     <pre><code>// das hier geh\u00f6rt nicht zur Ausgabe, soll nur zeigen, dass zun\u00e4chst eine Leerzeile kommt\n\na\nhallo\n</code></pre></p> </li> <li> <p>Wenden Sie die <code>getCharAt()</code>-Methode an und lassen sich f\u00fcr das dritte <code>MyString</code>-Objekt (<code>s3</code>) den Buchstaben auf der Konsole ausgeben, der am Index <code>1</code> gespeichert ist. Wenden Sie die <code>contains()</code>-Methode <code>2</code> Mal an und lassen sich f\u00fcr das dritte <code>MyString</code>-Objekt auf der Konsole ausgebenden, </p> <ul> <li> <p>ob der Buchstabe <code>a</code> in dessen <code>wort</code>-Array gespeichert ist und</p> </li> <li> <p>ob der Buchstabe <code>b</code> in dessen <code>wort</code>-Array gespeichert ist. </p> </li> </ul> <p>Es entsteht folgende Ausgabe: <pre><code>a\na in hallo ? true\nb in hallo ? false\n</code></pre></p> </li> <li> <p>Erzeugen Sie zwei weitere Objekte <code>s4</code> und <code>s5</code> von <code>MyString</code>, einmal mit der Zeichenkette <code>hallo</code> und einmal mit der Zeichenkette <code>halLo</code> und vergleichen Sie beide Objekte mithilfe der <code>equals()</code>-Methode mit dem dritten <code>MyString</code>-Objekt <code>s3</code>. Es entstehen folgende Ausgaben: <pre><code>s3 gleich s4 ? true\ns3 gleich s4 ? false\n</code></pre></p> </li> </ul> </li> <li> <p>weiter mit <code>MyString</code>:</p> <ul> <li> <p>Schreiben Sie eine Objektmethode <code>getAsciiCodeOfCharAt(int index)</code>. Diese Methode gibt den Ascii-Code des Zeichens zur\u00fcck, das im <code>wort</code>-Array unter dem Index <code>index</code> gespeichert ist. Ist index kein Index aus dem <code>wort</code>-Array, wird <code>-1</code> zur\u00fcckgegeben.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>append(char c)</code>. Diese Methode h\u00e4ngt das Zeichen <code>c</code> an das <code>wort</code>-Array, d.h. danach ist das <code>wort</code>-Array um 1 l\u00e4nger als vor Aufruf der Methode.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>append(MyString s)</code>. Diese Methode h\u00e4ngt alle Zeichen aus <code>s</code> (aus dessen <code>wort</code>-Array) an das <code>wort</code>-Array des aufrufenden Objektes. Tipp: Verwenden Sie dazu die <code>append(char c)</code>-Methode.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>concat(MyString s1, MyString s2)</code>. Diese Methode gibt ein (neues) <code>MyString</code>-Objekt zur\u00fcck, in dem das <code>wort</code>-Array alle Zeichen aus <code>s1</code> und <code>s2</code> enth\u00e4lt. (Diese <code>concat()</code>-Methode entspricht <code>s1+s2</code> f\u00fcr Strings): </p> <p></p> </li> <li> <p>Schreiben Sie die Objektmethode <code>firstIndexOf(char c)</code>. Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen <code>c</code> zum ersten Mal im <code>wort</code>-Array vorkommt. Kommt das Zeichen <code>c</code> nicht im <code>wort</code>-Array vor, wird <code>-1</code> zur\u00fcckgegeben.</p> </li> <li> <p>Schreiben Sie die Objektmethode <code>lastIndexOf(char c)</code>. Diese Methode gibt den Index zur\u00fcck, an dem das Zeichen <code>c</code> zum letzten Mal im <code>wort</code>-Array vorkommt. Kommt das Zeichen <code>c</code> nicht im <code>wort</code>-Array vor, wird <code>-1</code> zur\u00fcckgegeben.</p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>substring(int beginIndex)</code>. Diese Methode gibt ein (neues) <code>MyString</code>-Objekt zur\u00fcck. Das neue <code>MyString</code>-Objekt enth\u00e4lt im <code>wort</code>-Array alle Zeichen aus dem <code>wort</code>-Array des aufrufenden Objektes ab dem Index <code>beginIndex</code> (inklusive). Ist <code>beginIndex</code> kein korrekter Index aus dem <code>wort</code>-Array des aufrufenden Objektes, wird ein <code>MyString</code>-Objekt mit leerem <code>wort</code>-Array zur\u00fcckgegeben.</p> <p></p> </li> </ul> </li> <li> <p>weiter mit <code>Testklasse</code>:</p> <ul> <li> <p>Testen Sie die <code>getAsciiCodeOfCharAt()</code>-Methode, indem Sie sich den Ascii-Code des Zeichens von <code>s3</code> auf dem Index <code>1</code> ausgeben lassen:     <pre><code>Ascii-Code Zeichen aus s3 mit Index 1 = 97\n</code></pre></p> </li> <li> <p>Testen Sie die <code>append(char)</code>-Methode, indem Sie an <code>s3</code> das Zeichen <code>c</code> h\u00e4ngen:     <pre><code>halloc \n</code></pre></p> </li> <li> <p>Testen Sie die <code>append(MyString)</code>-Methode, indem Sie sich ein weiteres <code>MyString</code>-Objekt <code>s6</code> mit <code>ballo</code> erzeugen und dieses Objekt an <code>s3</code> h\u00e4ngen:     <pre><code>hallocballo\n</code></pre></p> </li> <li> <p>Testen Sie die <code>concat()</code>-Methode, indem Sie sich ein weiteres <code>MyString</code>-Objekt <code>s7</code> mit leerem <code>wort</code>-Array erzeugen und f\u00fcr dieses Objekt die <code>concat()</code>-Methode aufrufen, wobei Sie die Objekte <code>s4</code> und <code>s6</code> \u00fcbergeben:     <pre><code>halloballo\n</code></pre></p> </li> <li> <p>Testen Sie die <code>firstIndexOf()</code>- und die <code>lastIndexOf()</code>- Methode, indem Sie jeweils in <code>s3</code> nach dem Buchstaben <code>l</code> suchen (kleines L):     <pre><code>erstes l in s3 am Index 2\nletztes l in s3 am Index 9\n</code></pre></p> </li> <li> <p>Testen Sie die <code>substring()</code>-Methode, indem Sie den Teilstring ab Index <code>5</code> f\u00fcr <code>s3</code> ausgeben:     <pre><code>cballo\n</code></pre></p> </li> </ul> </li> <li> <p>weiter mit <code>MyString</code>:</p> <ul> <li> <p>Schreiben Sie eine Objektmethode <code>substring(int beginIndex, int endIndex)</code>. Diese Methode gibt ein (neues) <code>MyString</code>-Objekt zur\u00fcck. Das neue <code>MyString</code>-Objekt enth\u00e4lt im <code>wort</code>-Array alle Zeichen aus dem <code>wort</code>-Array des aufrufenden Objektes ab dem Index <code>beginIndex</code> (inklusive) bis zum Index <code>endIndex</code> (exklusive). Ist <code>beginIndex</code> kein korrekter Index aus dem <code>wort</code>-Array des aufrufenden Objektes oder ist <code>beginIndex</code> gr\u00f6\u00dfer gleich <code>endIndex</code>, wird ein <code>MyString</code>-Objekt mit leerem <code>wort</code>-Array zur\u00fcckgegeben.</p> <p></p> </li> <li> <p>Schreiben Sie eine Objektmethode <code>toUpperCase()</code>, die ein (neues) <code>MyString</code>-Objekt zur\u00fcckgibt. Alle Kleinbuchstaben aus dem aufrufenden Objekt sind im neuen Objekt Gro\u00dfbuchstaben. </p> <p></p> <p>Tipps:</p> <ul> <li> <p>Bei der Umwandlung m\u00fcssen Sie sich nur um die Kleinbuchstaben k\u00fcmmern, alle anderen Zeichen werden direkt \u00fcbernommen.</p> </li> <li> <p>Kleinbuchstaben haben die Ascii-Codes <code>97</code> (<code>a</code>) \u2013 <code>122</code> (<code>z</code>)</p> </li> <li> <p>Gro\u00dfbuchstaben haben die Ascii-Codes <code>65</code> (<code>A</code>) \u2013 <code>90</code> (<code>Z</code>)</p> </li> </ul> </li> <li> <p>Schreiben Sie eine Objektmethode <code>reverse()</code>, die ein (neues) <code>MyString</code>-Objekt zur\u00fcckgibt. In diesem neuen Objekt ist die Zeichenfolge im <code>wort</code>-Array genau umgekehrt wie im aufrufenden Objekt.</p> <p></p> </li> <li> <p>Schreiben Sie die Objektmethode <code>contains(MyString s)</code>. Diese Methode gibt ein <code>true</code> zur\u00fcck, wenn das <code>wort</code>-Array von <code>s</code> im <code>wort</code>-Array des aufrufenden Objektes vorkommt. Ansonsten <code>false</code>.</p> </li> </ul> </li> <li> <p>weiter mit <code>Testklasse</code>:</p> <ul> <li>Testen Sie Sie alle 4 Methoden <code>substring(int beginIndex, int endIndex)</code>, <code>toUpperCase()</code>, <code>reverse()</code> und <code>contains(MyString s)</code>:     <pre><code>-------------------- Teil 3 ----------------------------\n\ns3                : hallocballo\ns3 substring(3,7) : locb\ns3 toUpperCase()  : HALLOCBALLO\ns3 reverse()      : ollabcollah\ns4                : locba\ns4 in s3 ?        : true\n</code></pre></li> </ul> </li> </ul> eine m\u00f6gliche L\u00f6sung f\u00fcr MyString MyString.javaTestklasse.java <pre><code>package klausurvorbereitung.mystring;\n\npublic class MyString\n{\n    private char[] wort;\n\n    public MyString()\n    {\n        this.wort = new char[0];\n    }\n\n    public MyString(char letter)\n    {\n        this.wort = new char[1];\n        this.wort[0] = letter;\n    }\n\n    public MyString(String wort)\n    {\n        this.wort = new char[wort.length()];\n        for(int index=0; index&lt;this.wort.length; index++)\n        {\n            this.wort[index] = wort.charAt(index);\n        }\n    }\n\n    @Override \n    public String toString()\n    {\n        String s = \"\";\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            s += this.wort[index];\n        }\n        return s;\n    }\n\n    public void print()\n    {\n        System.out.println(this.toString());\n    }\n\n    public int getLength()\n    {\n        return this.wort.length;\n    }\n\n    public char getCharAt(int index)\n    {\n        if(index&lt;0 || index&gt;this.wort.length)\n        {\n            return ' ';\n        }\n        else\n        {\n            return this.wort[index];\n        }\n    }\n\n    public boolean contains(char c)\n    {\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            if(this.wort[index]==c) return true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if(o == null) return false;\n        if(this == o) return true;\n        if(this.getClass() != o.getClass()) return false;\n\n        MyString so = (MyString)o;\n        if(this.getLength() != so.getLength()) return false;\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            if(this.wort[index] != so.wort[index]) return false;\n        }\n        return true;\n    }\n\n    public int getAsciiCodeOfCharAt(int index)\n    {\n        if(index&lt;0 || index&gt;this.wort.length)\n        {\n            return -1;\n        }\n        else\n        {\n            return (int)this.wort[index];\n        }\n    }\n\n    public void append(char c)\n    {\n        char[] newWord = new char[this.getLength()+1];\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            newWord[index] = this.getCharAt(index);\n        }\n        newWord[this.getLength()] = c;\n        this.wort = newWord;\n    }\n\n    public void append(MyString s)\n    {\n        for (int index = 0; index &lt; s.getLength(); index++)\n        {\n            this.append(s.getCharAt(index));\n        }\n    }\n\n    public MyString concat(MyString s1, MyString s2)\n    {\n        MyString s = new MyString();\n        s.append(s1);\n        s.append(s2);\n        return s;\n    }\n\n    public int firstIndexOf(char c)\n    {\n        final int NOT_FOUND = -1;\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            if(this.wort[index] == c) return index;\n        }\n        return NOT_FOUND;\n    }\n\n    public int lastIndexOf(char c)\n    {\n        final int NOT_FOUND = -1;\n        for (int index = this.wort.length-1; index &gt;= 0; index--)\n        {\n            if(this.wort[index] == c) return index;\n        }\n        return NOT_FOUND;\n    }\n\n    public MyString substring(int beginIndex)\n    {\n        if(beginIndex &lt; 0 || beginIndex &gt;= this.getLength())\n        {\n            return new MyString();\n        }\n        else\n        {\n            MyString s = new MyString(this.getCharAt(beginIndex));\n            for(int index = beginIndex+1; index&lt;this.getLength(); index++)\n            {\n                s.append(this.getCharAt(index));\n            }\n            return s;\n        }\n    }\n\n    public MyString substring(int beginIndex, int endIndex)\n    {\n        if(beginIndex &lt; 0 || beginIndex &gt;= this.getLength())\n        {\n            return new MyString();\n        }\n        else\n        {\n            MyString s = new MyString(this.getCharAt(beginIndex));\n            for(int index = beginIndex+1; (index&lt;this.getLength() &amp;&amp; index&lt;endIndex); index++)\n            {\n                s.append(this.getCharAt(index));\n            }\n            return s;\n        }\n    }\n\n    public MyString toUpperCase()\n    {\n        final int FROM_LOWER_TO_UPPER = 32;\n        MyString s = new MyString();\n        for(int index = 0; index&lt;this.getLength(); index++)\n        {\n            char c = this.getCharAt(index);\n            int ascii = (int)c;\n            if(ascii&gt;=97 &amp;&amp; ascii&lt;=122)\n            {\n                ascii = ascii - FROM_LOWER_TO_UPPER;\n                c = (char)ascii;\n            }\n            s.append(c);\n        }\n        return s;\n    }\n\n    public MyString reverse()\n    {\n        MyString s = new MyString();\n        for (int index = this.wort.length-1; index &gt;= 0; index--)\n        {\n            s.append(this.getCharAt(index));\n        }\n        return s;\n    }\n\n    public boolean contains(MyString s)\n    {\n        if(this.getLength() &lt; s.getLength()) return false;\n        if(this.equals(s)) return true;\n        boolean noMatch = true;\n        for (int index = 0; index &lt; this.wort.length; index++)\n        {\n            if(this.wort[index]==s.getCharAt(0))\n            {\n                for(int i=1; i&lt;s.getLength() &amp;&amp; noMatch; i++)\n                {\n                    if(index+i &gt;= this.getLength() || this.wort[index+i] != s.wort[i])\n                    {\n                        noMatch = false;\n                    }\n                }\n                return true;\n            }\n            noMatch = true;\n        }\n        return false;\n    }\n}\n</code></pre> <pre><code>package klausurvorbereitung.mystring;\n\npublic class Testklasse\n{\n\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%n%n------------------ Teil 1 a) --------------------------%n%n\");\n        MyString s1 = new MyString();\n        s1.print();\n        MyString s2 = new MyString('a');\n        s2.print(); \n        MyString s3 = new MyString(\"hallo\");\n        s3.print();\n\n        System.out.printf(\"%n%n------------------ Teil 1 b) --------------------------%n%n\");\n        char c1 = s3.getCharAt(1);\n        System.out.println(c1);\n        System.out.println(\"a in hallo ? \" + s3.contains('a'));\n        System.out.println(\"b in hallo ? \" + s3.contains('b'));\n\n        System.out.printf(\"%n%n------------------ Teil 1 c) --------------------------%n%n\");\n        MyString s4 = new MyString(\"hallo\");\n        s4.print();\n        MyString s5 = new MyString(\"halLo\");\n        s5.print();\n\n        System.out.println(\"s3 gleich s4 ? \" + s3.equals(s4));\n        System.out.println(\"s3 gleich s4 ? \" + s3.equals(s5));\n\n\n        System.out.printf(\"%n%n-------------------- Teil 2 ----------------------------%n%n\");  \n        int i1 = s3.getAsciiCodeOfCharAt(1);\n        System.out.println(\"Ascii-Code Zeichen aus s3 mit Index 1 = \" + i1);\n        s3.append('c');\n        s3.print();\n        MyString s6 = new MyString(\"ballo\");\n        s3.append(s6);\n        s3.print();\n        MyString s7 = new MyString();\n        s7 = s7.concat(s4, s6);\n        s7.print();\n        int i2 = s3.firstIndexOf('l');\n        System.out.println(\"erstes l in s3 am Index \" + i2);\n        i2 = s3.lastIndexOf('l');\n        System.out.println(\"letztes l in s3 am Index \" + i2);\n        MyString s8 = s3.substring(5);\n        s8.print();\n\n        System.out.printf(\"%n%n-------------------- Teil 3 ----------------------------%n%n\");  \n        System.out.print(\"s3                : \");\n        s3.print();\n        MyString s9 = s3.substring(3,7);\n        System.out.print(\"s3 substring(3,7) :    \");\n        s9.print();\n        s9 = s3.toUpperCase();\n        System.out.print(\"s3 toUpperCase()  : \");\n        s9.print();\n        s9 = s3.reverse();\n        System.out.print(\"s3 reverse()      : \");\n        s9.print();\n        s4 = new MyString(\"locba\");\n        System.out.print(\"s4                : \");\n        s4.print();\n        System.out.println(\"s4 in s3 ?        : \" + s3.contains(s4));\n    }\n\n}\n</code></pre>"},{"location":"uebungen/#zusatzliche-ubungen","title":"Zus\u00e4tzliche \u00dcbungen","text":"Bin\u00e4re B\u00e4ume <p>Info: Wir erstellen uns einen Datentyp <code>BinaryTreeNode</code>, der einen Knoten in einem Bin\u00e4rbaum repr\u00e4sentiert. Hier wird die Verwendung von <code>null</code> und Rekursion ge\u00fcbt.</p> <ol> <li>Erstellen Sie eine Klasse <code>BinaryTreeNode</code>.</li> <li> <p>Objektvariablen (alle <code>private</code>) dieser Klasse sind</p> <ul> <li><code>value</code> vom Typ <code>int</code>,</li> <li><code>left</code> vom Typ <code>BinaryTreeNode</code> und</li> <li><code>right</code> vom Typ <code>BinaryTreeNode</code>.</li> </ul> </li> <li> <p>Erstellen Sie einen parametrisierten Konstruktor <code>public BinaryTreeNode(int value)</code>, in dem der linke und rechte Teilbaum jeweils auf <code>null</code> gesetzt und die Objektvariable <code>value</code> mit dem Parameterwert initialisiert werden. </p> </li> <li> <p>Implementieren Sie die Methoden <code>public boolean hasLeft()</code> und <code>public boolean hasRight()</code>, die ein <code>true</code> zur\u00fcckgeben, wenn der linke bzw. rechte Teilbaum ein Objekt ist und <code>false</code>, wenn <code>left</code> bzw. <code>right</code> den Wert <code>null</code> haben. </p> </li> <li> <p>Implementieren Sie eine Methode <code>public void insert(int value)</code>, die die folgende private Methode <code>private void insert(BinaryTreeNode root, int value)</code> aufruft.</p> </li> <li> <p>Implementieren Sie eine Methode <code>private void insert(BinaryTreeNode root, int value)</code>, die ein <code>BinaryTreeNode</code>-Objekt in den Bin\u00e4rbaum einf\u00fcgt. Beachten Sie:</p> <ul> <li>wenn <code>value</code> kleiner ist, als der <code>value</code>, von dem Knoten, den Sie gerade betrachten, dann f\u00fcgen Sie den Wert in den linken Teilbaum ein,</li> <li>wenn <code>value</code> gr\u00f6\u00dfer ist, als der <code>value</code>, von dem Knoten, den Sie gerade betrachten, dann f\u00fcgen Sie den Wert in den rechten Teilbaum ein,</li> <li>wenn im Baum bereits ein Knoten mit <code>value</code> existiert, dann wird kein Knoten hinzugef\u00fcgt. </li> </ul> <p>Tipp: Sie sollten die Methode am besten rekursiv implementieren.</p> </li> <li> <p>Implementieren Sie eine Methode <code>public void print()</code>, die die folgende private Methode <code>private void print(int indent)</code> aufruft.</p> </li> <li> <p>Implementieren Sie eine Methode <code>private void print(int indent)</code>. Diese Methode gibt den <code>value</code> des aufrufenden Knotens auf die Konsole aus und ruft dann sowohl die <code>print(indent)</code>-Methode des linken Teilbaums als auch die <code>print(indent)</code>-Methode des rechten Teilbaums auf, falls sie jeweils existieren. Der <code>indent</code>-Parameter ist dazu da, damit f\u00fcr jede Verzweigungstiefe der Wert weiter einger\u00fcckt auf der Konsole ausgegeben wird, also z.B. so:</p> <pre><code>10\nl--------5\n         l--------3\n                  r--------4\n         r--------8\n                  r--------9\nr--------15\n         l--------13\n                  l--------12\n                  r--------14\n         r--------18\n                  l--------17\n</code></pre> <p>Tipp: Sie sollten die Methode am besten rekursiv implementieren.</p> </li> <li> <p>Die <code>main()</code>-methode der <code>Programmklasse</code> k\u00f6nnte z.B. so aussehen:</p> <pre><code>BinaryTreeNode btn = new BinaryTreeNode(10);\nbtn.insert(5);\nbtn.insert(15); \nbtn.insert(8); \nbtn.insert(3); \nbtn.insert(18); \nbtn.insert(13);\nbtn.insert(14); \nbtn.insert(9); \nbtn.insert(4); \nbtn.insert(17); \nbtn.insert(12);\nbtn.print();\n</code></pre> </li> </ol> Eine m\u00f6gliche L\u00f6sung f\u00fcr Bin\u00e4re B\u00e4ume BinaryTreeNode.javaProgrammklasse.java <pre><code>public class BinaryTreeNode\n{\n    private int value;\n    private BinaryTreeNode left;\n    private BinaryTreeNode right;\n\n    BinaryTreeNode(int value)\n    {\n        this.value = value;\n        this.left = null;\n        this.right = null;  \n    }\n\n    public boolean hasLeft()\n    {\n        return this.left != null;\n    }\n\n    public boolean hasRight()\n    {\n        return this.right != null;\n    }   \n\n    public void insert(int value)\n    {\n        this.insert(this, value);\n    }\n\n    private void insert(BinaryTreeNode root, int value)\n    { \n        if(value &lt; root.value)\n        {\n            if(!root.hasLeft())\n            {\n                root.left = new BinaryTreeNode(value);\n            }\n            else\n            {\n                insert(root.left, value);\n            }\n        }\n        else if(value &gt; root.value)\n        {\n            if(!root.hasRight())\n            {\n                root.right = new BinaryTreeNode(value);\n            }\n            else\n            {\n                insert(root.right, value);\n            }\n        }\n    }\n\n    public void print()\n    {\n        print(1);\n    }\n\n    private void print(int indent)\n    {\n        System.out.println(this.value);\n        if(this.hasLeft())\n        {\n            for(int i = 0; i &lt; indent; i++)\n            {\n                if(i == indent-1) System.out.print(\"l--------\"); \n                else              System.out.print(\"         \"); \n            }\n            this.left.print(indent+1);\n        }\n\n        if(this.hasRight())\n        {\n            for(int i = 0; i &lt; indent; i++)\n            {\n                if(i == indent-1) System.out.print(\"r--------\"); \n                else              System.out.print(\"         \");  \n            } \n            this.right.print(indent+1);\n        }\n    }\n\n}\n</code></pre> <pre><code>public class Programmklasse\n{\n\n    public static void main(String[] args)\n    {\n        BinaryTreeNode btn = new BinaryTreeNode(10);\n        btn.insert(5);\n        btn.insert(15); \n        btn.insert(8); \n        btn.insert(3); \n        btn.insert(18); \n        btn.insert(13);\n        btn.insert(14); \n        btn.insert(9); \n        btn.insert(4); \n        btn.insert(17); \n        btn.insert(12);\n        btn.print();\n    }\n\n}\n</code></pre>"},{"location":"variablen/","title":"Variablen und Datentypen","text":"<p>Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert. Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren. </p> <p>Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp. </p> <p>Eine Variable besteht also aus drei Dingen:</p> <ul> <li>dem Wert der Variablen (genau einer)</li> <li>dem Datentyp der Variablen (besteimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann)</li> <li>dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen)</li> </ul> <p></p> <p>Das Erstellen einer Variablen (die Definition einer Variablen) besteht in der Programmierung aus zwei Schritten:</p> <ol> <li>der Variablendeklaration: in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist</li> <li>der Initialisierung: bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen</li> </ol> <p>Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann. </p>"},{"location":"variablen/#datentypen-in-java","title":"Datentypen in Java","text":"<p>In Java gibt es acht sogenannte primitive Datentypen. Wir bezeichnen diese primitiven Datentypen als Wertetypen. Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt.</p>  Datentyp   Bedeutung  <code>int</code>  eine Variable vom Datentyp <code>int</code> kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ <code>int</code> ist <code>-2^31</code> \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ <code>int</code> ist <code>2^31-1</code> gro\u00df. <code>int</code> ist der Standard-Typ f\u00fcr ganze Zahlen in Java. <code>int</code> steht f\u00fcr <code>integer</code>.               <code>byte</code>  \u00a0eine Variable vom Datentyp <code>byte</code> kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu <code>int</code> ist der Wertebereich aber viel kleiner. Die kleinste <code>byte</code>-Zahl ist <code>-2^7</code> klein und die gr\u00f6\u00dfte <code>byte</code>-Zahl ist <code>2^7-1</code> gro\u00df.  <code>short</code>  eine Variable vom Datentyp <code>short</code> kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu <code>int</code> ist der Wertebereich aber viel kleiner. Im Gegensatz zu <code>byte</code> ist er aber gr\u00f6\u00dfer. Die kleinste <code>short</code>-Zahl ist <code>-2^15</code> klein und die gr\u00f6\u00dfte <code>short</code>-Zahl ist <code>2^15-1</code> gro\u00df.  <code>long</code>  \u00a0eine Variable vom Datentyp <code>long</code> kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu <code>int</code> ist der Wertebereich aber viel gr\u00f6\u00dfer. <code>long</code> wird immer dann verwendet, wenn der Wertebereich von <code>int</code> nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste <code>long</code>-Zahl ist <code>-2^63</code> klein und die gr\u00f6\u00dfte <code>long</code>-Zahl ist <code>2^63-1</code> gro\u00df.  <code>char</code>  \u00a0Der Datenyp <code>char</code> steht f\u00fcr <code>character</code>. Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp <code>char</code> ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich <code>0</code> bis <code>65535</code> an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen <code>'a'</code>. Ein solches Zeichen steht immer in einfachen Hochkommata <code>''</code>.  <code>boolean</code>  \u00a0Der Datentyp <code>boolean</code> kennt nur genau zwei Werte <code>true</code> und <code>false</code>. Eine Variable vom Datentyp <code>boolean</code> kann also entweder genau <code>true</code> sein oder genau <code>false</code>, nichts anderes.  <code>double</code>   Der Datentyp <code>double</code> ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte <code>double</code>-Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine <code>double</code>-Zahl zu speichern.  <code>float</code> <code>float</code> ist neben <code>double</code> ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als <code>float</code> ist aber nicht so gro\u00df wie bei <code>double</code>, da <code>float</code> nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat."},{"location":"variablen/#deklaration-von-variablen","title":"Deklaration von Variablen","text":"<p>Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten:</p> <ol> <li>wir vergeben einen Namen f\u00fcr unsere Variable und</li> <li>wir weisen der Variablen einen Datentyp zu. </li> </ol> <p>Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration). Die allgemine Syntax der Variablendeklaration ist wie folgt:</p> <pre><code>datentyp variablenName;\n</code></pre> <p>Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. </p> <p>Beispiele:</p> <pre><code>int ganzeZahl;\nint number;\nlong bigNumber;\nbyte smallNumber;\ndouble nr1;\nfloat nr2;\nboolean condition;\nchar character;\n</code></pre> <p>F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen.</p>"},{"location":"variablen/#bezeichner","title":"Bezeichner","text":"<p>Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern. Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. </p> <p>Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen:</p> <ul> <li>Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen</li> <li>Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen</li> <li>Java-Buchstaben sind mehr als 'a'-'z' und 'A'-'Z'</li> <li>z.B. auch <code>\u20ac</code>, <code>\u00a3</code>, <code>\u00a5</code>, <code>$</code>, Umlaute <code>\u00e4</code>, <code>\u00f6</code>, <code>\u00fc</code>, <code>\u00df</code>sowie Buchstaben mit Apostrophen</li> <li>Aber: wir verwenden nur die normalen Buchstaben 'a'-'z' und 'A'-'Z'!!! Alles andere f\u00fchrt zu Problemen</li> <li>wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. <code>!</code>, <code>/</code>, <code>*</code>, <code>{</code>, <code>[</code>, <code>.</code>, <code>]</code>, <code>}</code></li> <li>In Java wird Gro\u00df- und Kleinschreibung unterschieden (case sensitive)!</li> </ul> <p>Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben)<sup>1</sup>. Dazu geh\u00f6ren:</p> <code>abstract</code> <code>assert</code> <code>boolean</code> <code>break</code> <code>byte</code> <code>case</code> <code>catch</code> <code>char</code> <code>class</code> <code>const</code> <code>continue</code> <code>default</code> <code>do</code> <code>double</code> <code>else</code> <code>enum</code> <code>extends</code> <code>final</code> <code>finally</code> <code>float</code> <code>for</code> <code>goto</code> <code>if</code> <code>implements</code> <code>import</code> <code>instanceof</code> <code>int</code> <code>interface</code> <code>long</code> <code>native</code> <code>new</code> <code>package</code> <code>private</code> <code>protected</code> <code>public</code> <code>return</code> <code>short</code> <code>static</code> <code>strictfp</code> <code>super</code> <code>switch</code> <code>synchronized</code> <code>this</code> <code>throw</code> <code>throws</code> <code>transient</code> <code>try</code> <code>void</code> <code>volatile</code> <code>while</code> \u00dcbung Bezeichner <p>Warum sind das keine g\u00fcltigen Bezeichner in Java?</p> <ul> <li><code>2und2macht4</code></li> <li><code>class</code></li> <li><code>Hose gewaschen</code></li> <li><code>Hurtig!</code></li> <li><code>null</code></li> </ul>"},{"location":"variablen/#konventionen","title":"Konventionen","text":"<p>Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben:</p> <ul> <li>wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. <code>sum</code>, <code>input</code>, <code>checkIfEmpty</code> usw.</li> <li>Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben)</li> <li>Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben</li> <li>verwenden die sogenannte camelCaseSchreibweise. Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.)</li> </ul>"},{"location":"variablen/#initialisierung-von-variablen","title":"Initialisierung von Variablen","text":"<p>Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Du weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt. </p>"},{"location":"variablen/#der-wertzuweisungsoperator","title":"Der Wertzuweisungsoperator <code>=</code>","text":"<p>Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein eifaches Gleichheitszeichen <code>=</code>. Die Syntax der Wertzuweisung ist wie folgt:</p> <pre><code>variablenName = wert;\n</code></pre> <p>Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Seikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht!</p> <p>Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten:</p> <pre><code>ganzeZahl = 5;          // int\nnumber = -1234;         // int\nbigNumber = 12345678;   // long\nnr1 = 6.54321;          // double\ncondition = true;       // boolean\ncharacter = 'a';        // char\n</code></pre> <p>Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. </p>"},{"location":"variablen/#deklaration-und-initialisierung-in-einem-schritt","title":"Deklaration und Initialisierung in einem Schritt","text":"<p>Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und INitialisierung) ist wie folgt:</p> <p><pre><code>datentyp variablenName = wert;\n</code></pre> Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele:</p> <pre><code>int ganzeZahl = 5;          \nint number = -1234;         \nlong bigNumber = 12345678;  \ndouble nr1 = 6.54321;           \nboolean condition = true;       \nchar character = 'a';       \n</code></pre> <p>Beachte</p> <p>Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen <code>ganzeZahl</code> einen neuen Wert zuweisen, dann schreiben Sie die Anweisung <code>ganzeZahl = 6;</code>. Sie d\u00fcrfen auf keinen Fall <code>int ganzeZahl = 6;</code> schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable <code>ganzeZahl</code> erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen.   </p>"},{"location":"variablen/#details-zu-primitiven-datentypen-wertetypen","title":"Details zu primitiven Datentypen (Wertetypen)","text":"<p>Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen:</p> Datentyp \u00a0Gr\u00f6\u00dfe \u00a0Wertebereich <code>boolean</code> \u00a01 Byte<sup>2</sup> <code>true</code> / <code>false</code> <code>char</code> \u00a016 bit <code>0</code> ... <code>65.535</code> (z.B. <code>'A'</code>) <code>byte</code> 8 bit <code>-128</code> ... <code>127</code> <code>short</code> \u00a016 bit <code>-32.768</code> ... <code>32.767</code> <code>int</code> \u00a032 bit <code>-2.147.483.648</code> ... <code>2.147.483.647</code> <code>long</code> \u00a064 bit <code>-2^63</code> ... <code>2^63-1</code> <code>float</code> \u00a032 bit <code>+/-1,4E-45</code> ... <code>+/-3,4E+38</code> <code>double</code> \u00a064 bit <code>+/-4,9E-324</code> ... <code>+/-1,7E+308</code> <p>Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an.</p>"},{"location":"variablen/#ganzzahlige-datentypen-int-long-short-byte","title":"Ganzzahlige Datentypen <code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>","text":"<p>Eine ganze Zahl in einem Java-Programm ist vom Typ <code>int</code>. Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement  dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps <code>byte</code> (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der <code>1</code> (<code>2^0</code>) auf der rechten Seite (\"kleinstes\" bit) bis hin zu <code>2^7</code> auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der <code>128</code>, sondern der <code>-128</code>. Dies hat drei Vorteile</p> <ul> <li>es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt</li> <li>die <code>0</code> kommt nicht 2x vor (<code>1000 0000</code> und <code>0000 0000</code> w\u00e4re jeweils <code>0</code>, wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist)</li> <li>sowohl die Addition als auch die Subtraktion geht einfacher</li> </ul> <p></p> <p>Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von <code>-128</code>, <code>127</code> und <code>0</code>.  In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen <code>85</code>, <code>-43</code> und <code>-85</code> als Zweierkomplement repr\u00e4sentiert werden. </p> <p>Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sidn die Repr\u00e4sentationen von <code>-4</code> und <code>3</code> als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. </p> <p></p> <p>Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp <code>byte</code> ist <code>127</code> die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine <code>1</code> hinzuaddiert wird. </p> <p></p> <p>Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von <code>int</code> nach <code>long</code>. </p> Datentyp gr\u00f6\u00dfter Wert kleinster Wert <code>byte</code> <code>127</code> <code>-128</code> <code>short</code> <code>32.767</code> <code>-32.768</code> <code>int</code> <code>2.147.483.647</code> <code>-2.147.483.648</code> <code>long</code> <code>9.223.372.036.854.775.807</code> <code>-9.223.372.036.854.775.808</code> \u00dcbung Zweierkomplement <ul> <li>Warum ist <code>1111 1111</code> als Zweierkomplement im Datentyp <code>byte</code> die Dezimalzahl <code>-1</code>?</li> <li>Wie ist die Repr\u00e4sentation der Zahlen <code>-99</code> und <code>99</code> als Zweierkomplement im Datentyp <code>byte</code>?</li> <li>Was ist das Ergebnis der Rechnung <code>2.147.483.647 + 1</code> im Datentyp <code>int</code> und warum?</li> </ul>"},{"location":"variablen/#initialisierung-von-long-variablen","title":"Initialisierung von <code>long</code>-Variablen.","text":"<p>Eine ganze Zahl als Literal, also als alleinstehender Wert ist vom Typ <code>int</code>. Wenn wir folgende kombinierte Deklaration und INitialisierung betrachten:</p> <pre><code>long bigNumber = 12345678;\n</code></pre> <p>dann stellen wir fest, dass die Variable <code>bigNumber</code> auf der linken Seite des Wertzuweisungsoperators vom Typ <code>long</code> ist, die Zahl <code>12345678</code> aber vom Typ <code>int</code>. Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix <code>L</code> erg\u00e4nzen kann<sup>3</sup> - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ <code>int</code>, sondern vom Typ <code>long</code> ist. </p> <p>Die \"richtige\" Initialisierung sieht so aus: </p> <pre><code>long bigNumber = 12345678L;\n</code></pre> <p>Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das <code>L</code> an die Zahl zu h\u00e4ngen, wenn wir eine <code>long</code>-Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber * Typkonvertierung*  Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initailisierung kein Problem ist </p> <pre><code>long bigNumber = 2147483647;\n</code></pre> <p>aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen:</p> <pre><code>long bigNumber = 2147483648;\n</code></pre> <p>Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem <code>L</code>, dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren:</p> <pre><code>long bigNumber = 2147483648L;\n</code></pre> <p>In unseren Programmen werden wir zu 99% den Datentyp <code>int</code> f\u00fcr ganzzahlige Werte verwenden und zu 1% <code>long</code>. Die anderen ganzzahligen Datentypen <code>byte</code> und <code>short</code> braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen. </p>"},{"location":"variablen/#char","title":"<code>char</code>","text":"<p>Der Datentyp <code>char</code> ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, <code>ESC</code>-Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert:</p> Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen 33 <code>!</code> 47 <code>/</code> 61 <code>=</code> 34 <code>\"\"</code> 48 <code>0</code> 62 <code>&gt;</code> 35 <code>#</code> 49 <code>1</code> 63 <code>?</code> 36 <code>$</code> 50 <code>2</code> 64 <code>@</code> 37 <code>%</code> 51 <code>3</code> 65 <code>A</code> 38 <code>&amp;</code> 52 <code>4</code> 66 <code>B</code> 39 <code>'</code> 53 <code>5</code> 67 <code>C</code> 40 <code>(</code> 54 <code>6</code> 68 <code>D</code> 41 <code>)</code> 55 <code>7</code> 69 <code>E</code> 42 <code>*</code> 56 <code>8</code> 70 <code>F</code> 43 <code>+</code> 57 <code>9</code> 71 <code>G</code> 44 <code>,</code> 58 <code>:</code> 72 <code>H</code> 45 <code>-</code> 59 <code>;</code> 73 <code>I</code> 46 <code>.</code> 60 <code>&lt;</code> 74 <code>J</code> Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen 75 <code>K</code> 89 <code>Y</code> 103 <code>g</code> 76 <code>L</code> 90 <code>Z</code> 104 <code>h</code> 77 <code>M</code> 91 <code>[</code> 105 <code>i</code> 78 <code>N</code> 92 <code>\\</code> 106 <code>j</code> 79 <code>O</code> 93 <code>]</code> 107 <code>k</code> 80 <code>P</code> 94 <code>^</code> 108 <code>l</code> 81 <code>Q</code> 95 <code>_</code> 109 <code>m</code> 82 <code>R</code> 96 \u00a0``` 110 <code>n</code> 83 <code>S</code> 97 <code>a</code> 111 <code>o</code> 84 <code>T</code> 98 <code>b</code> 112 <code>p</code> 85 <code>U</code> 99 <code>c</code> 113 <code>q</code> 86 <code>V</code> 100 <code>d</code> 114 <code>r</code> 87 <code>W</code> 101 <code>e</code> 115 <code>s</code> 88 <code>X</code> 102 <code>f</code> 116 <code>t</code> Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen Dezimalzahl \u00a0Zeichen 117 <code>u</code> 121 <code>y</code> 125 <code>}</code> 118 <code>v</code> 122 <code>z</code> 126 <code>~</code> 119 <code>w</code> 123 <code>{</code> 127 <code>DEL</code> 120 <code>x</code> 124 <code>|</code> <p>Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei <code>char</code> um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata <code>''</code> angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies:</p> char ganzzahliger Typ <pre><code>char c1 = 'a';\nSystem.out.println(c1);     // a\nchar c2 = 97;\nSystem.out.println(c2);     // a\nchar c3 ='`';\nc3++;\nSystem.out.println(c3);     // a\n</code></pre> <p>Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist <code>UTF-8</code>, welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp <code>char</code> ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier. Die linke Spalte in dieser Tabelle zeigt den Unicode. Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position <code>U+00A9</code> herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden:</p> char UTF-8 Zeichen <pre><code>char u1 = '\\u00a9';\nSystem.out.println(u1);     // copyright-Zeichen\nchar u2 = '\\u00b0';\nSystem.out.println(u2);     // Grad-Zeichen\nchar u3 = '\\u00bd';\nSystem.out.println(u3);     // 1/2-Zeichen\n</code></pre>"},{"location":"variablen/#gleitkomma-datentypen-double-float","title":"Gleitkomma-Datentypen <code>double</code>, <code>float</code>","text":"<p>Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. <code>5.0</code> oder <code>-1.2345</code>) in einem Java-Programm ist vom Typ <code>double</code>. Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen <code>double</code> und <code>float</code> l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. <code>0.123456789</code>) oder f\u00fcr die Vorkommastellen (z.B. <code>987654321.0</code>). Generell ist der Wertebereich (die Genauigkeit) bei <code>double</code> viel h\u00f6her, denn f\u00fcr eine Variable vom Typ <code>double</code> werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ <code>float</code> nur 32 bit gro\u00df ist. Bei <code>float</code> beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei <code>double</code> ca. 17 signifikante Stellen sind. </p> Beispiel float <pre><code>float floatNumber = 1.0f/3.0f;\nSystem.out.println(floatNumber);    // 0.33333334\n</code></pre> <p>Im obigen Beispiel wird mithilfe von <code>float</code> der Bruch <code>1/3</code> ausgerechnet. Zwei Sachen sind zu beachten</p> <ol> <li>Wie wir das schon beim Datentyp <code>long</code> gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier <code>f</code>, um zu sagen, dass eine Zahl vom Typ <code>float</code> sein soll. Ohne das <code>f</code> w\u00e4re sie vom Typ <code>double</code> und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das <code>f</code> am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ <code>float</code> sein soll - n\u00e4mlcih durch die Angabe von <code>f</code> (<code>F</code> ginge auch).</li> <li>Die Genauigkeit bei <code>float</code> ist nicht sehr hoch. <code>1/3</code> im <code>float</code>-Wertebereich ergibt <code>0.33333334</code>. Schauen wir uns das gleiche Beispiel mit <code>double</code> an:</li> </ol> Beispiel float <pre><code>double doubleNumber = 1.0/3.0;\nSystem.out.println(doubleNumber);   // 0.3333333333333333\n</code></pre> <p>Erstens hat der <code>double</code>-Wert deutlich mehr Nachkommastellen (16 statt 8 bei <code>float</code>) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard. </p> <p>Wir merken uns:</p> <ul> <li>wir sollten <code>float</code> eher nicht verwenden, wenn wir Wert auf Genauigkeit legen,</li> <li>wenn wir <code>float</code> verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein <code>f</code> anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ <code>double</code> handelt,</li> <li><code>double</code> ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ <code>double</code>. </li> </ul> Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert <code>float</code> <code>~3.4028234663852886E+038</code> <code>~1.4012984643248171E-045</code> <code>double</code> <code>~1.7976931348623157E+308</code> <code>~4.9406564584124654E-324</code>"},{"location":"variablen/#der-datentyp-string","title":"Der Datentyp <code>String</code>","text":"<p>Der Datentyp <code>String</code> ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern (<code>3</code>, <code>5</code>, <code>'a'</code>, <code>123.45</code>, <code>true</code>, ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. </p> <p>Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp <code>String</code> wie die primitiven Wertetypen auch. </p> <p>Ein <code>String</code>-Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. <code>\"Hallo FIW!\"</code>, <code>\"2und2gleich4 und $ % &amp; 0? | \\ !\"</code>, <code>\" \u00e4 \u00fc \u00f6 \u00df</code>.</p> <p>Die Deklaration und Initialisierung einer <code>String</code>-Variablen sieht also so aus: <pre><code>String s1 = \"Informatik\";\n</code></pre></p> <p>Auch f\u00fcr den Datentyp <code>String</code> gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation (String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java <code>+</code>. </p> <pre><code>String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\";\nSystem.out.println(s1);\n</code></pre> <p>Die folgenden drei Ausgaben sind alle gleich: <pre><code>String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\";\nSystem.out.println(s1);             // Informatik und Wirtschaft\n\nString s2 = \"Informatik\";\nString s3 = \" und\";\nString s4 = \" Wirtschaft\";\nSystem.out.println(s2 + s3 + s4);   // Informatik und Wirtschaft\n\nString s5 = \"Informatik\";\nString s6 = s5 + \" und\";\nString s7 = s6 + \" Wirtschaft\";\nSystem.out.println(s7);             //Informatik und Wirtschaft\n</code></pre></p>"},{"location":"variablen/#doppelte-bedeutung-des-operatorzeichens","title":"Doppelte Bedeutung des Operatorzeichens <code>+</code>","text":"<p>Das <code>+</code> wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine Typische Verendung der Konkatenation an:</p> typisches Beispiel f\u00fcr die Konkatenation <pre><code>int summand1 = 3;\nint summand2 = 4;\nint summe = summand1 + summand2;\nSystem.out.println(summand1 + \" + \" + summand2 + \" = \" + summe);    // 3 + 4 = 7\n</code></pre> <p>Die Ausgabe bei dem obigen Beispiel ist <code>3 + 4 = 7</code>. Schauen wir uns das Beispiel genauer an:</p> <ul> <li>In Zeile <code>3</code> wird das <code>+</code> eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten (<code>summand1</code> und <code>summand2</code> sind jeweils vom Typ <code>int</code>)</li> <li>In Zeile <code>4</code> kommt <code>+</code> mehrmals vor. Der Ausdruck in den runden Klammern von <code>println()</code> wird von links nach rechts aufgel\u00f6st:<ul> <li>Das Literal <code>\" + \"</code> ist ein String. Hier ist <code>+</code> gar kein Operator, sondern nur ein Zeichen.</li> <li>Das <code>+</code> in <code>summand1 + \" + \"</code> ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das <code>+</code> verbindet, vom Typ <code>String</code> ist. Intern wird der Wert von <code>summand1</code> ( die <code>3</code>) zu einem String und dieser wird mit <code>\" + \"</code> verbunden. Es entsteht ein String <code>\"3 + \"</code>.  </li> <li>Das bedeutet, dass das n\u00e4chste <code>+</code> in dem Ausdruck <code>\"3 + \" + summand2</code> enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ <code>String</code>. Intern wird der Wert von <code>summand2</code> ( die <code>4</code>) zu einem String und dieser wird mit <code>\"3 + \"</code> verbunden. Es entsteht ein String <code>\"3 + 4\"</code>. </li> <li>Das bedeutet, dass das n\u00e4chste <code>+</code> in dem Ausdruck <code>\"3 + 4\" + \" = \"</code> enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ <code>String</code>. Es entsteht der String <code>\"3 + 4 = \"</code>.   </li> <li>Das letzte <code>+</code> steht also in dem Ausdruck <code>\"3 + 4 = \" + summe</code>. Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ <code>String</code> ist. Intern wird der Wert von <code>summe</code> ( die <code>7</code>) zu einem String und dieser wird mit <code>\"3 + 4 = \"</code> verbunden. Es entsteht ein String <code>\"3 + 4 = 7\"</code>. Dieser String wird ausgegegeben. </li> </ul> </li> </ul> 1. \u00dcbung Doppelte Bedeutung von <code>+</code> <p>Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: <pre><code>int summand1 = 3;\nint summand2 = 4;\nSystem.out.println(summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2);  \n</code></pre> Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen?</p> <p>Success</p> <p>Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen. Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ <code>int</code> ist und eine Gleikommazahl vom Typ <code>double</code>. Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp <code>char</code> ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist <code>=</code>. Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertuweisungsoperator in der Mitte und rechts der Wert. </p>"},{"location":"variablen/#konstanten","title":"Konstanten","text":"<p>Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes <code>final</code> deklarieren:</p> <p><code>final datentyp KONSTANTE = Wert;</code></p> <p>Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort <code>final</code>. Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an:</p> <pre><code>final double PI = 3.14159265359;\n</code></pre> <p>Es wird eine Konstante <code>PI</code> deklariert und ihr der Wert <code>3.14159265359</code> zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df. Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich <code>_</code> zum Verbinden der beiden W\u00f6rter, z.B. </p> <pre><code>final int NOT_FOUND = -1;\nfinal int MIN_VALUE = -2147483648; \nfinal int MAX_VALUE = 2147483647;\nfinal char DEGREE_SYMBOL = '\\u00b0';\nfinal char DEGREE_CELSIUS = '\\u2103';\nfinal char DEGREE_FAHRENHEIT = '\\u2109';\n</code></pre> <p>Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. </p> <pre><code>double area = PI * 25.0;\nSystem.out.println(area);\nSystem.out.println(DEGREE_FAHRENHEIT);\nSystem.out.println(DEGREE_CELSIUS);\nString fahrenheit = DEGREE_SYMBOL+\"F\";\nSystem.out.println(fahrenheit);\n</code></pre> <p>ergibt folgende Ausgabe:</p> <pre><code>78.53981633975\n\u2109\n\u2103\n\u00b0F\n</code></pre> <p>Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler (<code>The final variable cannot be assigned</code>) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. </p> <p>Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer. </p>"},{"location":"variablen/#typkonvertierung-type-cast","title":"Typkonvertierung (type-cast)","text":"<p>Java ist statisch typisiert, d.h. dass jede Variable (und jedes Literal) einen Datentyp hat. Dieser wird bei der Deklaration der Variablen festegelgt und ist somit bereits zur Compile-Zeit bekannt. Der Datentyp einer Variablen kann auch nicht mehr ge\u00e4ndert werden<sup>4</sup>.</p> <p>Die Typisierung einer Variablen gibt den Wertebereich vor, aus dem die Variable Werte annehmen kann (<code>int</code>-Variablen aus dem <code>int</code>-Wertebereich, <code>boolean</code> aus dem Wertebereich <code>{true, false}</code>usw.). Trotzdem ist in Java auch erlaubt, dass Wertezuweisungen nicht nur aus identischen Datentypen m\u00f6glich sind, sondern auch aus kampatiblen Datentypen:</p> <pre><code>int a = 5;          // links ist int und rechts ist int --&gt; identische Datentypen\nlong b = 5;         // links ist long und rechts ist int --&gt; kompatible Datentypen\nint c = boolean;    // nicht erlaubt --&gt; Fehler!!! keine kompatiblen Datentypen (int vs. boolean)\nfloat d = 5.0f;     // links ist float und rechts ist float --&gt; identische Datentypen\ndouble e = d;       // links ist double und rechts ist float --&gt; kompatible Datentypen\n</code></pre> <p>In den Zeilen <code>2</code> und <code>5</code> werden die Datentypen bei der Zuweisung automatisch vom Compiler umgewandelt (in Zeile <code>2</code> automatisch von <code>int</code> nach <code>long</code> und in Zeile <code>5</code> automatisch von <code>float</code> nach <code>double</code>). Diese Umwandlung von Datentypen nennt sich Typkonvertierung (engl. type cast). Die beiden Beispiele aus Zeile <code>2</code> und Zeile <code>5</code> hei\u00dfen implizite  Typkonvertierung. </p>"},{"location":"variablen/#implizite-typkonvertierung","title":"Implizite Typkonvertierung","text":"<p>Jeder Wert (jedes Literal) in Java ist von einem bestimmten Typ, z.B. </p> <pre><code>4       // Datentyp int\n4.0     // Datentyp double\ntrue    // Datentyp boolean\n'a'     // Datentyp char\n\"FIW\"   // Datentyp String\n</code></pre> <p>Was passiert bei </p> <pre><code>double number = 4;\n</code></pre> <p>? Wir haben links eine Variable vom Typ <code>double</code> und rechts einen Wert vom Typ <code>int</code>. Die Antwort ist, dass der Compiler implizit den Wert <code>4</code> in den Wert <code>4.0</code> umwandelt und diesen Wert der Variablen <code>number</code> zuweist. Es findet also eine implizite Typkonvertierung statt. </p> <p>Typkonvertierung </p> <ul> <li>immer, wenn in einer Zuweisung verschiedene Typen im Spiel sind, erfolgt eine Typkonvertierung</li> <li>der Typ, der rechts vom Zuweisungsoperator steht, muss in den Typ konvertiert werden, der links vom Zuweisungsoperator steht</li> <li>hier: von <code>int</code> nach <code>double</code></li> </ul> <p>Wenn von Typen mit einem kleineren Wertebereich zu Typen mit einem gr\u00f6\u00dferen Wertebereich umgewandelt (konvertiert) werden sollen, kann dies automatisch (implizit) erfolgen \u2192 implizite Typkonvertierung</p> <pre><code>// Beispiel Umrechnung Fahrenheit in Celsius --&gt; ohne Typkonvertierung\nfinal char DEGREE_SYMBOL = '\\u00b0';\nint celsius = 0;\nfor(int fahrenheit = 0; fahrenheit &lt;= 100; fahrenheit+=20)\n{\n    celsius = 5 * (fahrenheit - 32) / 9;\n    System.out.printf(\"%3d %cF --&gt; %3d %cC %n\", fahrenheit, DEGREE_SYMBOL, celsius, DEGREE_SYMBOL);\n}\n</code></pre> <p>In dem Beispiel werden <code>fahrenheit</code>-Werte in <code>celsius</code>-Werte umgerechnet. Die Variablen <code>celsius</code> und <code>fahrenheit</code> und auch die Werte <code>5</code>, <code>32</code> und <code>9</code> sind vom Typ <code>int</code>. Die Berechnungen laufen ohne Typkonvertierung ab, alles bleibt im Wertebereich von <code>int</code>. Deshalb handelt es sich bei <code>(fahrenheit - 32) / 9</code> um eine ganzzahlige Division. Die Ausgabe ist wie folgt:</p> <pre><code>  0 \u00b0F --&gt; -17 \u00b0C \n 20 \u00b0F --&gt;  -6 \u00b0C \n 40 \u00b0F --&gt;   4 \u00b0C \n 60 \u00b0F --&gt;  15 \u00b0C \n 80 \u00b0F --&gt;  26 \u00b0C \n100 \u00b0F --&gt;  37 \u00b0C\n</code></pre> <p>Wir \u00e4ndern das Beispiel und deklarieren die beiden Variablen <code>fahrenheit</code> und <code>celsius</code> als <code>double</code>:</p> <pre><code>// Beispiel Umrechnung Fahrenheit in Celsius --&gt; mit Typkonvertierung\nfinal char DEGREE_SYMBOL = '\\u00b0';\ndouble celsius = 0;\nfor(double fahrenheit = 0; fahrenheit &lt;= 100; fahrenheit+=20)\n{\n    celsius = 5 * (fahrenheit - 32) / 9;\n    System.out.printf(\"%6.2f %cF --&gt; %7.3f %cC %n\", fahrenheit, DEGREE_SYMBOL, celsius, DEGREE_SYMBOL);\n}\n</code></pre> <p>Dadurch ergibt sich eine andere Ausgabe (die Platzhalter in <code>printf()</code> mussten auch angepasst werden):</p> <pre><code>  0,00 \u00b0F --&gt; -17,778 \u00b0C \n 20,00 \u00b0F --&gt;  -6,667 \u00b0C \n 40,00 \u00b0F --&gt;   4,444 \u00b0C \n 60,00 \u00b0F --&gt;  15,556 \u00b0C \n 80,00 \u00b0F --&gt;  26,667 \u00b0C \n100,00 \u00b0F --&gt;  37,778 \u00b0C\n</code></pre> <p>Was ist passiert? Dadurch, dass in der Wertezuweisung <code>celsius = 5 * (fahrenheit - 32) / 9;</code> auf der linken Seite ein <code>double</code> steht, wird der gesamte Ausdruck auf der rechten Seite in ein <code>double</code> konvertiert. Das w\u00fcrde aber erst nach Ausrechnen des Ausdrucks erfolgen, wenn nicht auch <code>fahrenheit</code> ein <code>double</code> w\u00e4re. Es passiert folgendes:</p> <ul> <li>zuerst wird der Ausdruck <code>(fahrenheit - 32)</code> aufgel\u00f6st, da er in Klammern steht. Hier ist die Operation <code>double - int</code>. Sobald einer der beiden Operanden ein <code>double</code> ist, wird der <code>double</code>-Operator <code>-</code> verwendet \u2192 dazu wird die <code>32</code> in eine <code>32.0</code> konvertiert \u2192 das Ergebnis ist ein <code>double</code></li> <li>dann wird von links nach rechts aufgel\u00f6st, also zun\u00e4chst <code>5 * double</code>. Auch hier ist die Operation also <code>int * double</code>, d.h. <code>double</code>-Multiplikation und somit wird aus der <code>5</code> eine <code>5.0</code>. Das Ergebnis dieser Multiplikation ist <code>double</code></li> <li>dann erfolgt die Berechnung von <code>double / 9</code>. Wenn einer der beiden Operanden ein <code>double</code> ist, handelt es sich bei der Division um eine Gleikommadivision. Also gibt es auch Nachkommastellen \u2192 das Ergebnis ist ein <code>double</code></li> </ul> <p>Diese implizite Typkonvertierung macht der Compiler automatisch. Implizite Typkonvertierung kann immer dann erfolgen, wenn von einem schmalen in einen breiten Datentyp konvertiert wird, d.h. wenn alle Werte aus dem \"schmalen\" Wertebereich auch Werte aus dem \"breiten\" Wertebereich sind. Dies ist bei <code>int</code> (schmal) nach <code>double</code> (breit) der Fall, da alle <code>int</code>-Werte auch im <code>double</code>-Wertebereich enthalten sind. </p> <p>Das hier ist also kein Problem:</p> <pre><code>int v1 = 1;\ndouble v2 = v1;                 // ok\nSystem.out.println(\"Wert von v2: \" + v2);       // 1.0\n</code></pre> <p>aber das geht nicht:</p> <pre><code>double v3 = 1.0;\nint v4 = v3;                    // Fehler!\nSystem.out.println(\"Wert von v4: \" + v4);\n</code></pre> <p>Obwohl ja die <code>1.0</code> ein Wert aus <code>int</code> darstellt, pr\u00fcft der Compiler nicht den Wert, sondern den Typ. Da der <code>double</code>-Wertebereich viele Werte umfasst, die nicht Teil des Wertebereichs von <code>int</code> sind (z.B. <code>1.5</code>), kann hier keine implizite Typkonvertierung erfolgen, denn diese w\u00e4re von einem \"breiten\" in einen \"schmalen\" Datentypen. Wenn man sich jedoch ganz sicher ist, dass eine solche Typkonvertierung sinnvoll ist (z.B. kann man ja <code>1.0</code> nach <code>1</code> und somit <code>int</code> ohne Verlust umwandeln), kann eine solche Typkonvertierung explizit angesto\u00dfen werden.</p>"},{"location":"variablen/#explizite-typkonvertierung","title":"Explizite Typkonvertierung","text":"<p>In dem Beispiel von eben</p> <pre><code>double v3 = 1.0;\nint v4 = v3;                    // Fehler!\nSystem.out.println(\"Wert von v4: \" + v4);\n</code></pre> <p>f\u00fchrt der Compiler keine implizite Typkonvertierung durch. Das Programm wird gar nicht compiliert. Wenn wir nun aber wollen, dass diese Typkonvertierung trotzdem durchgef\u00fchrt wird, m\u00fcssen wir den Typkonvertierungsoperator (auch type cast operator) verwenden. Der Typkonvertierungsoperator enth\u00e4lt in runden Klammern den Zieltyp und steht vor dem Wert der umgewandelt werden soll:</p> <p><code>typ_A variable = (typ_A)wert;</code></p> <p>Die <code>variable</code> sei vom <code>typ_A</code> und der Wert von einem Typ, der nicht impliziert nach <code>typ_A</code> konvertiert werden kann. Unter Angabe von <code>(typ_A)</code> direkt vor dem <code>wert</code> wird der Wert explizit in <code>typ_A</code> konvertiert. </p> <p>Obiges Beispiel w\u00fcrde dann so aussehen:</p> <pre><code>double v3 = 1.0;\nint v4 = (int)v3;                   // ok\nSystem.out.println(\"Wert von v4: \" + v4);       // 1\n</code></pre> <p>Da wir wissen, dass die <code>1</code> (der von uns zugewiesene Wert von <code>v3</code>) im Wertebereich von <code>int</code> liegt, k\u00f6nnen wir den Compiler anweisen, von <code>double</code> nach <code>int</code> zu konvertieren \u2192 explizite Typkonvertierung. </p> <p>Aber Achtung! Explizite Typkonvertierung kann zu Informationsverlust f\u00fchren!</p> <pre><code>double v3 = 1.23456;\nint v4 = (int)v3;               // explizite TK\nSystem.out.println(\"Wert von v4: \" + v4);   // 1\n</code></pre> <p>Wird ein <code>double</code> in ein <code>int</code> konvertiert, werden die Nachkommastellen einfach abgeschnitten (kein Runden!).</p> <p>Aber Achtung! Explizite Typkonvertierung kann zu ganz anderen Werten f\u00fchren!</p> <pre><code>long v5 = 2147483648L;                      // L mit angeben!\nint v6 = (int)v5;                           // 2 hoch 31\nSystem.out.println(\"Wert von v6: \" + v6);   // -2147483648\n</code></pre> <p><code>2147483648</code> ist zwar ganzzahlig, ist aber nicht mehr Teil des Wertebereiches von <code>int</code> (um <code>1</code>zu gro\u00df) \u2192 aufgrund der internen Zahlendarstellung (Zweierkomplement), bekommt <code>v6</code> den Wert <code>-2147483648</code>.</p> <p>Bei expliziter Typkonvertierung muss selbst\u00e4ndig darauf geachtet werden, dass der Wertebereich nicht \u00fcberschritten bzw. nicht verlassen wird!</p>"},{"location":"variablen/#sinnvolle-anwendungen-des-typkonvertierungsoperators","title":"Sinnvolle Anwendungen des Typkonvertierungsoperators","text":"<p>Angenommen, wir haben ein <code>int</code>-Array <code>ia</code> und wollen aus den Werten in diesem Array den Mittelwert berechnen. Dann w\u00e4re folgender erster Implementierungsversuch denkbar:</p> <pre><code>int[] ia = { 1, 2, 3, 4 };\nint sum = 0;\nfor (int index = 0; index &lt; ia.length; index++)\n{\n    sum = sum + ia[index];\n}\ndouble average = sum / ia.length;\nSystem.out.println(\"Durchschnitt ist \" + average);      // 2.0\n</code></pre> <p>Wir bilden also die Summe \u00fcber alle Werte und teilen durch die Anzahl der Werte. Das entspricht der Definition des Durchschnitts. Wir \u00fcberschlagen im Kopf, dass f\u00fcr die vier Werte <code>1</code>, <code>2</code>, <code>3</code> und <code>4</code> der Durchschnitt <code>2.5</code> ist. Ausgegeben wird aber </p> <pre><code>Durchschnitt ist 2.0\n</code></pre> <p>Das ist falsch und der Grund daf\u00fcr liegt darin, dass es sich bei <code>sum / ia.length</code> um die ganzzahlige Divsion handelt, da beide Operanden vom Typ <code>int</code> sind. Eine M\u00f6glichkeit w\u00e4re, die Variable <code>sum</code> als <code>double</code> zu deklarieren. Dann haben wir bereits das gew\u00fcnschte Ergebnis. Eine andere ist, einen der beiden (oder beide) explizit nach <code>double</code> zu konvertieren:</p> <pre><code>int[] ia = { 1, 2, 3, 4 };\nint sum = 0;\nfor (int index = 0; index &lt; ia.length; index++)\n{\n    sum = sum + ia[index];\n}\ndouble average = sum / (double)ia.length;\nSystem.out.println(\"Durchschnitt ist \" + average);      // 2.5\n</code></pre> <p>Wir haben jetzt die L\u00e4nge explizit nach <code>double</code> konvertiert und somit ist einer der beiden Operanden der Division ein <code>double</code> und somit wird die Gleitkommadivision durchgef\u00fchrt. Nun erhalten wir das richtige Ergebnis: Kopf, dass f\u00fcr die vier Werte <code>1</code>, <code>2</code>, <code>3</code> und <code>4</code> der Durchschnitt <code>2.5</code> ist. Ausgegeben wird aber </p> <pre><code>Durchschnitt ist 2.5\n</code></pre> <p>Ein anderes sinnvolles Beispiel ist die explizite Konvertierung eines <code>int</code>-Wertes nach <code>char</code>. Beides sind ganzzahlige Datentypen, aber der Wertebereich von <code>char</code> (8 Bit) umfasst viel weniger Werte als der Wertebereich von <code>int</code> (16 Bit). <code>int</code> ist der \"breite\" Datentyp und <code>char</code> der schmale und somit findet keine implizite Typkonvertierung von <code>int</code> nach <code>char</code> statt. Trotzdem m\u00f6chte man h\u00e4ufig <code>int</code> in Bezug auf <code>char</code> nutzen, weil man unter Verwendung der numerischen ASCII-Codes (<code>int</code>) gut mit Zeichen \"rechnen\" kann:</p> <pre><code>for(int ascii = 65; ascii &lt; 91; ascii++)\n{\n    char c = (char)ascii;\n    System.out.print(c+\" \");\n}\n</code></pre> <p>Wir m\u00fcssen hier explizit konvertieren, da die implizite Typkonvertierung <code>char c = ascii;</code> nicht existiert. Das w\u00e4re also ein Fehler. Mit der expliziten Typkonvertierung klappt aber alles wie gew\u00fcnscht:</p> <pre><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \n</code></pre> <p>Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine implizite Typkonvertierung durchgef\u00fchrt wird:</p> <p></p> <p>Beachten Sie, dass von und nach <code>boolean</code> in Java keine implizite Typkonvertierung durchgef\u00fchrt wird!</p> <p>Hier nochmal zur Veranschaulichung, zwischen welchen Datentypen eine explizite Typkonvertierung durchgef\u00fchrt werden kann (kompatible Datentypen):</p> <p></p> <p>Beachten Sie, dass von und nach <code>boolean</code> in Java auch keine explizite Typkonvertierung m\u00f6glich ist!</p> <ol> <li> <p><code>const</code> und <code>goto</code> geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter.\u00a0\u21a9</p> </li> <li> <p>Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines <code>boolean</code> gar nicht genau definiert (siehe hier). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ <code>boolean</code> ein ganzes Byte reserviert wird.\u00a0\u21a9</p> </li> <li> <p>Man k\u00f6nnte auch nit dem kleinen Buchstaben <code>l</code> erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der <code>1</code> zu gro\u00df ist.\u00a0\u21a9</p> </li> <li> <p>Das ist nicht in Allen Programmiersprachen so. Beispielsweise wird in JavaScript erst zur Laufzeit ermittelt, von welchem Typ die Variable ist, denn das h\u00e4ngt von ihrem Wert ab. Dort kann eine Variable <code>foo=\"String\"</code> vom Typ <code>string</code> sein und dann durch <code>foo=4</code> vom Typ <code>number</code>. Die Typisierung in solchen Programmiersprachen nennt man dynamisch typisiert.\u00a0\u21a9</p> </li> </ol>"},{"location":"vererbung/","title":"Vererbung","text":"<p>Vererbung (engl. Inheritance) geh\u00f6rt zu den grundlegenden Konzepten der objektorientierten Programmierung. Dieses Konzept basiert auf Beobachtungen aus der realen Welt:</p> <ul> <li>Dinge (Objekte) kommen in verschiedenen Varianten vor, die sich hierarchisch klassifizieren lassen</li> <li>Dinge (Objekte), die hierarchisch tiefer stehen, sind speziellere Varianten der \u00fcbergeordneten, generelleren Dinge</li> <li>Speziellere Dinge besitzen die Eigenschaften der generelleren Dinge plus weitere, spezifischere Eigenschaften</li> </ul> <p>H\u00e4ufig werden f\u00fcr solche Beispiele aus der Realen Welt die Klassifikationen von Tieren oder Pflanzen verwendet, z.B. <code>S\u00e4ugetiere</code> sind eine Spezialisierung der <code>Tiere</code>, <code>Katzen</code> und <code>Hunde</code> wiederum sind Spezialisierungen von <code>S\u00e4ugetieren</code> usw. Eine solche Hierarchie, wie z.B. in der folgenden Abbildung gezeigt, kommt jedenfalls in der realen Welt sehr h\u00e4ufig vor.</p> <p></p> <p><code>Tiere</code> sind dabei die allgemeinste Klasse. Sie haben Eigenschaften, die f\u00fcr alle Tiere zutreffen, z.B. dass sie sich bewegen k\u00f6nnen und fortpflanzen. <code>Wirbeltiere</code> haben alle Eigenschaften der <code>Tiere</code>, aber zus\u00e4tzlich noch speziellerere Eigenschaften, wie z.B. dass sie ein Skellett besitzen. <code>S\u00e4ugetiere</code> besitzen alle Eigenschaften von <code>Wirbeltieren</code> (und also auch von <code>Tieren</code>) und dar\u00fcber hinaus speziellere Eigenschaften, n\u00e4mlich z.B. lebend geb\u00e4rend usw. </p> <p>F\u00fcr die Programmierung bedeutet das, dass Klassen von anderen Klassen die Eigenschaften erben k\u00f6nnen, d.h.</p> <ul> <li>Kindklassen \u00fcbernehmen (erben) Eigenschaften (Objektvariablen und Objektmethoden) der Elternklasse</li> <li>Kindklassen k\u00f6nnen zus\u00e4tzlich weitere Eigenschaften (Objektvariablen und Objektmethoden) enthalten</li> </ul> <p>Wichtig f\u00fcr das Verst\u00e4ndnis der Vererbung ist, dass zwischen den Kind- und der Elternklasse eine is-a- (ist-ein-) Relation besteht. F\u00fcr unser Beispiel oben bedeutet das z.B. der <code>Hund</code> ist ein <code>S\u00e4ugetier</code>, das <code>S\u00e4ugetier</code> ist ein <code>Wirbeltier</code> usw. Wenn wir uns also eine Vererbungshierarchie aufmalen, dann gehen die Pfleile immer von der Kind- zur Elternklasse:</p> <p></p> <p>F\u00fcr die Vererbung gilt also:</p> <ul> <li>Die Vererbung ist eine sehr bedeutende M\u00f6glichkeit der Wiederverwendbarkeit von Klassen</li> <li>Vererbung basiert auf der Idee, dass Elternklassen ihren Kindern Variablen und Methoden vererben</li> <li>Durch Vererbung entsteht eine Klassenhierarchie:</li> </ul> <p></p>"},{"location":"vererbung/#vererbung-in-java","title":"Vererbung in Java","text":"<p>Angenommen, wir haben eine Klasse <code>Elternklasse</code> und eine <code>Kindklasse</code> soll von dieser Klasse erben. Wir verwenden das Schl\u00fcsselwort <code>extends</code>, um die <code>Kindklasse</code> von der <code>Elternklasse</code> erben zu lassen:</p> <p><code>public class Kindklasse extends Elternklasse</code> <code>{</code> <code>}</code></p> <p>In Java kann eine Klasse nur von genau einer Klasse erben. Mehrfachvererbung (das Erben von mehreren Klassen) ist nicht m\u00f6glich. </p>"},{"location":"vererbung/#ein-erstes-beispiel","title":"Ein erstes Beispiel","text":"<p>Wir betrachten ein erstes Beispiel. Wir werden eine Klasse <code>Viereck</code> erstellen. Von dieser Klasse wird eine Klasse <code>Rechteck</code> abgeleitet, d.h. <code>Rechteck</code> erbt von <code>Viereck</code>. Danach erzeugen wir noch eine weitere Klasse <code>Quadrat</code>, die wiederum von <code>Rechteck</code> erbt. </p>"},{"location":"vererbung/#die-klasse-viereck","title":"Die Klasse <code>Viereck</code>","text":"<p>Als Objektvariablen der Klasse <code>Viereck</code> w\u00e4hlen wir die vier Seitenl\u00e4ngen eines Vierecks <code>a</code>, <code>b</code>, <code>c</code> und <code>d</code>. Au\u00dferdem definieren wir uns noch einen Konstruktor und zwei Objektmethoden, die Methode <code>umfang()</code>, die den Umfang des Rechtecks zur\u00fcckgibt und die Methode <code>print()</code>, die die vier Seitenl\u00e4ngen auf die Konsole ausgibt und den Umfang:</p> <pre><code>public class Viereck\n{\n    private int a,b,c,d;            // Seiten\n\n    public Viereck(int a, int b, int c, int d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public int umfang()\n    {\n        return this.a + this.b + this.c + this.d;\n    }\n\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.println(\" Umfang des Vierecks : \" + this.umfang());\n    }\n\n}\n</code></pre> <p>In einer <code>TestViereck</code>-Klasse erzeugen wir Objekte von <code>Viereck</code> und testen die Methoden:</p> <pre><code>public class TestViereck\n{\n\n    public void main()\n    {\n        Viereck v1 = new Viereck(10,20,30,40);\n        v1.print();\n\n        Viereck v2 = new Viereck(15,20,25,20);\n        v2.print();\n    }\n\n}\n</code></pre> <p>Auf der Konsole erscheint folgende Ausgabe:</p> <pre><code>[ a=10, b=20, c=30, d=40 ]  Umfang des Vierecks : 100\n[ a=15, b=20, c=25, d=20 ]  Umfang des Vierecks : 80\n</code></pre> <p>Soweit nichts Neues. Jetzt wollen wir aber von dieser Klasse erben und erzeugen eine Klasse <code>Rechteck</code>. Ein Rechteck ist ein Viereck.</p>"},{"location":"vererbung/#die-klasse-rechteck","title":"Die Klasse <code>Rechteck</code>","text":"<p>Die Klasse <code>Rechteck</code> erbt von <code>Viereck</code>, d.h. wir verwenden das Schl\u00fcsselwort <code>extends</code>. Wir erzeugen uns im gleichen package, in dem auch <code>Viereck</code> und <code>TestViereck</code> liegen, eine Klasse <code>Rechteck</code>:</p> <pre><code>public class Rechteck extends Viereck\n{\n\n}\n</code></pre> <p>Hinter den Klassennamen <code>Rechteck</code> schreiben wir nun <code>extends</code> und den Namen der Klasse, von der geerbt werden soll, hier <code>Viereck</code>. </p> <p>Das ist soweit gut, jedoch wird leider ein Fehler angezeigt:</p> <pre><code>Implicit super constructor Viereck() is undefined for default constructor. Must define an explicit constructor\n</code></pre>"},{"location":"vererbung/#der-konstruktor-von-rechteck-das-schlusselwort-super","title":"Der Konstruktor von <code>Rechteck</code> - das Schl\u00fcsselwort <code>super</code>","text":"<p>Wir erinnern uns:</p> <ol> <li>Wenn wir eine neue Klasse erstellen und keinen Konstruktor definieren, dann existiert immer ein sogenannter impliziter Konstruktor (oder Standardkonstruktor). Dieser hei\u00dft exakt wie die Klasse und ist parameterlos. </li> <li>Wenn wir uns einen eigenen Konstruktor definieren, dann existiert dieser implizite Konstruktor (Standardkonstruktor) nicht mehr. </li> </ol> <p>In der Klasse <code>Viereck</code> haben wir uns einen eigenen Konstruktor erstellt (<code>Viereck(int a, int b, int c, int d)</code>), d.h. es gibt keinen impliziten Konstruktor <code>Viereck()</code> (mehr). In Java gilt nun aber folgendes:</p> <p>Wird in Java ein Objekt einer Kindklasse erzeugt, wird auch immer ein Objekt der Elternklasse erzeugt. </p> <p>Wir m\u00fcssen nun daf\u00fcr sorgen, dass beim Erzeugen eines Objektes von <code>Rechteck</code> auch ein Objekt von <code>Viereck</code> erzeugt werden kann. Dies machen wir wie folgt:</p> <pre><code>public class Rechteck extends Viereck\n{\n    public Rechteck(int laenge, int breite)\n    {\n        super(laenge, breite, laenge, breite);  // Aufruf des Konstruktors von Viereck\n    }\n}\n</code></pre> <p>Erl\u00e4uterung:</p> <ul> <li>in den Zeilen <code>3-6</code> wird der Konstruktor von <code>Rechteck</code> definiert. bei einem Rechteck sind die gegen\u00fcberliegenden Seiten gleich lang, deshalb ben\u00f6tigen wir f\u00fcr die Seitenl\u00e4ngen auch nur noch zwei Werte, n\u00e4mlich <code>laenge</code> und <code>breite</code>. </li> <li>in Zeile <code>5</code> wird der Konstruktor von <code>Viereck</code> aufgerufen! Das passiert in der Kindklasse nicht durch <code>Viereck(int, int, int, int)</code>, sondern durch die Verwendung des Schl\u00fcsselwortes <code>super</code>. Hier wird also explizit der Konstruktor der Elternklasse aufgerufen! Wenn wir uns den Konstruktor von <code>Viereck</code> nochmal anschauen, dann sehen wir, dass nun der Wert von <code>laenge</code> der Seite <code>a</code> zugeordnet wird, der Wert von <code>breite</code> der Seite <code>b</code>, der Wert von <code>laenge</code> der Seite <code>c</code> und der Wert von <code>breite</code> der Seite <code>d</code>.</li> </ul> <p>Wenn wir in einer Kindklasse  einen Konstruktor definieren, sollten wir immer explizit den Konstruktor der Elternklasse aufrufen (mithilfe von <code>super()</code>). Dieser Aufruf muss die erste Anweisung innerhalb des Konstruktors sein!</p> <p>Der Umgang mit den Konstruktoren ist schon das Komplizierteste in Bezug auf Vererbung. Wir kommen sp\u00e4ter nochmal darauf zur\u00fcck. </p>"},{"location":"vererbung/#rechteck-hat-alle-eigenschaften-von-viereck-geerbt","title":"<code>Rechteck</code> hat alle Eigenschaften von <code>Viereck</code> geerbt","text":"<p>Unsere Klasse <code>Rechteck</code> ist nun anwendbar. Die Klasse <code>rechteck</code> hat alle Eigenschaften der Klasse <code>Viereck</code> geerbt, d.h.</p> <ul> <li>die Objektvariablen <code>a</code>, <code>b</code>, <code>c</code> und <code>d</code> sowie</li> <li>die Objektmethoden <code>umfang()</code> und <code>print()</code>.</li> </ul> <p>Das testen wir gleich in der <code>TestViereck</code>-Klasse und erzeugen uns Objekte von <code>Rechteck</code>:</p> <pre><code>public class TestViereck\n{\n\n    public void main()\n    {\n        System.out.printf(\"%n%n------- Objekte von Viereck erzeugen ------------%n%n\");\n\n        Viereck v1 = new Viereck(10,20,30,40);\n        v1.print();\n\n        Viereck v2 = new Viereck(15,20,25,20);\n        v2.print();\n\n        System.out.printf(\"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\");\n        Rechteck r1 = new Rechteck(10, 20);\n        r1.print();\n\n        Rechteck r2 = new Rechteck(20, 30);\n        r2.print();\n    }\n\n}\n</code></pre> <p>Auf der Konsole erscheinen folgende Ausgaben:</p> <pre><code>------- Objekte von Viereck erzeugen ------------\n\n[ a=10, b=20, c=30, d=40 ]  Umfang des Vierecks : 100\n[ a=15, b=20, c=25, d=20 ]  Umfang des Vierecks : 80\n\n\n------- Objekte von Rechteck erzeugen ------------\n\n[ a=10, b=20, c=10, d=20 ]  Umfang des Vierecks : 60\n[ a=20, b=30, c=20, d=30 ]  Umfang des Vierecks : 100\n</code></pre> <p>Wir erzeugen uns also zwei Objekte von <code>Rechteck</code> und rufen f\u00fcr beide Objekte die Objektmethode <code>print()</code> auf. Diese Methode hat <code>Rechteck</code> von <code>Viereck</code> geerbt. Diese Methode gibt nun korrekt die jeweiligen Seitenl\u00e4ngen aus (<code>laenge</code> wird <code>a</code> und <code>c</code> zugewiesen und <code>breite</code> den Seiten <code>b</code> und <code>d</code> - siehe Aufruf des Konstruktors von <code>Viereck</code> im Konstruktor von <code>Rechteck</code>: <code>super(laenge, breite, laenge, breite)</code>).</p> <p>In der Methode <code>print()</code> wird die Methode <code>umfang()</code> aufgerufen, die ebenfalls geerbt wurde. Wir k\u00f6nnten diese Methode zum Testen auch direkt in der Testklasse f\u00fcr die <code>Rechteck</code>-Objekte aufrufen, z.B. </p> <pre><code>System.out.printf(\"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\");\nRechteck r1 = new Rechteck(10, 20);\nr1.print();\nSystem.out.println(\"Umfang des Rechtecks : \" + r1.umfang());\n\nRechteck r2 = new Rechteck(20, 30);\nr2.print();\nSystem.out.println(\"Umfang des Rechtecks : \" + r2.umfang());\n</code></pre> <p>und erhalten dann die Ausgaben:</p> <pre><code>------- Objekte von Rechteck erzeugen ------------\n\n[ a=10, b=20, c=10, d=20 ]  Umfang des Vierecks : 60\nUmfang des Rechtecks : 60\n[ a=20, b=30, c=20, d=30 ]  Umfang des Vierecks : 100\nUmfang des Rechtecks : 100\n</code></pre> <p>Wichtig ist, dass <code>Rechteck</code> alle Objektvariablen und Objektmethoden der Klasse <code>Viereck</code> geerbt hat. Allerdings sind die Objektvariablen <code>a</code>, <code>b</code>, <code>c</code> und <code>d</code> in <code>Viereck</code> als <code>private</code> deklariert und deshalb kann nur in <code>Viereck</code> auf diese Objektvariablen zugegriffen werden. Wenn wir auch in <code>Rechteck</code> darauf zugreifen wollen, dann m\u00fcssen wir die Sichtbarkeit der Objektvariablen \u00e4ndern. Das wollen wir im n\u00e4chsten Schritt machen.</p>"},{"location":"vererbung/#der-sichtbarkeitsmodifizierer-protected","title":"Der Sichtbarkeitsmodifizierer <code>protected</code>","text":"<p>Wir kennen bisher zwei Sichtbarkeitsmodifizierer (auch Zugriffsmodifizierer): <code>private</code> und <code>public</code>. </p> <ul> <li>auf Objektvariablen und -methoden, die als <code>private</code> deklariert wurden, kann nur innerhalb der Klasse zugegriffen werden,</li> <li>auf Objektvariablen und -methoden, die als <code>public</code> deklariert wurden, kann in allen anderen Klassen (auch Klassen aus anderen Paketen) zugegriffen werden. </li> </ul> <p>Wir lernen jetzt einen weiteren Sichtbarkeitsmodifizierer kennen: <code>protected</code>.</p> <p>Auf Objektvariablen und -methoden, die als <code>protected</code> deklariert wurden, kann in den Klassen einer Vererbungshierarchie zugegriffen werden. </p> <p>Bis jetzt k\u00f6nnen wir in der Klasse <code>Rechteck</code> nicht auf die Objektvariablen <code>a</code>, <code>b</code>, <code>c</code> und <code>d</code> zugreifen, da diese in <code>Viereck</code> als <code>private</code> deklariert wurden und deshalb nur innerhalb von <code>Viereck</code> zugreifbar sind. Aus Gr\u00fcnden der Datenkapselung sollen diese aber auch nicht <code>public</code> sein. Wir deklarieren sie deshalb als <code>protected</code>:</p> <pre><code>public class Viereck\n{\n    protected int a,b,c,d;          // Seiten innerhalb der Vererbungshierarchie sichtbar\n\n    public Viereck(int a, int b, int c, int d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public int umfang()\n    {\n        return this.a + this.b + this.c + this.d;\n    }\n\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.println(\" Umfang des Vierecks : \" + this.umfang());\n    }\n\n}\n</code></pre> <p>Nun kann auf die Objektvariablen in allen abgeleiteten Klassen (also in <code>Rechteck</code>) zugegriffen werden. Nicht aber in anderen Klassen. Man muss also von <code>Viereck</code> erben, um Zugriff auf die als <code>protected</code> deklarierten Variablen zu bekommen. </p>"},{"location":"vererbung/#erweitern-der-klasse-rechteck-um-eine-weitere-eigenschaft","title":"Erweitern der Klasse <code>Rechteck</code> um eine weitere Eigenschaft","text":"<p><code>Rechteck</code> hat alle Eigenschaften von <code>Viereck</code> geerbt. Ganz am Anfang des Vererbungskapitels haben wir aber gesagt, dass speziellere Klassen auch speziellere Eigenschaften haben k\u00f6nnen. Wir wollen <code>Rechteck</code> nun eine weitere Eigenschaft hinzuf\u00fcgen: die Objektmethode <code>flaecheninhalt()</code>:</p> <pre><code>public class Rechteck extends Viereck\n{\n    public Rechteck(int laenge, int breite)\n    {\n        super(laenge, breite, laenge, breite);  // Aufruf des Konstruktors von Viereck\n    }\n\n    /*\n     *  neue Objektmethode\n     *  spezielle Eigenschaft fuer Rechteck \n     *  gilt nicht f\u00fcr Viereck\n     *  \n     */\n    public int flaecheninhalt()\n    {\n        return this.a * this.b;     // Zugriff moeglich wegen protected in Viereck\n    }\n}\n</code></pre> <p>Die Klasse <code>Rechteck</code> hat somit eine weitere Eigenschaft. Diese ist nicht von <code>Viereck</code> geerbt, sondern ist eine spezielle Eigenschaft von <code>Rechteck</code>. Die Klasse <code>Viereck</code> besitzt diese Eigenschaft nicht! Das bedeutet, dass f\u00fcr Objekte der Klasse <code>Viereck</code> existiert die Eigenschaft <code>flaecheninhalt()</code> nicht, f\u00fcr Objekte der Klasse <code>Rechteck</code> aber schon. In der Testklasse k\u00f6nnen wir die neue Methode testen:</p> <pre><code>public void main()\n{\n    System.out.printf(\"%n%n------- Objekte von Viereck erzeugen ------------%n%n\");\n\n    Viereck v1 = new Viereck(10,20,30,40);\n    v1.print();\n\n    Viereck v2 = new Viereck(15,20,25,20);\n    v2.print();\n\n    System.out.printf(\"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\");\n    Rechteck r1 = new Rechteck(10, 20);\n    r1.print();\n    System.out.println(\"Umfang des Rechtecks : \" + r1.umfang());\n    System.out.println(\"Flaecheninhalt des Rechtecks \" + r1.flaecheninhalt());\n\n    Rechteck r2 = new Rechteck(20, 30);\n    r2.print();\n    System.out.println(\"Umfang des Rechtecks : \" + r2.umfang());\n    System.out.println(\"Flaecheninhalt des Rechtecks \" + r2.flaecheninhalt());\n\n}\n</code></pre> <p>und erhalten dann die Ausgaben (hier nur f\u00fcr <code>Rechteck</code> gezeigt):</p> <pre><code>------- Objekte von Rechteck erzeugen ------------\n\n[ a=10, b=20, c=10, d=20 ]  Umfang des Vierecks : 60\nUmfang des Rechtecks : 60\nFlaecheninhalt des Rechtecks 200\n[ a=20, b=30, c=20, d=30 ]  Umfang des Vierecks : 100\nUmfang des Rechtecks : 100\nFlaecheninhalt des Rechtecks 600\n</code></pre> <p>Beachten Sie, es ist nicht m\u00f6glich, die Objektmethode <code>flaecheninhalt()</code> f\u00fcr die Objekte von <code>Viereck</code> aufzurufen! F\u00fcr diese Objekte existiert die Eigenschaft nicht!</p> <pre><code>public void main()\n{\n    System.out.printf(\"%n%n------- Objekte von Viereck erzeugen ------------%n%n\");\n\n    Viereck v1 = new Viereck(10,20,30,40);\n    v1.print();\n    // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt());    // existiert nicht!!!\n\n    Viereck v2 = new Viereck(15,20,25,20);\n    v2.print();\n    // System.out.println(\"Flaecheninhalt des Vierecks \" + v1.flaecheninhalt());    // existiert nicht!!!\n}\n</code></pre>"},{"location":"vererbung/#uberschreiben-von-methoden","title":"\u00dcberschreiben von Methoden","text":"<p>Die Klasse <code>Rechteck</code> hat unter anderem die Objektmethode <code>print()</code> von der Klasse <code>Viereck</code> geerbt. Wir k\u00f6nnen geerbte Methoden entweder so lassen, wie wir sie geerbt haben oder wir implementieren sie neu. Das Neuimplementieren von geerbten Methoden nennt sich \u00dcberschreiben. </p> <p>Wird eine Methode von der Elternklasse geerbt, diese Methode in der Kindklasse jedoch neu implementiert, so wird diese Methode \u00fcberschrieben. </p> <p>Die geerbte <code>print()</code>-Methode gef\u00e4llt uns nicht wirklich gut, denn </p> <ol> <li>erfolgt innerhalb der Methode die Ausschrift <code>Umfang des Vierecks</code> anstelle von <code>Umfang des Rechtecks</code> und</li> <li>k\u00f6nnten wir die <code>print()</code>-Methode in <code>Rechteck</code> um die Ausgabe des Fl\u00e4cheninhaltes des Rechteckes erweitern. </li> </ol> <p>Wir wollen deshalb diese Methode \u00fcberschreiben:</p> <pre><code>public class Rechteck extends Viereck\n{\n    public Rechteck(int laenge, int breite)\n    {\n        super(laenge, breite, laenge, breite);  // Aufruf des Konstruktors von Viereck\n    }\n\n    /*\n     *  neue Objektmethode\n     *  spezielle Eigenschaft fuer Rechteck \n     *  gilt nicht f\u00fcr Viereck\n     *  \n     */\n    public int flaecheninhalt()\n    {\n        return this.a * this.b;     // Zugriff moeglich wegen protected in Viereck\n    }\n\n    @Override\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.print(\" Umfang des Rechtecks : \" + this.umfang());\n        System.out.println(\" Flaecheninhalt des Rechtecks : \" + this.flaecheninhalt());\n    }\n}\n</code></pre> <p>In den Zeilen <code>20-26</code> haben wir nun die Methode <code>print()</code> neu implementiert, d.h. wir haben sie \u00fcberschrieben. Beachten Sie die sogenannte Annotation <code>@Override</code>, die direkt \u00fcber dem Methodenkopf steht. Mit dieser Annotation geben wir dem Compiler an, dass die folgende Methode \u00fcberschrieben wird. Der Compiler pr\u00fcft nun, ob wir die Methode \u00fcberhaupt so geerbt haben, wie wir sie \u00fcberschreiben, d.h. es wird \u00fcberpr\u00fcft, ob</p> <ol> <li>der Name der Methode korrekt ist (wir m\u00fcssen eine Methode geerbt haben, die genau so hei\u00dft - auch hier Gro\u00df- und Kleinschreibung beachten), </li> <li>die Anzahl und die Typreihenfolge der Parameter mit der geerbten Methode \u00fcbereinstimmen (die Namen der Parameter sind egal),</li> <li>der R\u00fcckgabetyp der Methode mit der geerbten Methode \u00fcbereinstimmt (der kann innerhalb der Vererbungshierarchie ge\u00e4ndert werden, aber das ist ein sp\u00e4teres Thema),</li> <li>die Sichtbarkeit nicht eingeschr\u00e4nkt wird (eine Methode, die in der Elternklasse als <code>public</code> deklariert wurde, darf beim \u00dcberschreiben nicht <code>protected</code> oder <code>private</code> werden).</li> </ol> <p>Wir m\u00fcssen in der Testklasse nun gar nichts \u00e4ndern, es wird f\u00fcr die Rechteck-Objekte die neue Implementierung der <code>print()</code>-Methode verwendet:</p> <pre><code>public void main()\n{\n    System.out.printf(\"%n%n------- Objekte von Viereck erzeugen ------------%n%n\");\n\n    Viereck v1 = new Viereck(10,20,30,40);\n    v1.print();\n\n    Viereck v2 = new Viereck(15,20,25,20);\n    v2.print();\n\n    System.out.printf(\"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\");\n    Rechteck r1 = new Rechteck(10, 20);\n    r1.print();\n\n    Rechteck r2 = new Rechteck(20, 30);\n    r2.print();\n}\n</code></pre> <p>erzeugt folgende Ausgaben:</p> <pre><code>------- Objekte von Viereck erzeugen ------------\n\n[ a=10, b=20, c=30, d=40 ]  Umfang des Vierecks : 100\n[ a=15, b=20, c=25, d=20 ]  Umfang des Vierecks : 80\n\n\n------- Objekte von Rechteck erzeugen ------------\n\n[ a=10, b=20, c=10, d=20 ]  Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200\n[ a=20, b=30, c=20, d=30 ]  Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600\n</code></pre> <p>Wir werden das \u00dcberschreiben von Methoden noch weiter \u00fcben, wenn wir uns mit der Klasse <code>Object</code> besch\u00e4ftigen. Wir merken uns zun\u00e4chst, dass wir geerbte Methoden \u00fcberschreiben k\u00f6nnen und dass wir die Annotation <code>@Override</code> verwenden sollten, wenn wir eine Methode \u00fcberschreiben, um zu vermeiden, dass wir - z.B. weil wir den Namen der Methode falsch schreiben - die Methode gar nicht \u00fcberschreiben, sondern eine neue Methode hinzuf\u00fcgen. </p> <p>\u00dcbrigens : Wir kennen das Schl\u00fcsselwort <code>final</code> ja bereits von Variablen. Eine als <code>final</code> deklarierte Variable kann ihren einmal zugewiesenen Wert nicht mehr \u00e4ndern. Wir haben mit <code>final</code> sogenannte Konstanten definiert. </p> <p>Eine als <code>final</code> deklarierte Methode kann nicht \u00fcberschrieben werden!</p> <p>Von einer als <code>final</code> deklarierten Klasse kann nicht geerbt werden!</p>"},{"location":"vererbung/#die-klasse-quadrat","title":"Die Klasse <code>Quadrat</code>","text":"<p>Das folgende Beispiel dient nur zur Wiederholung. Wir erben nun eine Klasse <code>Quadrat</code> von der Klasse <code>Rechteck</code>.</p> <pre><code>public class Quadrat extends Rechteck\n{\n    Quadrat(int seite)\n    {\n        super(seite, seite);    // Aufruf des Konstruktors von Rechteck\n    }\n\n    @Override\n    public void print()\n    {\n        System.out.print(\"[ a=\" + this.a + \", b=\" + this.b \n                + \", c=\" + this.c + \", d=\" + this.d + \" ] \");\n        System.out.print(\" Umfang des Quadrats : \" + this.umfang());\n        System.out.println(\" Flaecheninhalt des Quadrats : \" + this.flaecheninhalt());\n    }\n}\n</code></pre> <ul> <li>In Zeile <code>1</code> geben wir mithilfe von <code>extends Rechteck</code> an, dass die Klasse <code>Quadrat</code> von der Klasse <code>Rechteck</code> erbt.</li> <li>In den Zeilen <code>3-6</code> definieren wir den Konstruktor von <code>Quadrat</code>. Darin rufen wir als erstes den Konstruktor von <code>Rechteck</code> auf. Der Konstruktor von <code>Quadrat</code> erwartet nur noch eine Parameter, da im Quadrat alle Seiten gleich lang sind. Den Wert des Parameters \u00fcbergeben wir dem Konstruktor von <code>Rechteck</code>, der zwei Parameterwerte erwartet (f\u00fcr <code>laenge</code> und <code>breite</code>). </li> <li>In den Zeilen <code>8-15</code> \u00fcberschreiben wir wieder die <code>print()</code>-Methode und passen sie an das Quadrat an. </li> </ul> <p>Beachten Sie, dass <code>Quadrat</code> alle Eigenschaften von <code>Rechteck</code> erbt, also </p> <ul> <li>die Objektvariablen <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> und</li> <li>die Objektmethoden <code>print()</code>, <code>umfang()</code> und <code>flaecheninhalt()</code>.</li> </ul> <p>Die Testklasse k\u00f6nnten wir nun wie folgt erweiteren:</p> <pre><code>public void main()\n{\n    System.out.printf(\"%n%n------- Objekte von Viereck erzeugen ------------%n%n\");\n\n    Viereck v1 = new Viereck(10,20,30,40);\n    v1.print();\n\n    Viereck v2 = new Viereck(15,20,25,20);\n    v2.print();\n\n    System.out.printf(\"%n%n------- Objekte von Rechteck erzeugen ------------%n%n\");\n    Rechteck r1 = new Rechteck(10, 20);\n    r1.print();\n\n    Rechteck r2 = new Rechteck(20, 30);\n    r2.print();\n\n    System.out.printf(\"%n%n------- Objekte von Quadrat erzeugen ------------%n%n\");\n    Quadrat q1 = new Quadrat(30);\n    q1.print();\n\n    Quadrat q2 = new Quadrat(40);\n    q2.print();\n}\n</code></pre> <p>und bek\u00e4men folgende Ausgaben:</p> <pre><code>------- Objekte von Viereck erzeugen ------------\n\n[ a=10, b=20, c=30, d=40 ]  Umfang des Vierecks : 100\n[ a=15, b=20, c=25, d=20 ]  Umfang des Vierecks : 80\n\n\n------- Objekte von Rechteck erzeugen ------------\n\n[ a=10, b=20, c=10, d=20 ]  Umfang des Rechtecks : 60 Flaecheninhalt des Rechtecks : 200\n[ a=20, b=30, c=20, d=30 ]  Umfang des Rechtecks : 100 Flaecheninhalt des Rechtecks : 600\n\n\n------- Objekte von Quadrat erzeugen ------------\n\n[ a=30, b=30, c=30, d=30 ]  Umfang des Quadrats : 120 Flaecheninhalt des Quadrats : 900\n[ a=40, b=40, c=40, d=40 ]  Umfang des Quadrats : 160 Flaecheninhalt des Quadrats : 1600\n</code></pre> <p>Success</p> <p>Mit Vererbung haben wir ein wichtiges Konzept der objektorientierten Programmierung kennengelernt. Um von einer Klasse zu erben, verwenden wir das Schl\u00fcsselwort <code>extends</code>. Eine Kindklasse erbt von ihrer Elternklasse alle Eigenschaften, also alle Objektvariablen und Objektmethoden. Eine geerbte Methode kann in der Kindklasse \u00fcberschrieben werden. Wird eine Methode \u00fcberschrieben, verwenden wir die Annotation <code>@Override</code>. Im Konstruktor der Kindklasse wird der Konstruktor der Elternklasse aufgerufen. Dies kann implizit erfolgen, wenn der implizite Konstruktor der Elternklasse existiert, oder es erfolgt explizit durch die Verwendung des Schl\u00fcsselwortes <code>super</code>. Mithilfe von Vererbung erh\u00f6hen wir die Wiederverwendbarkeit von Code und vermeiden doppelte Implementierungen. Au\u00dferdem sorgen wir f\u00fcr eine bessere Strukturierung des Codes. </p>"}]}